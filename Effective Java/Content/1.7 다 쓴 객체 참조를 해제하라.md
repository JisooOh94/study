# 다 쓴 객체 참조 해제
* java는 개발자가 직접 다 쓴 객체 참조에 대해 GC 가 자동으로 메모리를 수거해 감으로서, 메모리 누수 방지
* 그럼에도 불구하고 메모리 누수의 위험이 있는 경우 존재
## 가비지 콜렉팅 대상이 되는경우
### 1. 직접 참조 해제
* 코드를 통해 직접 참조변수에 null을 할당하는 것
* 코드가 지저분해지기 때문에 특수한 경우를 아니면 가급적 사용 지양
* 클래스 내에서 인스턴스에 대한 참조를 직접 관리하는 경우에 사용
### 2. Scope를 통한 자동 참조 해제
* 참조변수의 스코프를 최대한 작은 범위에서 선언하여 스코프가 끝남과 동시에 자동으로 참조 해제

<br>

## 주로 메모리 누수가 발생하는 케이스
### 메모리를 직접 관리하는 클래스
```java
	public class Stack {
	    private Object[] elements;	인스턴스에 대한 참조를 직접 관리
	    private int size = 0;

	    public Stack() {
	        elements = new Object[10];
	    }

	    public void push(Object e) {
	        ensureCapacity();
	        elements[size++] = e;
	    }
	
	    public Object pop() throws Exception {
	        if (size == 0)
	            throw new Exception();
	        return elements[--size];	//더이상 사용되지 않음에도 참조가 해제되지 않음
	    }
	}
	//Stack 인스턴스의 생명주기가 끝나면 elements의 참조도 모두 해제?????
```
### 캐시
* 객체를 캐싱한 후, 더이상 해당 객체를 사용할 일이 없어졌음에도 캐시에서 삭제하지 않아 방치되는 경우
* 약한참조를 사용하거나 백그라운드 스레드 또는 엔트리 추가시의 부수작업등으로 사용되지않는 오래된 캐시데이터 정리

### 리스너, 콜백
* 클라이언트 코드가 리스너, 콜백을 등록할 수 있는 api만 제공하고 해제할 수 있는 api를 제공하지 않는다거나 혹은  사용이 끝난 후 해제를 하지 않아 방치되는 경우
* 약한참조를 통해 자동으로 참조 해제