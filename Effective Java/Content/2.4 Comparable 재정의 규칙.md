# Comparable 재정의 규칙
### Comparable 인터페이스
```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```
* equals 처럼 두 객체를 비교하나 그 결과가 boolean이 아닌, integer로 반환
* source > target : -1
  source = target : 0
  source < target : 1
* 순서가 명확한 클래스(e.g. 순번, 알파벳, 그룹 등) 정의시 Comparable 인터페이스를 구현하는것이 좋음 
### Comparable 인터페이스 구현시 효과
* equals 처럼 동치성 비교 뿐만 아니라 두 값의 대소 비교도 가능
* 유틸리티 클래스인 Collections나 Arrays 에서 제공하는 정렬 및 탐색 알고리즘, 극단값 계산 등 사용가능
* 정렬 컬렉션인 TreeSet, TreeMap 사용 가능

> 책에서는 '좁쌀만 한 노력으로 코끼리만 한 큰 효과를 얻는것이다' 라고 되어있음...

### Comparable 일반 규약
1. x.compareTo(y) < 0 이면 0 < y.compareTo(x) 이어야 한다.
2. x.compareTo(y) < 0 이고 y.compareTo(z) < 0 이면 x.compareTo(z) < 0 이어야 한다.
3. x.compareTo(y) == 0 이고, x.compareTo(z) == 0 이면 y.compareTo(z) == 0 이어야 한다.  

### compareTo 와 equals
* comparable 인터페이스 구현시, equals 메서드도 재정의 해주어야 한다.
* compareTo와 equals의 동치성 비교 결과가 동일하지 않을경우, 자료구조마다 동작이 달라진다.
#### e.g. TreeMap 과 HashMap
* TreeMap, TreeSet 과 같은 정렬된 컬렉션 객체들은 동치성 비교시 eqauls가 아닌, compareTo를 사용한다.
* 반면에 HashMap, HashSet 등의 일반 컬렉션 객체들은 동치성 비교시 eqauls 를 사용한다.
* compareTo 를 구현한 클래스에서 equals를 재정의하지않으면, 해당 클래스 객체를 TreeMap 과 HashMap 에 사용했을때 다르게 동작할것이다.
```java
@Test
public void test() {
	BigDecimal bigDecimal = new BigDecimal("1.0");
	BigDecimal bigDecima2 = new BigDecimal("1.00");
	
	Map<BigDecimal, String> normalMap = new HashMap<>();
	TreeMap<BigDecimal, String> treeMap = new TreeMap<>();
	
	normalMap.put(bigDecimal, "bigDecimal_1");
	treeMap.put(bigDecimal, "bigDecimal_1");
	
	normalMap.put(bigDecima2, "bigDecimal_2");
	treeMap.put(bigDecima2, "bigDecimal_2");
	
	System.out.println(normalMap);	//{1.0 = bigDecimal_1, 1.00 = bigDecimal_2}
	System.out.println(treeMap);	//{1.0 = bigDecimal_2}
}
```

### compareTo 구현 
* 필드 값 비교시, 비교 연산자(>, <, ==) 가 아닌, 필드 데이터 타입의 레퍼런스 타입에서 제공하는 compare 메서드를 사용한다.
```java
public int compareTo(Foo foo) {
	return Integer.compare(this.var, foo.getVar());
}
```
* 비교에 사용하고자 하는 필드(핵심필드)가 많을경우, 가장 핵심적인 것부터 비교해 나가며 동치가 아닌(!=0) 필드가 나오면 결과 return
```java
public int compareTo(PhoneNumber phoneNubmer) {
	int result = Integer.compare(this.areaCode, phoneNubmer.areaCode);
	if(result == 0) {
		result = Integer.compare(this.prefix, phoneNubmer.prefix);
		if(result == 0) {
			result = Integer.compare(this.lineNum, phoneNubmer.lineNum);
		}
	}
	
	return result;
}
```
* 필드에 또다른 객체 참조가 있을경우, 재귀적으로 compareTo 호출

### 비교자 생성 메서드
* Java 8 부터는 비교자 생성메서드를 통해 Comparator 객체를 생성하여 compareTo에 사용 가능
* 빌더패턴처럼 메서드 연쇄 방식으로 비교자를 계속 이어붙여 하나의 Comparator 객체에 담을 수 있음
```java
private static final Comparator<PhoneNumber> PHONE_NUMBER_COMPARATOR =
			comparingInt((PhoneNumber phoneNumber) -> phoneNumber.areaCode)
					.thenComparingInt(phoneNumber -> phoneNumber.prefix)
					.thenComparingInt(phoneNumber -> phoneNumber.lineNum);

public int compareTo(PhoneNumber phoneNumber) {
	return PHONE_NUMBER_COMPARATOR.compare(this, phoneNumber);
}
```