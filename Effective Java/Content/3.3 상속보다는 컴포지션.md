# 클래스 상속의 단점
## 1. 캡슐화 침해
### 자식클래스가 부모클래스에 의존하는 경우
* 자식클래스 메서드 내부에서 부모클래스 메서드 사용시, 부모클래스 수정에 영향 받음
* 부모클래스 메서드를 사용하지 않고 똑같이 자식클래스에 구현해도 되나, 그만큼 구현시간이 소요되고 기능이 복잡할경우 버그를 발생시킬 수도 있음

```java
public class Parent {
   public List<Integer> getRangeList(int min, int max) {
   	List<Integer> list = new LinkedList<>();
   	
   	for(int i = min; i < max; i++) {		//만약 max값까지 포함하게 수정한다면?
   		list.add(i);
   	}
   	
   	return list;
   }
}

public class Child extends Parent{
   public int getSumOfRange(int min, int max) {
   	List<Integer> rangeList = super.getRangeList(min, max);		//자식클래스 메서드의 결과값이 달라짐
   	return rangeList.stream().collect(Collctors.summingInt(Integer::intValue));
   }
}
```

### 부모클래스가 자식클래스에 의존하는 경우
* 부모클래스에서 재정의 가능메서드를 자기사용시, 자식클래스 수정에 영향 받음
* 부모클래스 메서드를 재정의하는 대신, 개별적인 메서드로 만든다면 의존성에 의한 문제는 해결 될 수 있으나, 장기적 관점에서 문제 발생 여지가 많음
---> 다음 릴리즈때, 상위클래스에 새로운 메서드를 추가하는데, 우연히 자식클래스 메서드와 시그니처가 동일한경우
```java
public class Parent {
    public int getSumOfRange(int min, int max) {
        List<Integer> rangeList = this.getRangeList(min, max);
        return rangeList.stream().collect(Collctors.summingInt(Integer::intValue));
    }
    
    protected List<Integer> getRangeList(int min, int max) {
        List<Integer> list = new LinkedList<>();

        for(int i = min; i < max; i++) {
            list.add(i);
        }

        return list;
    }
}

public class Child extends Parent{
	@Override
    protected List<Integer> getRangeList(int min, int max) {
        List<Integer> list = new LinkedList<>();
        for(int i = min; i <= max; i++) {		//max 값도 포함하는 정수 리스트를 생성하여 반환한다.
            list.add(i);
        }
        return list;
    }
}

Child child = new Child();
child.getSumOfRange(0, 5); 	//재정의 가능메서드(getRangeList)를 자기사용하고 있던 부모객체 메서드(getSumOfRange)에서 의도치 않게 재정의된 자식객체 메서드(getRangeList) 호출
```

```java
public class HashSet {
   private Set<Integer> set;

   public void add(int elem) {
      set.add(elem);
   }
   
   public void addAll(Collection<Integer> c) {
   	  ...
      for(Integer value : c) {
         add(value);
      }
   }
}

public class AdvancedHashSet extends HashSet {
	private int addCount = 0;
   
	@Override
	public void add(int elem) {
	    addCount++;
	    return super.add(elem);
	}

	@Override
	public boolean addAll(Collection<Integer> c) {
	    addCount += c.size();	//HashSet의 addAll 메서드는 add 메서드를 다시 호출하여 처리함
	    super.addAll(c);			//자식클래스의 @Override된 add가 호출되어 addCount 에 c.size() *2가 더해짐						   
	}
}
```

## 2. 부모클래스 메서드 직접 접근 가능
* 클라이언트에서 자식클래스 객체를 통해 부모클래스 메서드 직접 호출이 가능함 ---> 사용자의 혼란 유발

```java
Properteis properties = new Porperties;

//HashTable을 상속받은 java.util.Properteis은 getProperty(key), get(key) 모두 호출 가능하여 사용자의 혼란 유발
properties.getProperty(key);
properties.get(key);
```

### 자식 클래스 불변성 침해
* 클라이언트에서 자식클래스 객체의 부모클래스 메서드를 호출하여 개발자가 예상치 못한 데이터 수정을 일으킬 수 있음 > 자식클래스 불변식 파괴

```java
//Positive List
public class PositiveIntList<Integer> extends ArrayList<Integer> {
	private List<Integer> elems = new ArrayList<Integer>();
	public void addPositiveElem(int elem) {
		if(elem <= 0)
			return;
		this.elems.add(elem);
	}
}

PositiveIntList<Integer> positiveList = new PositiveIntList<>();
positiveList.addPositiveElem(5);
positiveList.add(-5);
```

## 3. 부모클래스 메서드의 결함 승계
* 상속받고자 하는 부모클래스 메서드에 결함이 있을경우 이를 상속받은 자식 클래스에도 메서드를 재정의 하지 않으면 그 결함이 그대로 이어짐

# 컴포지션(HAS-A)
* 상속을 목적으로 신중하게 구현된 클래스가 아닌, 일반클래스의 기능을 확장하고자 할경우 상속보다는 컴포지션을 통한 확장이 더 안전하고 효율적이다.
* 클래스 기능 확장시, 상속 대신, 확장하고자 하는 클래스 인스턴스를 private 필드로 가지는 새로운 클래스 정의
* 확장 클래스의 메서드 정의시, 기존 클래스의 동일한 메서드를 호출하면서 덧붙이고자 하는 기능을 추가

```java
public class AdvancedHashSet {
	private HashSet<Integer> set;
	private int addCount = 0;
   
	public AdvancedHashSet(HashSet<Integer> set) {
		this.set = set;
	}
	
	public boolean add(int elem) {
	    addCount++;
		return set.add(elem);	//기존 클래스의 메서드 호출
	}

	public boolean addAll(Collection<int> c) {
	   addCount += c.size();
	   set.addAll(c);		//기존 클래스의 메서드 호출 > AdvancedHashSet의 addAll과는 별개
	}
}
```

* 이를 통해, 기존 클래스와 확장 클래스 사이의 의존성을 없애고 서로의 수정에 영향을 더이상 받지 않음 

* 기능확장이 빈번하게 발생하는 경우, 별도의 재사용 가능한 전달클래스(포워딩클래스)를 정의하고 전달클래스를 상속받아 기능을 확장하는 레퍼클래스 구현

```java
//포워딩 클래스
public class ForwardingSet<Integer> implements Set<Integer> {
	//Set의 모든 api 구현
	private final Set<Integer> set;

	public ForwardingSet(Set<Integer> set) {
		this.set = set;
	}

	public void clear() { set.clear(); }
	public boolean contains(Integer itg) { return set.contains(itg); }
	public boolean add(int num) { return set.add(num); }
	...
}

//레퍼 클래스
public class AdvancedHashSet extends ForwardingSet{
	private HashSet<Integer> set;
	private int addCount = 0;
   
	public AdvancedHashSet(HashSet<Integer> set) {
		super(set);
	}
	
	public boolean add(int elem) {
	    addCount++;
		return super.add(elem);	//기존 클래스의 메서드 호출
	}

	public boolean addAll(Collection<int> c) {
		addCount += c.size();
		return super.addAll(c);		//기존 클래스의 메서드 호출 > AdvancedHashSet의 addAll과는 별개
	}
}
```

### 단점
* 콜백프레임워크에는 부적절

### 상속과 컴포지션
* 기존 클래스와 확장하고자 하는 클래스가 IS-A 관계일 때에만 상속을 사용하고 그 외의 모든 경우에는 컴포지션을 사용하는것이 안전하고 견고함