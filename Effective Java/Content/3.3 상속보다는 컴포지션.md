# 클래스 상속의 단점
## 1. 캡슐화 침해
### 자식클래스가 부모클래스에 의존하는 경우
* 자식클래스 메서드 내부에서 부모클래스 메서드 사용시, 부모클래스 수정에 영향 받음
* 부모클래스 메서드를 사용하지 않고 똑같이 자식클래스에 구현해도 되나, 그만큼 구현시간이 소요되고 기능이 복잡할경우 버그를 발생시킬 수도 있음

```java
public class Parent {
   public List<Integer> getRangeList(int min, int max) {
   	List<Integer> list = new LinkedList<>();
   	for(int i = min; i < max; i++) {
   		list.add(i);
   	}
   	return list;
   }
}

public class Child extends Parent{
    public int getSumOfRange(int min, int max) {
        List<Integer> rangeList = super.getRangeList(min, max);
        return rangeList.stream().collect(Collctors.summingInt(Integer::intValue));
    }
}

Child child = new Child();
int result_1 = child.getSumOfRange(0, 5);   //10
//Parnet 클래스의 getRangeList 메서드를 max값까지 포함한 list로 생성하도록 수정하면?
int result_2 = child.getSumOfRange(0, 5);   //15
//Child 클래스는 아무것도 수정하지 않았으나 getSumOfRange 결과값이 달라짐
```

### 부모클래스가 자식클래스에 의존하는 경우
* 부모클래스에서 재정의 가능메서드를 자기사용시, 자식클래스 수정에 영향 받음
* 부모클래스 메서드를 재정의하는 대신, 개별적인 메서드로 만든다면 의존성에 의한 문제는 해결 될 수 있으나, 장기적 관점에서 문제 발생 여지가 많음
---> 다음 릴리즈때, 상위클래스에 새로운 메서드를 추가하는데, 우연히 자식클래스 메서드와 시그니처가 동일한경우
```java
public class Parent {
    public int getSumOfRange(int min, int max) {
        List<Integer> rangeList = this.getRangeList(min, max);
        return rangeList.stream().collect(Collctors.summingInt(Integer::intValue));
    }
    
    protected List<Integer> getRangeList(int min, int max) {
        List<Integer> list = new LinkedList<>();

        for(int i = min; i < max; i++) {        //max 값을 포함하지 않는 정수 리스트를 생성하여 반환한다.
            list.add(i);
        }

        return list;
    }
}

public class Child extends Parent{
	@Override
    protected List<Integer> getRangeList(int min, int max) {
        List<Integer> list = new LinkedList<>();
        for(int i = min; i <= max; i++) {		//max 값도 포함하는 정수 리스트를 생성하여 반환한다.
            list.add(i);
        }
        return list;
    }
}

Parent parent = new Parent();
int result_1 = parent.getSumOfRange(0, 5);  //10

Child child = new Child();
int result_2 = child.getSumOfRange(0, 5);   //15 //부모클래스는 수정하지 않았으나, 자식객체를 통해 호출한 부모클래스 메서드의 결과값이 달라짐 	
//재정의 가능메서드(getRangeList)를 자기사용하고 있던 부모객체 메서드(getSumOfRange)에서 의도치 않게 재정의된 자식객체 메서드(getRangeList) 호출
```

## 2. 부모클래스 메서드 직접 접근 가능
* 클라이언트에서 자식클래스 객체를 통해 부모클래스 메서드 직접 호출이 가능함 ---> 사용자의 혼란 유발

```java
Properteis properties = new Porperties;

//HashTable을 상속받은 java.util.Properteis은 getProperty(key), get(key) 모두 호출 가능하여 사용자의 혼란 유발
properties.getProperty(key);
properties.get(key);
```

### 자식 클래스 불변성 침해
* 클라이언트에서 자식클래스 객체를 통해 부모클래스 메서드를 호출하여 개발자가 예상치 못한 데이터 수정을 일으킬 수 있음 > 자식클래스 불변식 파괴

```java
//Positive List
public class PositiveIntList<Integer> extends ArrayList<Integer> {
	private List<Integer> elems = new ArrayList<Integer>();
	public void addPositiveElem(int elem) {
		if(elem <= 0)
			return;
		this.elems.add(elem);
	}
}

PositiveIntList<Integer> positiveList = new PositiveIntList<>();
positiveList.addPositiveElem(5);
positiveList.add(-5);
```

## 3. 부모클래스 메서드의 결함 승계
* 상속받고자 하는 부모클래스 메서드에 결함이 있을경우 이를 상속받은 자식 클래스에도 메서드를 재정의 하지 않으면 그 결함이 그대로 이어짐

# 컴포지션(HAS-A)
* 상속을 목적으로 신중하게 구현된 클래스가 아닌, 일반클래스의 기능을 확장하고자 할경우 상속보다는 컴포지션을 통한 확장이 더 안전하고 효율적이다.
* 클래스 기능 확장시, 상속 대신, 확장하고자 하는 클래스 인스턴스를 private 필드로 가지는 새로운 클래스 정의
* 확장 클래스의 메서드 정의시, 기존 클래스의 동일한 메서드를 호출하면서 덧붙이고자 하는 기능을 추가
```java
public class Parent {
    public int getSumOfRange(int min, int max) {
        List<Integer> rangeList = this.getRangeList(min, max);
        return rangeList.stream().collect(Collctors.summingInt(Integer::intValue));
    }
    
    public List<Integer> getRangeList(int min, int max) {
        List<Integer> list = new LinkedList<>();
        for(int i = min; i < max; i++) {
            list.add(i);
        }
        return list;
    }
}

public class Child{
    private Parent parent = new Parent();
    
    public List<Integer> getClosedRagneList(int min, int max) {
        return parent.getRangeList(min, max + 1);
    }

    public int getSumOfRangeClosed(int min, int max) {
        parent.getSumOfRange(min, max + 1);
    }
}

Parent parent = new Parent();
int result_1 = parent.getSumOfRange(0, 5);   //10

Child child = new Child();
int result_2 = child.getSumOfRange(0, 5);   //10

//부모객체의 메서드와 자식객체의 동일한 메서드의 결과값도 동일하면서,
//기능을 확장한 확장메서드 또한 정상적으로 동작
int result_3 = child.getSumOfRangeClosed(0, 5)  //15
```

* 이를 통해, 기존 클래스와 확장 클래스 사이의 의존성을 없애고 서로의 수정에 영향을 더이상 받지 않음 

* 기능확장이 빈번하게 발생하는 경우, 별도의 재사용 가능한 전달클래스(포워딩클래스)를 정의하고 전달클래스를 상속받아 기능을 확장하는 레퍼클래스 구현

```java
//포워딩 클래스
public class ForwardingParent {
    
}
public class ForwardingSet<Integer> implements Set<Integer> {
	//Set의 모든 api 구현
	private final Set<Integer> set;

	public ForwardingSet(Set<Integer> set) {
		this.set = set;
	}

	public void clear() { set.clear(); }
	public boolean contains(Integer itg) { return set.contains(itg); }
	public boolean add(int num) { return set.add(num); }
	...
}

//레퍼 클래스
public class AdvancedHashSet extends ForwardingSet{
	private HashSet<Integer> set;
	private int addCount = 0;
   
	public AdvancedHashSet(HashSet<Integer> set) {
		super(set);
	}
	
	public boolean add(int elem) {
	    addCount++;
		return super.add(elem);	//기존 클래스의 메서드 호출
	}

	public boolean addAll(Collection<int> c) {
		addCount += c.size();
		return super.addAll(c);		//기존 클래스의 메서드 호출 > AdvancedHashSet의 addAll과는 별개
	}
}
```

### 단점
* 콜백프레임워크에는 부적절

### 상속과 컴포지션
* 기존 클래스와 확장하고자 하는 클래스가 IS-A 관계일 때에만 상속을 사용하고 그 외의 모든 경우에는 컴포지션을 사용하는것이 안전하고 견고함