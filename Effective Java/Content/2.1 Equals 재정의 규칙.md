# Equals 재정의 규칙
* 반사성, 대칭성, 추이성, 일관성, null-check
### 1. 대칭성
* null이 아닌 모든 참조값 x,y에 대해 x.equals(y) 가 true면 y.equals(x)도 true 다.
* A=B 이면 B=A 이다.
```java
String str_1 = "A";
String str_2 = "A";
AssertEquals(str_1.equals(str_2), str_2.equals(str_1) );
```
**대칭성이 깨지는 케이스**
* CaseIgnoreString 클래스의 equals 메서드로 동일한 클래스 객체 뿐만 아니라 일반 String 과도 비교시도
* CaseIgnoreString 클래스의 equals 메서드에는 String 객체에 대한 처리 코드가 있으나 String의 equals 메서드에는 CaseIgnoreString 처리코드가 없어 대칭성이 깨짐 
```java
public class CaseIgnoreString {
	String str;

	public CaseIgnoreString(String str) { this.str = str; }

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof CaseIgnoreString) {
			return str.equalsIgnoreCase((CaseIgnoreString)obj.str);
		}
		if(obj instanceof String) {
			return str.equalsIgnoreCase((String)obj);
		}
		return false;
	}
}

public static void main(String[] args) {
	CaseIgnoreString caseIgnoreString = new CaseIgnoreString ("A");
	String normalStr = "A";

	AssertEquals(caseIgnoreString.equals(normalStr), normalStr.equals(caseIgnoreString )); //false
}
```
* List<CaseIgnoreString> 의 contains 메서드와 그 내부적으로 호출하는 equals 메서드가 jdk 버전마다 다르게 동작 할 수 있음
```java
public static void main(String[] args) {
	CaseIgnoreString caseIgnoreString = new CaseIgnoreString ("A");
	String normalStr = "A";
    
    List<CaseIgnoreString> list = new ArrayList<>();
    list.add(caseIgnoreString);
    
    System.out.println(list.contains(normalStr));   //jdk마다 출력되는 결과가 다름
}
```
* CaseIgnoreClass 의 equals 메서드가 대칭성 규약을 지키게 하기 위해선 일반 String 객체와의 비교를 포기해야함
```java
	@Override
	public boolean equals(Object obj) {
        return obj instanceOf CaseIgnoreString && (CaseIgnoreString)obj.str.equalsIgnoreCase(this.str);
	}
```

##### cf) Java 라이브러리 내의 대칭성 위반 케이스 예제
* TimeStamp 클래스는 Date 클래스를 상속받았으므로 Date.equals(TimeStamp) != TimeStamp.equals(Date) 일 수 있음
```java
//java.sql.TimeStamp
/**
     * Tests to see if this <code>Timestamp</code> object is
     * equal to the given object.
     *
     * This version of the method <code>equals</code> has been added
     * to fix the incorrect
     * signature of <code>Timestamp.equals(Timestamp)</code> and to preserve backward
     * compatibility with existing class files.
     *
     * Note: This method is not symmetric with respect to the
     * <code>equals(Object)</code> method in the base class.
     *
     * @param ts the <code>Object</code> value to compare with
     * @return <code>true</code> if the given <code>Object</code> is an instance
     *         of a <code>Timestamp</code> that
     *         is equal to this <code>Timestamp</code> object;
     *         <code>false</code> otherwise
     */
    public boolean equals(java.lang.Object ts) {
      if (ts instanceof Timestamp) {
        return this.equals((Timestamp)ts);
      } else {
        return false;
      }
    }
```


### 2. 추이성
* null 이 아닌 모든 참조값 x,y,z 에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
* A=B 이고 B=C 이면 A=C 이다.
* **추이성이 깨지는 케이스 : 상속 관계에서 발생 **
```java
public class Point {
	private int x;
	public Point(int x) { this.x = x; }

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof Point) {
			return (Point)obj.x == this.x;
		}
		return false;
	}
}

public class ColorPoint extends Point {
    private final Color color;
    
    public ColorPoint(int x, Color color) {
        super(x);
        this.color = color;
    }
    
    @Override
    public boolean equals(Object obj) { 
    	if(!(obj instanceof Point)) {
            return false;
        }
        if(!(obj instanceof  ColorPoint)) {
            return obj.equals(this);
        }
        return super.equals(obj) && ((ColorPoint)obj).color == color; 
    }
}

public static void main(String[] args) { 
    Point point = new Point(0);
    ColorPoint colorPoint_1 = new ColorPoint(0, Color.RED);
    ColorPoint colorPoint_2 = new ColorPoint(0, Color.BLACK);
    
    System.out.println(colorPoint_1.equals(point));
    System.out.println(point.equals(colorPoint_2));
    System.out.println(colorPoint_1.equals(colorPoint_2));
}
```
* Point 클래스를 확장한 ColorPoint는 Point 클래스 인스턴스와의 equals 시 x값만 비교 
* Point 클래스도 마찬가지로 ColorPoint 클래스 인스턴스와의 equals 시 x값만 비교
* 이러한 방식은 대칭성은 충족되나 추이성을 위반하고 무한루프에 빠질 위험 또한 존재
	* point.equals(colorPoint_1), colorPoint_1.equals(point) 모두 true
	* colorPoint_1.equals(point), point.equals(colorPoint_2) 모두 true, colorPoint_1.equals(colorPoint_2) > false
```java
public class TexturePoint extends Point {
    private final String texture;
    
    public TexturePoint(int x, String texture) {
        super(x);
        this.texture = texture;
    }
	
	@Override
	public boolean equals(Object obj) {
        if(!(obj instanceof Point)) {
            return false;
        }
        if(!(obj instanceof  TexturePoint)) {
            return obj.equals(this);
        }
        return super.equals(obj) && ((TexturePoint)obj).texture == texture;
	}
}

colorPoint.equals(texturePoint); // 무한루프에 빠짐
```
* 자식 클래스에서 부모 클래스 객체와의 equals도 지원하며 equals재정의 규칙을 준수하는것은 불가능하므로 애초에 자기자신과 같은 인스턴스와만 비교하도록 구현하는것이 바람직
```java
public class ColorPoint extends Point {
    private final Color color;
    
    public ColorPoint(int x, Color color) {
        super(x);
        this.color = color;
    }
    
    @Override
    public boolean equals(Object obj) { 
    	if(!(obj instanceof ColorPoint)) {
            return false;
        }
        return super.equals(obj) && ((ColorPoint)obj).color == color; 
    }
}
```
 
> cf) 리스코프 치환원칙 : 어떤 타입에 있어 중요한 원칙이라면 그 하위타입에서도 똑같이 중요하기때문에 부모클래스의 모든 메서드가 자식클래스에서도 똑같이 잘 작동해야한다. 
> Point 의 하위클래스는 정의상 여전히 Point이므로 어디서든 Point로 활용될 수 있어야한다.
### 3. null-check
* 일반적으로 equals 재정의시 null-check 방법 > 파라미터로 다른타입이 들어올시 CastException 발생 가능
```java
@Override  
public boolean equals(Object other) {  
   if (other == null) {  
      return false;  
   }  
   return DEAFAULT_INTEGER_VALUE == (int)other;  //파라미터로 Long 타입 데이터 들어올시 	CaseException 발생
}  
```
* 명시적 null-check 보다 instanceof 를 활용하여 null-check 뿐만아니라 CastException 도 방지
```java
@Override  
public boolean equals(Object other) {  
   if (!(other instanceof Integer)) {  
      return false;  
   }  
   return DEAFAULT_INTEGER_VALUE == (int)other;
}  
```
### equals 메서드를 직접 재정의 해주기 번거롭다면 @AutoValue 이용
* 클래스에 @AutoValue 어노테이션 추가시 equals(), hashCode(), toString()를 해당클래스에 맞게 자동 재정의(getter, setter 등등 많은 기능제공..)