# Equals 재정의 규칙
* 반사성, 대칭성, 추이성, 일관성, null-check
### 1. 대칭성
* null이 아닌 모든 참조값 x,y에 대해 x.equals(y) 가 true면 y.equals(x)도 true 다.
* A=B 이면 B=A 이다.
```java
String str_1 = "A";
String str_2 = "A";
AssertEquals(str_1.equals(str_2), str_2.equals(str_1) );
```
**대칭성이 깨지는 케이스**
```java
public class CaseIgnoreString {
	String str;

	public CaseIgnoreString(String str) { this.str = str; }

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof CaseIgnoreString) {
			return str.equalsIgnoreCase((CaseIgnoreString)obj.str);
		}
		if(obj instanceof String) {
			return str.equalsIgnoreCase((String)obj);
		}
		return false;
	}
}

public static void main(String[] args) {
	CaseIgnoreString caseIgnoreString = new CaseIgnoreString ("A");
	String normalStr = "A";

	AssertEquals(caseIgnoreString.equals(normalStr), normalStr.equals(caseIgnoreString )); //false
}
```
### 2. 추이성
* null 이 아닌 모든 참조값 x,y,z 에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
* A=B 이고 B=C 이면 A=C 이다.
* **추이성이 깨지는 케이스**
```java
public class Point {
	private int x;
	public Point(int x) { this.x = x; }

	@Override
	public boolean equals(Object Obj) {
		if(obj instanceof Point) {
			return (Point)Obj.x == this.x;
		}
		return false;
	}
}

public class IdPoint extends Point {
	private String Id;
	public IdPoint(int x, String Id) { suepr(x), this.Id = Id};
	
	@Override
	public boolean equals(Object obj) {
		if(obj instanceof IdPoint) {
			return (IdPoint)obj.x == this.x && (IdPoint)obj.Id == this.Id; 
		}
	    if(obj instanceof Point) {
			return (Point)obj.x == this.x;
		}
		return false;
	}
}

public static void main(String[] args) {
	Point p = new Point(0);
	IdPoint idP_1 = new IdPoint(0, "idP_1");
	IdPoint idP_2 = new IdPoint(0, "idP_2");
	
	AssertEquals(idP_1.equals(idP_2), AssertEquals(p.equals(idP_1), p.equals(idP_2));
}
```
* 부모클래스를 상속받은 자식클래스의 equals 메서드 재정의시,  추이성 위반 - 1. 비교 instance를 자식클래스 객체로 제한하거나, 2. 상속대신 컴포지션을 이용 하여 해결(?)
```java
//1. 비교 instance 를 자식클래스 객체로 제한 - 리스코프 치한 원칙 위배
public class IdPoint extends Point {
   private String Id;
   public IdPoint(int x, String Id) { suepr(x), this.Id = Id};
	
   @Override
   public boolean equals(Object obj) {
      if(obj instanceof IdPoint) {
         return (IdPoint)obj.x == this.x && (IdPoint)obj.Id == this.Id; 
      }
      return false;
   }
}

//2. 상속대신 컴포지션 이용
public class IdPoint {
   private String Id;
   private Point p;
   public IdPoint(int x, String Id) { p = new Point(x), this.Id = Id};

   @Override
   public boolean equals(Object obj) {
      if(obj instanceof IdPoint) {
         return (IdPoint)obj.p == this.p && (IdPoint)obj.Id == this.Id; 
      }
      return false;
   }
}
```
> cf) 리스코프 치환원칙 : 어떤 타입에 있어 중요한 원칙이라면 그 하위타입에서도 똑같이 중요하기때문에 부모클래스의 모든 메서드가 자식클래스에서도 똑같이 잘 작동해야한다. 
> Point 의 하위클래스는 정의상 여전히 Point이므로 어디서든 Point로 활용될 수 있어야한다.
### 3. null-check
* 일반적으로 equals 재정의시 null-check 방법 > 파라미터로 다른타입이 들어올시 CastException 발생 가능
```java
@Override  
public boolean equals(Object other) {  
   if (other == null) {  
      return false;  
   }  
   return DEAFAULT_INTEGER_VALUE == (int)other;  //파라미터로 Long 타입 데이터 들어올시 	CaseException 발생
}  
```
* 명시적 null-check 보다 instanceof 를 활용하여 null-check 뿐만아니라 CastException 도 방지
```java
@Override  
public boolean equals(Object other) {  
   if (!(other instanceof Integer)) {  
      return false;  
   }  
   return DEAFAULT_INTEGER_VALUE == (int)other;
}  
```
### equals 메서드를 직접 재정의 해주기 번거롭다면 @AutoValue 이용
* 클래스에 @AutoValue 어노테이션 추가시 equals(), hashCode(), toString()를 해당클래스에 맞게 자동 재정의(getter, setter 등등 많은 기능제공..)