# Equals 재정의 규칙
* 반사성, 대칭성, 추이성, 일관성, null-check
### 1. 대칭성
* null이 아닌 모든 참조값 x,y에 대해 x.equals(y) 가 true면 y.equals(x)도 true 다.
* A=B 이면 B=A 이다.
```java
String str_1 = "A";
String str_2 = "A";
AssertEquals(str_1.equals(str_2), str_2.equals(str_1) );
```
**대칭성이 깨지는 케이스**
* CaseIgnoreString 클래스의 equals 메서드로 동일한 클래스 객체 뿐만 아니라 일반 String 과도 비교시도
* CaseIgnoreString 클래스의 equals 메서드에는 String 객체에 대한 처리 코드가 있으나 String의 equals 메서드에는 CaseIgnoreString 처리코드가 없어 대칭성이 깨짐 
```java
public class CaseIgnoreString {
	String str;

	public CaseIgnoreString(String str) { this.str = str; }

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof CaseIgnoreString) {
			return str.equalsIgnoreCase((CaseIgnoreString)obj.str);
		}
		if(obj instanceof String) {
			return str.equalsIgnoreCase((String)obj);
		}
		return false;
	}
}

public static void main(String[] args) {
	CaseIgnoreString caseIgnoreString = new CaseIgnoreString ("A");
	String normalStr = "A";

	AssertEquals(caseIgnoreString.equals(normalStr), normalStr.equals(caseIgnoreString )); //false
}
```
* List<CaseIgnoreString> 의 contains 메서드와 그 내부적으로 호출하는 equals 메서드가 jdk 버전마다 다르게 동작 할 수 있음
```java
public static void main(String[] args) {
	CaseIgnoreString caseIgnoreString = new CaseIgnoreString ("A");
	String normalStr = "A";
    
    List<CaseIgnoreString> list = new ArrayList<>();
    list.add(caseIgnoreString);
    
    System.out.println(list.contains(normalStr));   //jdk마다 출력되는 결과가 다름
}
```
* CaseIgnoreClass 의 equals 메서드가 대칭성 규약을 지키게 하기 위해선 일반 String 객체와의 비교를 포기해야함
```java
	@Override
	public boolean equals(Object obj) {
        return obj instanceOf CaseIgnoreString && (CaseIgnoreString)obj.str.equalsIgnoreCase(this.str);
	}
```

##### cf) Java 라이브러리 내의 대칭성 위반 케이스 예제
* TimeStamp 클래스는 Date 클래스를 상속받았으므로 Date.equals(TimeStamp) != TimeStamp.equals(Date) 일 수 있음
```java
//java.sql.TimeStamp
/**
     * Tests to see if this <code>Timestamp</code> object is
     * equal to the given object.
     *
     * This version of the method <code>equals</code> has been added
     * to fix the incorrect
     * signature of <code>Timestamp.equals(Timestamp)</code> and to preserve backward
     * compatibility with existing class files.
     *
     * Note: This method is not symmetric with respect to the
     * <code>equals(Object)</code> method in the base class.
     *
     * @param ts the <code>Object</code> value to compare with
     * @return <code>true</code> if the given <code>Object</code> is an instance
     *         of a <code>Timestamp</code> that
     *         is equal to this <code>Timestamp</code> object;
     *         <code>false</code> otherwise
     */
    public boolean equals(java.lang.Object ts) {
      if (ts instanceof Timestamp) {
        return this.equals((Timestamp)ts);
      } else {
        return false;
      }
    }
```


### 2. 추이성
* null 이 아닌 모든 참조값 x,y,z 에 대해, x.equals(y)가 true이고 y.equals(z)도 true면 x.equals(z)도 true다.
* A=B 이고 B=C 이면 A=C 이다.
* **추이성이 깨지는 케이스 : 상속 관계에서 발생 **
```java
public class Point {
	private int x;
	public Point(int x) { this.x = x; }

	@Override
	public boolean equals(Object obj) {
		if(obj instanceof Point) {
			return (Point)obj.x == this.x;
		}
		return false;
	}
}

public class ColorPoint extends Point {
    private final Color color;
    
    public ColorPoint(int x, Color color) {
        super(x);
        this.color = color;
    }
    
    @Override
    public boolean equals(Object obj) { 
    	if(!(obj instanceof Point)) {
            return false;
        }
        if(!(obj instanceof  ColorPoint)) {
            return obj.equals(this);
        }
        return super.equals(obj) && ((ColorPoint)obj).color == color; 
    }
}

public static void main(String[] args) { 
    Point point = new Point(0);
    ColorPoint colorPoint_1 = new ColorPoint(0, Color.RED);
    ColorPoint colorPoint_2 = new ColorPoint(0, Color.BLACK);
    
    System.out.println(colorPoint_1.equals(point));
    System.out.println(point.equals(colorPoint_2));
    System.out.println(colorPoint_1.equals(colorPoint_2));
}
```
* Point 클래스를 확장한 ColorPoint는 Point 클래스 인스턴스와의 equals 시 x값만 비교 
* Point 클래스도 마찬가지로 ColorPoint 클래스 인스턴스와의 equals 시 x값만 비교
* 이러한 방식은 대칭성은 충족되나 추이성을 위반하고 무한루프에 빠질 위험 또한 존재
	* point.equals(colorPoint_1), colorPoint_1.equals(point) 모두 true
	* colorPoint_1.equals(point), point.equals(colorPoint_2) 모두 true, colorPoint_1.equals(colorPoint_2) > false
```java
public class TexturePoint extends Point {
    private final String texture;
    
    public TexturePoint(int x, String texture) {
        super(x);
        this.texture = texture;
    }
	
	@Override
	public boolean equals(Object obj) {
        if(!(obj instanceof Point)) {
            return false;
        }
        if(!(obj instanceof  TexturePoint)) {
            return obj.equals(this);
        }
        return super.equals(obj) && ((TexturePoint)obj).texture == texture;
	}
}

colorPoint.equals(texturePoint); // 무한루프에 빠짐
```
* 자식 클래스에서 부모 클래스 객체와의 equals도 지원하며 equals재정의 규칙을 준수하는것은 불가능하므로 애초에 자기자신과 같은 인스턴스와만 비교하도록 구현하는것이 바람직
```java
public class ColorPoint extends Point {
    private final Color color;
    
    public ColorPoint(int x, Color color) {
        super(x);
        this.color = color;
    }
    
    @Override
    public boolean equals(Object obj) { 
    	if(!(obj instanceof ColorPoint)) {
            return false;
        }
        return super.equals(obj) && ((ColorPoint)obj).color == color; 
    }
}
```
 
> cf) 리스코프 치환원칙 : 어떤 타입에 있어 중요한 원칙이라면 그 하위타입에서도 똑같이 중요하기때문에 부모클래스의 모든 메서드가 자식클래스에서도 똑같이 잘 작동해야한다. 
> Point 의 하위클래스는 정의상 여전히 Point이므로 어디서든 Point로 활용될 수 있어야한다.
### 3. 일관성
* 두 객체의 equals가 true 라면, 어느하나가 수정되기 전까진 계속 eqauls가 true 이어야 한다.
    * java.net.URL 클래스의 equals는 파라미터로 들어온 URL의 호스트 IP 주소를 가지고 비교 수행
    * URL의 호스트 주소는 코드가 수정되지 않아도 그 값이 바뀔 수 있기 때문에 일관성이 깨짐
```java
//java.net.URL
public boolean equals(Object obj) {
        if (!(obj instanceof URL)) {
            return false;
        } else {
            URL u2 = (URL)obj;
            return this.handler.equals(this, u2);
        }
}

protected boolean equals(URL u1, URL u2) {
        String ref1 = u1.getRef();
        String ref2 = u2.getRef();      //언제든지 바뀔 수 있음
        return (ref1 == ref2 || ref1 != null && ref1.equals(ref2)) && this.sameFile(u1, u2);
}
``` 

### 4. null-check
* Object.equals(null) 의 결과가 true가 나오거나 equals 수행중 NPE가 발생하면 안됨
* 일반적으로 NPE 를 피하고 위해 equals 메서드 재정의시 파라미터 오브젝트의 null-check 를 직접 구현
* 명시적 null-check 대신 instanceof 연산자로 null-check 가능
```java
@Override  
public boolean equals(Object other) {  
   if (other == null) {
      return false;
   }
   return DEAFAULT_INTEGER_VALUE == (int)other;  //파라미터로 Long 타입 데이터 들어올시 	CaseException 발생
}
```

### 양질의 equals 메서드 재정의
1. 가장 먼저 == 연산자를 통해 입력이 자기자신의 참조인지 확인
2. instanceof 연산자로 입력이 비교가능한 올바른 타입인지 확인
3. 멤버 필드 비교시, 값이 다를 확률이 높은 필드부터 비교
3. equals 재정의 후 대칭성, 추이성, 일관성을 만족하는지 확인
```java
//InterruptionInfo
public class InterruptionInfo {
	...
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof InterruptionInfo)) {
			return false;
		}
	
		InterruptionInfo info = (InterruptionInfo)obj;
		return this.index == info.index && StringUtils.equals(this.apply, info.apply) && StringUtils.equals(this.serviceType, info.serviceType) && StringUtils.equals(this.checkType, info.checkType) && equals(this.startDate, info.startDate) && equals(this.endDate, info.endDate);
	}
	
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		
		if (!(obj instanceof InterruptionInfo)) {
			return false;
		}
	
		InterruptionInfo info = (InterruptionInfo)obj;
		return this.index == info.index && StringUtils.equals(this.apply, info.apply) && StringUtils.equals(this.serviceType, info.serviceType) && StringUtils.equals(this.checkType, info.checkType) && equals(this.startDate, info.startDate) && equals(this.endDate, info.endDate);
	}
}
```

### equals 메서드를 직접 재정의 해주기 번거롭다면 @AutoValue 이용
* 클래스에 @AutoValue 어노테이션 추가시 equals(), hashCode(), toString()를 해당클래스에 맞게 자동 재정의(getter, setter 등등 많은 기능제공..)