# hashCode 재정의 규칙
### hashCode 명세
1. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
2. ***equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.***
```java
public class Point {
   private int xPos;
   public Point(int xPos) { this.xPos = xPos; }

   @Override
   public boolean equals(Object Obj) {
      if(obj instanceof Point) {
         return (Point)Obj.xPos == this.xPos;
      }
      return false;
   }
}

@Test
public void test() {
   Point p1 = new Point(10);
   Point p2 = new Point(10);

   Assert.assertTrue(p1.equals(p2));		//true

   Map<Point, String> map = new HashMap<>();
   map.put(p1, "Point 1");

   Assert.assertTrue(map.containsKey(p2));		//false
}
```
> equals 재정의시, 2번 명세에 의거 hashCode 또한 equals에 맞춰 재정의 해주어야함.
3. equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.



### hashCode 재정의
* java 기본 hashCode메서드는 객체의 메모리 주소값을 파라미터로 하여 생성됨
* eqauls 가 데이터를 비교하도록 재정의 하였으면, hashCode 또한 데이터를 파라미터로 하여 생성하도록 재정의
* 재정의한 equals 비교에 사용된 멤버변수값을 파라미터로 hashCode 생성
```java
public class Point {
   private int xPos;
   public Point(int xPos) { this.xPos = xPos; }

   @Override
   public boolean equals(Object Obj) {
      if(obj instanceof Point) {
         return (Point)Obj.xPos == this.xPos;
      }
      return false;
   }

   @Override
   public int hashCode() {
	  return 31 * 17 + xPos;
   }
}

@Test
public void test() {
   Point p1 = new Point(10);
   Point p2 = new Point(10);

   Assert.assertTrue(p1.equals(p2));		//true

   Map<Point, String> map = new HashMap<>();
   map.put(p1, "Point 1");

   Assert.assertTrue(map.containsKey(p2));		//true
}
```

### hashCode를 재정의 하는 다른 방식
1. **Objects.hash(T.. paramList)**
* 입력받은 인수들을 파라미터로 hashCode를 생성해주는 유틸리티 메서드
* 코드 가독성이 높아지나 속도가 좀 더 느리다는 단점 존재
```java
public class Point {
   private int xPos;
   private int yPos;
   private int zPos;

   @Override
   public int hashCode() {
     int result = 17;
     result = 31 * result + xPos;
     result = 31 * result + yPos;
     result = 31 * result + zPos;
     return result;
   }

   @Override
   public int hashCode() {
      return Objects.hash(xPos, yPos, zPos);		//가독성이 좋아짐
   }
}
```

2. **해시코드 캐싱**
* 클래스 객체가 불변이고 해시코드 계산 비용이 클시, 최초 1회만 해시코드를 계산하고 이후 캐싱하여 재활용함으로서 효율성 증가
```java
public class Point {
   private int xPos;
   private int hashCode;
   public Point(int xPos) { this.xPos = xPos; hashCode = 0;}

   @Override
   public int hashCode() {
      if(hashCode == 0) {
         hashCode = 31 * 17 + xPos;
	  }
	  return hashCode;
   }
}
```