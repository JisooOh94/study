# hashCode 재정의 규칙
### object 명세
1. equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
2. ***equals(Object)가 두 객체를 같다고 판단했다면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.***
3. equals(Object)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.

### hashCode 재정의
* java 기본 hashCode메서드 : 객체의 메모리 주소값을 해싱하여 해시코드 생성 > 두 객체가 논리적 동치여도 서로 다른 hashCode 가짐
```java
public class Point {
   private int xPos;
   public Point(int xPos) { this.xPos = xPos; }

   @Override
   public boolean equals(Object obj) {
      if(obj instanceof Point) {
         return ((Point)obj).xPos == this.xPos;
      }
      return false;
   }
}

@Test
public void test() {
   Point p1 = new Point(10);
   Point p2 = new Point(10);

   Assert.assertTrue(p1.equals(p2));		//true

   Map<Point, String> map = new HashMap<>();
   map.put(p1, "Point 1");

   Assert.assertTrue(map.containsKey(p2));		//false
}
```
* eqauls가 논리적 동치를 따지도록 재정의시, hashCode 또한 멤버변수를 파라미터로 하여 생성하도록 재정의
* 재정의한 equals 에서 ***논리적 동치 판단에 사용된 멤버변수값만*** 을 파라미터로 hashCode 생성
```java
public class Point {
   private int xPos;
   public Point(int xPos) { this.xPos = xPos; }

   @Override
   public boolean equals(Object obj) {
      if(obj instanceof Point) {
         return ((Point)obj).xPos == this.xPos;
      }
      return false;
   }

   @Override
   public int hashCode() {
	  return 31 * 17 + xPos;
   }
}

@Test
public void test() {
   Point p1 = new Point(10);
   Point p2 = new Point(10);

   Assert.assertTrue(p1.equals(p2));		//true

   Map<Point, String> map = new HashMap<>();
   map.put(p1, "Point 1");

   Assert.assertTrue(map.containsKey(p2));		//true
}
```

### hashCode를 재정의 하는 다른 방식
1. **Objects.hash(T... paramters)**
* 입력받은 인수들을 파라미터로 hashCode를 생성해주는 유틸리티 메서드
* 코드 가독성이 높아지나 속도가 좀 더 느리므로 성능에 민감하지 않은 기능에서만 사용
```java
public class Point {
   private int xPos;
   private int yPos;
   private int zPos;

   @Override
   public int hashCode() {
     int result = 17;
     result = 31 * result + xPos;
     result = 31 * result + yPos;
     result = 31 * result + zPos;
     return result;
   }

   @Override
   public int hashCode() {
      return Objects.hash(xPos, yPos, zPos);		//가독성이 좋아짐
   }
}
```

### 해시코드 캐싱
* 해시코드 캐싱 조건 
	1. 클래스 객체가 불변이고, 
	2. equals 메서드를 논리적 동치성을 판단하도록 재정의 하였으며
	3. 객체의 hashCode 가 사용될 일이 있다면
* 해시코드 캐싱 방식
	1. 해시코드를 클래스의 static final 멤버 변수로 선언하여 프로그램 실행시 생성하여 재사용
	2. 클래스의 hashCode 가 최초 호출될때 생성 후 재사용(lazy-loading 방식)
```java
public class Point {
   private int xPos;
   private int hashCode;
   public Point(int xPos) { this.xPos = xPos; }

   @Override
   public int hashCode() {
      if(hashCode == 0) {
         hashCode = 31 * 17 + xPos;
	  }
	  return hashCode;
   }
}
```


### 해시코드 재정의 사례
```java
//InterruptionInfo
public class InterruptionInfo {
	...
	@Override
	public boolean equals(Object obj) {
		if (!(obj instanceof InterruptionInfo)) {
			return false;
		}
	
		InterruptionInfo info = (InterruptionInfo)obj;
		return this.index == info.index && StringUtils.equals(this.apply, info.apply) && StringUtils.equals(this.serviceType, info.serviceType) && StringUtils.equals(this.checkType, info.checkType) && equals(this.startDate, info.startDate) && equals(this.endDate, info.endDate);
	}
	
	//Object 명세의 두번째 규약 위반!!
	@Override
	public int hashCode() {
		return index + createDate.hashCode();
	}
	
	@Override
	public int hashCode() {
		result = Integer.hashCode(index);
		result = 31 * result + String.hashCode(apply);
		result = 31 * result + String.hashCode(serviceType);
		result = 31 * result + String.hashCode(checkType);
		result = 31 * result + startDate.hashCode();
		result = 31 * result + endDate.hashCode();
		return result;
	}
}
```