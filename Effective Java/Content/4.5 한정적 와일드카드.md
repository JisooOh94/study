# 제네릭의 단점
* 제네릭은 불공변 방식이기 때문에 객체지향의 속성중 하나인 다형성의 이점을 누릴 수 없다.
```java
public class Parent {}

public class Child extends Parent {}

public void doSomething(Parent obj) {}

public void doSomething_Generic(List<Parent> list) {}

@Test
public void test() {
	Child child = new Child();
	List<Child> childList= new ArrayList<>();
	
	Parent parent = child;		//가능
	List<Parent> parentList = childList;	//불가능
	
	doSomething(child);		//가능
	doSomething_Generic(childList);		//불가능
}
```
> * Child는 Parent의 자식클래스이기 때문에 Parent로서 동작할 수 있음
> * List<Child>는 제네릭의 불공변 속성에 따라 List<Parent> 와 아무런 부자관계가 성립하지 않아 List<Parent> 로서 동작할 수 없음

# 한정적 와일드카드
* 제네릭이 다형성의 이점을 누릴수 있도록 해주는 기능
* 제네릭 타입 객체의 실체화 타입이 타입 매개변수로 설정한 타입 뿐만 아니라 그의 자식클래스, 또는 부모클래스 타입이 될 수 있도록 해줌
* 형식 : <? extends Class>, <? super Class>
```java
public class GrandParent {}

public class Parent extends GrandParent{}

public class Child extends Parent {}

public class Stack<E> {
	private E[] elements;
		
	public void push(E elem) {}

	public E pop() {}

	public void pushAll(List<? extends E> list) {       //E의 모든 자식클래스 객체들의 list 가 올 수 있음
		for(E elem : list) {
			push(elem);
		}
	}
        	
	public void popAndPut(Collection<? super E> collection) {       //E의 모든 부모클래스 객체들의 Collection이 올 수 있음
		collection.add(pop());
	}
}

@Test
public void test() {
	List<Child> childList = new ArrayList<>();
	Collection<GrandParent> grandParentCollection = new Collection<>();
	
	Stack<Parent> stack = new Stack<>();
	
	stack.pushAll(childList);
	stack.popAndPut(grandParentCollection);
}
```

### PECS 공식
* Producer-extends, Consumer-super
* 다형성 원칙인, 자식클래스 객체는 부모클래스 타입 객체로서 사용될 수 있음을 활용
* 한정적 와일드카드 타입 객체가
    1. 생성자라면, 즉 객체 인스턴스 그 자체라면 extends 한정 조건 사용
    2. 소비자, 즉 객체 인스턴스를 제공받아 사용하는 주체라면 super 한정 조건 사용