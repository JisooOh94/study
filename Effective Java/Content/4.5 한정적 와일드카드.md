# 제네릭의 단점
* 제네릭은 불공변 방식이기 때문에 객체지향의 속성중 하나인 다형성의 이점을 누릴 수 없다.
```java
public class Parent {}

public class Child extends Parent {}

public void doSomething(Parent obj) {}

public void doSomething_Generic(List<Parent> list) {}

@Test
public void test() {
	Child child = new Child();
	List<Child> childList= new ArrayList<>();
	
	Parent parent = child;		//가능
	List<Parent> parentList = childList;	//불가능
	
	doSomething(child);		//가능
	doSomething_Generic(childList);		//불가능
}
```
> * Child는 Parent의 자식클래스이기 때문에 Parent로서 동작할 수 있음
> * List<Child>는 제네릭의 불공변 속성에 따라 List<Parent> 와 아무런 부자관계가 성립하지 않아 List<Parent> 로서 동작할 수 없음

# 한정적 와일드카드
* 제네릭이 다형성의 이점을 누릴수 있도록 해주는 기능
* 제네릭 타입 객체의 실체화 타입이 타입 매개변수로 설정한 타입 뿐만 아니라 그의 자식클래스, 또는 부모클래스 타입이 될 수 있도록 해줌
* 형식 : <? extends Class>, <? super Class>
```java
public class GrandParent {}

public class Parent extends GrandParent{}

public class Child extends Parent {}

public class Stack<E> {
	private E[] elements;
		
	public void push(E elem) {}

	public E pop() {}

	public void pushAll(List<? extends E> list) {
		for(E elem : list) {
			push(elem);
		}
	}
        	
	public void popAndPut(Collection<? super E> collection) {
		collection.add(pop());
	}
}

@Test
public void test() {
	List<Child> childList = new ArrayList<>();
	Collection<GrandParent> grandParentCollection = new Collection<>();
	
	Stack<Parent> stack = new Stack<>();
	
	stack.pushAll(childList);
	stack.popAndPut(grandParentCollection);
}
```

### PECS 공식
* producer-extends, consumer-super
* 매개변수화 타입 T가 생산자라면 extends, 소비자라면 super 를 사용
* 생산자 : 메서드에 데이터를 제공하는 자, 소비자 : 메서드의 데이터를 사용하는자

```java
//생산자
public <T> void generate(List<? extends T> params) {
	for(T param : params) {		//T 를 상속받은 모든 자식 클래스는 부모클래스 참조변수인 T에 참조될 수 있음
		//do something with param
	}
}

//소비자
List<T> vars = new LinkedList<>();
public <T> void consume(List<? super T> params) {
	params.addAll(vars);	//T 타입 인스턴스들은 T의 모든 부모클래스 참조변수에 담길 수 있음
}
```

### 한정적 와일드 카드 사용 예시
* raw 타입을 사용하여 범용성을 높였으나 타입 안정성을 보장할 수 없음
```java
//org.apache.commons.collections
public static List union(List list1, List list2) {
	ArrayList result = new ArrayList(list1);
	result.addAll(list2);
	return result;
}
```

* Raw 타입의 범용성과 Generic의 타입 안정성을 모두 만족하는 와일드카드를 활용하여 문제 해결
```java
public static <T> List<T> union(List<? extends T> list1, List<? extends T> list2) {
	ArrayList<T> result = new ArrayList<>(list1);
	result.addAll(list2);
	return result;
}
```

* 반환타입에도 와일드카드를 사용할 수 있고, 그를 통해 범용성을 더 높힐 수 있으나 이를 사용하는 클라이언트코드에서도 와일드카드타입을 쓰도록 강제하게 되므로 지양해야함
```java
public static <T> List<? super T> union(List<? extends T> list1, List<? extends T> list2) {
	...
}

@Test
public void test() {
	List<Integer> list_1 = Arrays.asList(1,2,3);
	List<Double> list_2 = Arrays.asList(1.1, 1.2, 1.3);
	List<? super Number> resultList = union(list_1, list_2);
}
```