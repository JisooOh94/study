# 동기화의 기능
### 1. 배타적 실행
* 한 스레드가 공유 데이터를 사용하는중엔 다른 스레드가 그 데이터를 사용할 수 없도록 lock 을 거는것

### 2. 스레드간 통신
* lock 에 걸려있는동안 공유데이터에 행해진 변경을 대기하던 다른 스레드가 사용하는 시점에도 공유데이터에 적용되어있을 수 있도록 하는것
* 동기화를 하지 않을경우, 한 스레드가 수행한 변경이 다른 스레드가 사용시에도 즉시 적용되지 않음 

### 스레드간 통신이 필요한 이유
* primitive type 변수들은 값 수정에 대해 별도의 동기화 없이도 atomic 하게 동작함
* 하지만 스레드간 통신은 적용되지 않아, 스레드에서 primitive type 변수 사용시, 다른 스레드가 바꾼 값이 아닌, 이전 값으로 동작할 수 있음

# 동기화 방법
1. volatile
* volatile 시그니처가 붙은 변수는 스레드에서 사용시, 항상 최신의 값으로 사용되도록 보장
* 배타적 실행은 보장하지 않으므로 primitive type 변수에만 사용하는것이 좋음

2. synchronized
* synchronized 시그니처가 붙은 메서드, 블록내에서 사용되는 변수는 항상 최신의 값으로 사용되고, 배타적 실행또한 보장됨
* 변수에는 적용할 수 없고 메서드나 코드블럭에만 적용할 수 있음

3. Atomic package(AtomicLong, AtomicInteger...)
* volatile 과 synchronized 의 장점만을 결합한 기능으로, 변수에 사용 가능하면서 최신의 값 사용 및 배타적 실행 보장
* 성능또한 volatile 이나 synchronized 보다 우수

# 멀티스레딩 환경 개발 원칙
* 멀티스레딩 환경에서 가변데이터 사용시, 싱글톤으로만 사용
* 공유데이터가 필요할시, 불변객체를 활용
* 가급적 동기화 지양(성능 저하 유발, 동기화 누수 발생 가능)

# 열린 호출
* 동기화 블록 내에서 파라미터로 전달된 객체의 메서드나, 재정의 가능한 메서드 사용되면 안됨
	* 어떤 로직이 수행될지 알 수 없고, 그 로직으로 인해 동기화가 깨지거나 데드락이 발생하거나 데이터를 훼손할 수 있음
* 열린 호출 : 이러한 가변로직들을 모두 동기화 블록 바깥에서 호출하는것 