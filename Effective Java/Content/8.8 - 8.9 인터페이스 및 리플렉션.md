# 객체 참조 변수는 클래스타입보단 인터페이스 타입으로
* 객체 참조변수는 구체적인 클래스 타입보단 인터페이스 타입으로 선언하는것이 더 범용적이고 유연함
* 단순 객체 변수 뿐만 아니라, 파라미터, 반환타입, 클래스 멤버필드 등에도 해당됨
* 클래스 객체를 담을 수 있는 적절한 인터페이스가 없을경우, 해당 클래스의 부모 클래스중 가능한한 가장 상위의 부모클래스 타입으로 선언

### 직접적인 클래스 타입 참조변수가 필요한 경우
1. 클래스 객체가 인터페이스엔 선언되어있지 않은 고유한 메서드나 규약 등의 특별한 기능을 가지고 있는 경우
2. String, BigInteger 과 같은 값 클래스(값 클래스를 여러가지로 구현하겠다고 인터페이스로 선언하는경우는 없으므로)

# 리플렉션 사용 지양
* 리플렉션은 다양한 강력한 기능을 제공하지만 다음의 명백한 단점들로 인해 사용하지 않는것이 좋음
    1. 컴파일러가 수행해주는 여러 타입 체크나 컴파일 에러 체크등이 수행되지 않음
    2. 코드가 장황해지고 가독성이 떨어짐
    3. 속도가 느리고 성능이 떨어짐

### 리플렉션 사용이 필요한 경우
#### 1. 컴파일 타임엔 존재하지 않는, 혹은 알 수 없는 클래스 인스턴스를 사용해야 하는 경우
* 컴파일 타임엔 알 수 없으나 런타임시에는 명확해지는 클래스 인스턴스를 사용해야 하는경우, 리플렉션을 통해 인스턴스 생성하여 사용(컴파일러가 체크하지 않으므로 컴파일에러 발생하지 않고 정상적으로 빌드됨)
* 리플렉션을 통해 생성한 알 수 없는 클래스 인스턴스는 해당 클래스 인스턴스의 부모 클래스타입이나 인터페이스 타입 참조변수에 저장하여 사용하는것이 안전
```java
public static void main(String[] args) {		//args 에는 HashSet<String>, TreeSet<String> 등의 Set 클래스 자식 클래스 인스턴스들이 올 수 있다.
	Class<? extends Set<String>> class = (Class<? extends Set<String>>)Class.forName(args[0]);		//명령줄 인수로 전달될 Set 인스턴스의 타입을 알아 낸다.
	Constructor<? extends Set<String>>) constructor = class.getDeclaredConstructor();		//알아낸 타입의 클래스의 생성자를 얻는다.

	Set<String> strSet = constructor.newInstance();		//얻어낸 생성자를 통해 Set 인스턴스를 생성한다.
	strSet.addAll(args);		//명령줄 인수로 전달된 Set 인스턴스 를 담는다.
}
```

#### 2. 버전이 여러개 존재하는 외부 써드 파티 라이브러리의 클래스 인스턴스를 사용해야 하는 경우
* 제공되는 버전들 중, 가장 기능이 적은 오래된 버전의 클래스 api만 대응하는 인터페이스 참조변수에 담아 사용
* 높은 버전의 라이브러리가 제공되는 경우, 추가된 api 및 기능들은 리플렉션을 통해 호출하여 사용