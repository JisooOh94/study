# 불필요한 객체 생성 지양
* 불변객체 또는 가변객체이나 사용중에 변경될 일이 없는 가변 객체는 매 요청마다 새로운 객체를 생성하기보다 미리 만들어져있는 객체를 재사용하는것이 효율적
* 정적 팩터리 메서드를 통해 객체 재사용 
```java
//java.lang.Boolean.class
public final class Boolean implements Serializable, Comparable<Boolean> {
    public static final Boolean TRUE = new Boolean(true);
    public static final Boolean FALSE = new Boolean(false);

    /** @deprecated */
    @Deprecated(
        since = "9"
    )
    public Boolean(String s) {
        return parseBoolean(s) ? new Boolean(true) : new Boolean(false);
    }

    public static Boolean valueOf(String s) {
        return parseBoolean(s) ? TRUE : FALSE;
    }
    ...
}
``` 

### 불필요한 객체 생성 - 1. 생성 비용이 비싼 객체
1. String.matches
* String.matches() 는 내부적으로 파라미터로 전달된 패턴스트링을 Pattern 객체로 생성하는 로직이 있음
   * public static Pattern compile(String regex) {  return new Pattern(regex, 0);  }
   * pattern 객체는 생성비용이 비싸므로 미리 static 객체로 선언하여 재사용
```java
	public boolean isValidString(String str) {
	   return str.matches("/\\.share/([^/]+)/([0-9]+)/([0-9]+)/([0-9a-z]+)/(.*)");  //생성비용이 비싸다.ㅏ
	}

    private static final Pattern validStringPattern = Pattern.compile("/\\.share/([^/]+)/([0-	9]+)/([0-9]+)/([0-9a-z]+)/(.*)");

    public boolean isValidString(String str) {
	   return validStringPattern.matcher(str).matches();
	}
```

### 불필요한 객체 생성 - 2. 오토박싱
```java
	Long sum = 0L;
	for(long i = 0; i < 100; i++) {
	   sum += i;		//primitive 타입인 i를 Long 타입 변수에 더하기 위한 오토박싱 발생(Long 타입 객체 생성)
	}
```
* primitive 타입과 boxing 타입을 섞어서 쓸경우, 오토박싱이 일어나면서 불필요한 객체 생성 비용 지불됨
* 가급적 primitive 타입 사용, 어쩔수없이 섞어 쓸경우 오토박싱이 일어나지 않도록 주의

### 객체 재사용시 주의사항
1. 객체 풀 사용시, 객체 생성 비용이 비싼 경우에만 사용
2. 객체 생성 비용이 비싸지 않고 불변객체라 할지라도 코드 명확성, 가독성등을 따져 융통성있게 활용