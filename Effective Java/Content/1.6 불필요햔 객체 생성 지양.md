# 불필요한 객체 생성 지양
* 불변객체는 물론이고 사용중에 변경될 일이 없는 가변 객체 또한 재사용하는것이 더 효율적
* 객체 재사용 방법
   * 정적 유틸리티 클래스
      * 유틸성 정적 함수들만 가지고, 상태(멤버변수)를 가지지 않는 클래스
      * e.g) StringUtils, CollectionUtils
   * 정적 팩터리 메서드
      * 미리 생성되어있는 정적 객체를 반환하는 메서드를 제공하는 동반 클래스
   * Spring 의존성 주입
   * 객체 풀

### 불필요한 객체 생성 예시
1. String.matches
```java
	public boolean isValidString(String str) {
	   return str.matches("/\\.share/([^/]+)/([0-9]+)/([0-9]+)/([0-9a-z]+)/(.*)");
	   //String.matches() 는 내부적으로 파라미터로 전달된 패턴스트링을 Pattern 객체로 생성하는 로직이 있음
	   //public static Pattern compile(String regex) {  return new Pattern(regex, 0);  }
	}

	private static final Pattern validStringPattern = Pattern.compile("/\\.share/([^/]+)/([0-	9]+)/([0-9]+)/([0-9a-z]+)/(.*)");	
	public boolean isValidString(String str) {
	   return validStringPattern.matcher(str).matches(); //미리 생성된 정적 Pattern 객체를 재활용하여 객체 생성 비용 절약
	}
```
2. 오토박싱
```java
	Long sum = 0L;
	for(long i = 0; i < 100; i++) {
	   sum += i;		//primitive 타입인 i를 Long 타입 변수에 더하기 위한 오토박싱 발생(Long 타입 객체 생성)
	}
```
* primitive 타입과 boxing 타입을 섞어서 쓸경우, 오토박싱이 일어나면서 불필요한 객체 생성 비용 지불됨
* 가급적 primitive 타입 사용, 어쩔수없이 섞어 쓸경우 오토박싱이 일어나지 않도록 주의

### 객체 재사용시 주의사항
1. 객체 풀 사용시, 객체 생성 비용이 비싼 경우에만 사용
2. 객체 생성 비용이 비싸지 않고 불변객체라 할지라도 코드 명확성, 가독성등을 따져 융통성있게 활용
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTU0OTg3MzY2XX0=
-->