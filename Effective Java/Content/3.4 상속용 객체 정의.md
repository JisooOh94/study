# 상속용 객체 정의 조건
1. 상속용 객체를 정의하여 상속받는것보다 인터페이스를 이용하는것이 더 좋다
2. 상속용 객체를 정의하여 상속받는것보다 래퍼 클래스 패턴이 더 좋다
3. 그럼에도 꼭 상속용 객체를 통해 상속받아야겠다면.
   1. 재정의 가능 메서드의 자기사용을 모두 제거 / 디테일한 설명 문서화
   2. 생성자의 재정의 가능 메서드 사용을 모두 제거

cf) 부모클래스 메서드를 하위클래스에서 재정의하고, 부모클래스 내부에서 그 메서드 호출시 하위클래스 메서드 호출됨
```java
public class Parent {
   public void parentMethod() {
      commmonMethod();
   }

   private void commonMethod() {
      System.out.println("Parent");
   }
}

public class Child extends Parent {
   public void childMethod() {
      commmonMethod();
   }
   @Override
   private void commonMethod() {
      System.out.println("Child");
   }
}

public void main(String[] args) {
   Parent parent = new Child();
   parent.childMethod();	//Child
   parent.parentMethod();	//Child
}
```
# 재정의 가능메서드의 자기사용 모두 제거 / 디테일한 설명 문서화
* 부모클래스가 재정의 가능 메서드를 자기 사용시, 자식클래스의 메서드 재정의로 인해 의도치 않게 부모클래스 동작이 변경됨
* 재정의 가능메서드를 자기사용하고 있던 부모클래스 메서드에서 의도치 않게 재정의된 자식클래스 메서드 호출
```java
public class ScoreCalculator {
   List<Integer> scoreList;

   public ScoreCalculator(List scoreList) {
	   this.scoreList= scoreList;
   }

   public String getFloorAverage() {
      int average = calcAverage();
      return "Average Score is " + average;
   }

   private int calcAverage() {
      int sum = scoreList.collect(Collectors.summingInt(Integer::intValue));
      double aver = (double)sum / (double)scoreList.size();
      return Math.floor(aver)
   }
}

public class ScoreCalculatorChild extends ScoreCalculator {
   public String getRoundAverage() {
      int average = calcAverage();
      return "Average Score is " + average;
   }
   
   @Override
   private int calcAverage() {
      int sum = scoreList.collect(Collectors.summingInt(Integer::intValue));
      double aver = (double)sum / (double)scoreList.size();
      return Math.round(aver)
   }
}

public static void main(String[] args) {
   ScoreCalculator scoreCalculator = new ScoreCalculator(Arrays.asList(90,91));
   ScoreCalculator scoreCalculatorExtended = new ScoreCalculatorChild(Arrays.asList(90,91));

   System.out.println(scoreCalculator.getFloorAverage());	//90
   System.out.println(scoreCalculatorExtended.getFloorAverage());	//91 > 재정의된 ScoreCalculatorChild 의 calcAverage 호출
}
```
### 해결방법
1. 재정의 가능 메서드의 자기사용 모두 제거
* 자기사용되는 메서드를 final로 선언하여 재정의 불가능하게 함
```java
public class ScoreCalculator {
   ...
   private final int calcAverage() {
      int sum = scoreList.collect(Collectors.summingInt(Integer::intValue));
      double aver = (double)sum / (double)scoreList.size();
      return Math.floor(aver)
   }
}

public class ScoreCalculatorChild extends ScoreCalculator {
   ...
   private int calcAverageRound() {
      int sum = scoreList.collect(Collectors.summingInt(Integer::intValue));
      double aver = (double)sum / (double)scoreList.size();
      return Math.round(aver)
   }
}
```
2. 재정의 가능 메서드에 대한 상세한 설명 문서화
* 자기사용 패턴을 문서화하여 다른 개발자가 그 메서드를 올바르게 재정의 하는 방법 제공
   * 재정의 가능 메서드가 내부적으로 호출될 수 있는 모든 상황
   * 재정의 가능 메서드가 내부적으로 어떻게 이용되는지, 어떤 순서로 호출되는지
   * 재정의 가능 메서드가 호출되었을 때, 이어지는 처리에 어떤 영향을 주는지
* @implSpec 어노테이션 이용
   * API 인터페이스 문서 생성시, javaDoc이 자동으로 Implementation Requirements 절 생성
   * 명령줄 매개변수로 ```-tag "implSpec:a:Implementation Requirement"``` 추가
   * 메서드와 하위 클래스 사이의 관계를 설명
   * 하위 클래스들이 그 메서드를 상속받아 재정의 할때, 그 메서드가 부모클래스 내부의 어디서 어떻게 동작하는지 설명

```java
/**java.util.Iterator
 * Performs the given action for each remaining element until all elements 
 * have been processed or the action throws an exception.  Actions are 
 * performed in the order of iteration, if that order is specified. 
 * Exceptions thrown by the action are relayed to the caller. 
 * @implSpec  
 * <p>The default implementation behaves as if:  
 * <pre>{@code  
 *     while (hasNext())  
 *         action.accept(next()); * }</pre>  
 *  
 * @param action The action to be performed for each element  
 * @throws NullPointerException if the specified action is null  
 * @since 1.8  
 */default void forEachRemaining(Consumer<? super E> action) {  
    Objects.requireNonNull(action);  
 while (hasNext())  
        action.accept(next());  
}
```
# 생성자의 재정의 가능 메서드 사용을 모두 제거
* 부모클래스 생성자에서 재정의 가능 메서드 자기사용시, 아직 생성되지 않은 자식객체 메서드를 호출하게됨
* 자식클래스 객체 생성 순서 : 부모클래스 객체 > 자식클래스 객체
```java
public class Super {
   public Super() {
      overrideMe();
   }
   public void overrideMe() {
   }
}

public class Sub extends Super {
   private final Instant instant;
   Sub() {
      instant = Instant.generate();
   }
   @Override
   public void overrideMe() {
      System.out.println(instant.value());
   }
}

public static void main(String[] args) {
   Sub sub = new Sub();		//NPE 발생
}
```