# 랜카드
* 네트워크를 통해 전송되는 데이터를 CPU 로 전달해주고, CPU 가 네트워크를 통해 보내고자 하는 데이터를 전송해주는 역할
   * 네트워크를 통한 데이터 수신시, 목적지 주소와 자신의 맥주소를 비교하여, 일치할경우 CPU에 인터럽트 걸고 데이터 전송
   * CPU로부터 데이터 전달시, 데이터를 케이블에 실어 네트워크(허브, 스위치, 라우터등)로 전송
* 네트워킹 방법에 따라 이더넷용/토큰링용, 데이터 송/수신 속도에 따라 10Mbps, 100Mbps 등으로 구분

### 랜카드의 CPU 인터럽트 원리
* CPU 는 자신에게 인터럽트를 걸 수 있는 여러 라인 중 하나를 랜카드에 할당 --> IRQ
* CPU 는 네트워크로 수신한 데이터를 저장할 메모리 공간을 랜카드에 할당 --> Base Memory
* 네트워크를 통해 데이터 수신시 랜카드는 해당 데이터를 Base Memory에 저장후 IRQ 라인을 통해 CPU 에 인터럽트 요청
* CPU 는 인터럽트 요청이 들어온 IRQ 라인의 번호를 확인하여 랜카드 요청 확인 후 Base Memory 영역을 가서 데이터 처리

<br>

# 허브
* Local Area Network 를 구축해주는 네트워크 장비
* 허브의 포트에 연결되어있는 장비들간에는 네트워크 통신 가능
* 멀티포트 리피터 방식의 데이터 통신

### 멀티포트 리피터 
* 한 장비가 허브로 데이터 전송시, 허브는 자신에게 연결되어있는 다른 모든 장비로 데이터 전송(일종의 브로드캐스팅)

### 콜리젼 도메인
* 이더넷 네트워크로 사용되는 허브는 CSMA/CD 통신방식을 이용하여 데이터를 전달하기 때문에 한번에 하나의 데이터 전달 요청밖에 처리하지 못함
* CSMA/CD 통신방식이기 때문에 동시에 2개 이상의 데이터 전달 요청이 들어올경우 콜리젼을 일으켜 연결되어있는 모든 PC에 영향을 주고 네트워크 속도가 저하됨
* 이렇게 하나의 허브 네트워크에 연결되어있는 PC들은 '하나의 콜리젼 도메인에 속해 있다' 라고 함

### 콜리젼에 따른 허브의 한계
* 100Mbps 속도로 데이터를 전송하는 허브라 해도, 한번에 하나의 데이터 전송요청밖에 처리하지 못함
* 따라서 실질적인 속도는 100Mbps 를 허브에 연결되어있는 네트워크 장비 수로 나눈 값임 (e.g 20대가 연결되어있다면 100Mbps / 20 = 5Mbps)
* 게다가 콜리전 발생시 연결되어있는 다른 모든 장비에 영향을 주고 네트워크 속도를 더 저하시킴
* 이러한 속도저하는 허브에 연결되어있는 네트워크 장비수가 많아질수록 더욱 심해짐

<br>

# 브리지
* 콜리전 도메인이 커질수록 네트워크 속도 저하가 심해지는 허브의 한계를 극복한 네트워크 장비
* 허브의 콜리젼 도메인을 2개로 분리하여 각각의 콜리젼 도메인별로 동시에 2개의 통신이 가능하도록 해줌
* 브리지가 각 장비들이 속해있는 콜리젼 도메인을 기록하는 브리지 테이블을 참조하여 같은 콜리젼 도메인간 통신인지, 다른 콜리젼 도메인간 통신인지 판단
   * 같은 콜리젼 도메인간 데이터 전송 요청일경우, 다른 콜리젼 도메인엔 해당 전송 요청을 보내지 않음으로서, 다른 콜리젼 도메인의 통신은 유휴상태를 유지

### 브리지 테이블
* 허브에 연결되어있는 네트워크 장비들의 MAC 주소를 기록하는 테이블
* MAC 주소와 함께 해당 장비가 속해있는 콜리젼 도메인(세그먼트)의 ID도 기록

### 브리지의 콜리젼 도메인 분리 원리
1. Learning
* 허브에 연결되어있는 네트워크 장비들의 MAC 주소와 속해있는 세그먼트 번호를 자신의 브리지 테이블에 저장하는것
* 1번 세그먼트에 속해있는 pc에서 프레임 전송시, 해당 프레임은 CSMA/CD 통신방식에 따라 1번 세그먼트에 속해있는 모든 pc 및 브리지에 전달됨
   > cf) 프레임 : 데이터 통신 요청, 전송하고자 하는 데이터 + 출발지 MAC 주소 + 목적지 MAC 주소
* 브리지는 전달받은 프레임의 출발지 MAC 주소를 참조하여 해당 주소가 자신의 브리지테이블에 없으면 속해있는 세그먼트 번호와 함께 저장

2. Flooding
* 브리지로 전송된 프레임을 다른 세그먼트의 모든 pc 로 전송하는것
* 브리지로 전송된 프레임의 목적지 MAC 주소가 자신의 브리지 테이블에 없을경우, 반대편 세그먼트에 속해있는 모든 pc 로 프레임 전송
   > CSMA/CD 방식에 따라 출발지 pc 와 같은 세그먼트에 속해있는 모든 pc 엔 이미 프레임 전송되어있음 

3. Forwarding
* 출발지 pc 와 목적지 pc 가 서로다른 세그먼트에 속해있는 경우, 브리지에서 해당 프레임을 목적지 pc 의 세그먼트로 통과시키는것
* 출발지 pc 에서 프레임전송시 CSMA/CD 방식에 따라 같은 세그먼트에 속해있는 pc 들과 함께 브리지에도 프레임 전송됨
* 브리지가 자신의 브리지테이블 참조하여 출발지 MAC 주소와 목적지 MAC주소가 어드 세그먼트에 속해있는지 확인
* 출발지와 목적지가 서로 다른 세그먼트에 속해있는경우, 브리지에서 해당프레임을 다른세그먼트에 속해있는 목적지 MAC 주소로 전송
   > 다른 세그먼트에 속해있는 모든 pc 에 전송하는 Flooding 과는 다름

4. Filtering
* 출발지 pc 와 목적지 pc 가 서로같은 세그먼트에 속해있는 경우, 브리지에서 해당 프레임을 다른 세그먼트로 가지못하도록 차단하는것
* 출발지 pc 에서 프레임전송시 CSMA/CD 방식에 따라 같은 세그먼트에 속해있는 pc 들과 함께 브리지에도 프레임 전송됨
* 브리지가 자신의 브리지테이블 참조하여 출발지 MAC 주소와 목적지 MAC주소가 어느 세그먼트에 속해있는지 확인
* 출발지와 목적지가 서로 같은 세그먼트에 속해있는경우, 브리지를 통하지 않아도 서로 통신이 가능하므로 해당 프레임 차단

5. Aging
* 브리지 테이블은 한정된 저장공간을 가지고 있으므로 브리지 테이블이 꽉 차지 않도록 오래된 세그먼트 정보(MAC 주소 + 속해있는 세그먼트 ID)를 삭제하는것
* 브리지 테이블에 저장되어있는 세그먼트 정보중 설정한 시간(default: 300초)동안 새로운 통신 요청이 들어오지 않은 세그먼트 정보 삭제

<br>

# 스위치
* 브리지와 마찬가지로 허브의 한계를 극복한 네트워크 장비이나 브리지의 업그레이드 버전
* 포트별로 독립적인 통신라인을 가지고있어(포트별로 콜리젼 도메인이 나뉘어 있음) 콜리젼 도메인이 없다고 할 수 있음
   * 브리지는 허브의 콜리젼 도메인을 2개로 나누었으나, 스위치는 포트 수만큼 나누어 통신 속도가 더 빠름
   * 1, 2번포트에 연결되어있는 pc 간 통신을 하면서 동시에 3, 4번 포트에 연결되어있는 pc간 통신 가능
* 100Mbps 속도의 스위치일경우 실제 통신을 100Mbps 로 수행
* 또한 데이터 전송 에러 자동 복구 등의 여러 에러 처리 기능 제공

### 단점
* 허브보다 비싸기때문에 허브로 감당이 안되는 데이터 통신양일경우에만 사용하는것이 좋음
   > 짧은 텍스트 데이터 전송만 이루어지는 채팅 프로그램같은경우, 허브로도 원활한 통신 가능

<br>

# 브리지 - 스위치 차이점
1. 스위치는 하드웨어적 동작방식이므로 소프트웨어적 동작방식인 브리지보다 속도가 빠름
   * 브리지는 허브에 설치하는 프로그램으로서 소프트웨어적으로 콜리젼 도메인 분리 및 처리
   * 반면에 스위치는 독립적인 하드웨어 장비로서 콜리젼 도메인 분리 처리가 저장되어있는 칩으로 동작하므로 매우 고속
2. 브리지는 포트가 모드 같은 속도의 통신만 지원하나 스위치는 포트별로 통신속도가 서로 달라도 통신 가능
   * 10Mbps 랜카드 pc와 100Mbps 랜카드 pc 간 통신 가능
3. 스위치는 장비에 따라 브리지에 비해 제공하는 포트가 훨씬 많고(but 많을수록 비쌈) 스태킹도 가능(여러 스위치를 연결하여 사용하는것)
4. 스위치는 Cut-through / Store-and-forward 처리 방식 2가지를 지원하나 브리지는 Store-and-forward 처리 방식만 지원

### 프레임 처리 방식
1.Store-and-forward
* 스위치(브리지)로 들어오는 프레임을 전부다 받은 후에 처리(프레임에 에러있는 체크, 출발지/목적지 세그먼트 확인등) 시작
* 프레임 전체를 받은 후에 처리하므로 프레임 에러 검출 및 복구에 용이
* 프레임 전체를 받기전엔 처리를 시작하지 않으므로 처리속도가 느림

2.Cut-through
* 스위치로 들어오는 프레임의 처음 48bit까지만 받아 목적지 주소만 확인 후 바로 처리 시작
* 프레임의 일부만 받고서 바로 처리 시작하므로 처리속도가 빠름
* 프레임의 일부만 받고서 프레임 에러를 찾아내야하므로 에러 검출 정확도 및 복구 능력이 떨어짐

3.Fragment-free
* Store-and-forward 방식과 Cut-through 방식의 절충안
* 스위치로 들어오는 프레임의 처음 512bit 까지만 받은 후 처리 시작
* Cut-through 방식에 비해 더 많은 프레임을 받은 후 처리하므로 에러 검출 정확도 및 복구 능력이 더 좋음
* 전체 프레임이 아닌, 512 bit 까지만 받고 처리시작하므로 Store-and-forward 방식에 비해 처리속도가 더 빠름
 
> * 처리 속도 : Cut-through > Fragment-free > Store-and-forward
> * 에러 검출 및 복구 능력 : Store-and-forward > Fragment-free > Cut-througj