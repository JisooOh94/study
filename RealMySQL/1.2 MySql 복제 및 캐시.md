# 복제
* 확장성 및 부하분산을 위해 여러개의 MySql 서버 구축
* 여러개의 MySql 서버들이 동일한 데이터를 담도록 실시간으로 동기화하는 기술
* 동기화를 위해 복제되는 데이터의 일관성을 보장하기 위해 마스터 - 슬레이브를 1:n 으로 구성 
	> 데이터 수정 작업이 여러 Sql 서버에서 수행되면 데이터 일관성을 보장하기 어려움

### 마스터
* 데이터 읽기 뿐만 아니라 수정(생성, 수정, 삭제) 도 가능한 MySql 서버
* 데이터의 구조(DDL)나 내용(DML)을 변경하는 모든 쿼리를 바이너리 로그에 기록
* 'Binlog dumb' 스레드(연결되어있는 슬레이브 서버 수만큼 생성)가 슬레이브 MySql 서버로 바이너리 로그 전송하여 동기화

### 슬레이브
* 데이터 읽기만 가능한 Read-Only MySql 서버
* 바이너리 로그를 요청할 마스터 서버의 연결 정보(IP주소, 포트, 접속 계정) 저장 및 보관
* I/O 스레드가 지속적으로 마스터 서버에 변경 내역 로그(바이너리 로그) 요청하여 읽어와 릴레이 로그에 기록
* SQL 스레드가 릴레이 로그에 기록된 변경내역을 재실행하여 동기화 수행

> cf) 슬레이브 서버 장비는 마스터 서버 장비 스펙과 동일하게 맞춰주는것이 좋다
* 마스터 서버에서 수많은 동시 사용자가 실행한 데이터 변경 쿼리를 슬레이브서버는 단일 스레드(SQL 스레드)로 처리
* 마스터 서버 장애시 슬레이브 서버로 마스터 대체

<br>

# 캐시
* 쿼리의 결과를 메모리에 캐시
* 키 : 쿼리 문장 / 값 : 쿼리 결과

### 캐시 키
* 쿼리 문장의 공백, 탭, 대소문자까지 완전히 동일해야 같은 키로 인식
* 따라서 같은 작업을 하는 쿼리는 static string 변수로 선언하여 하나로 관리하는것이 바람직 

### 캐싱에 적합하지 않은 쿼리
* 호출할때마다 결과값이 달라지는 함수를 사용하는 쿼리(SYSDATE, RAND 등)
* 파라미터를 포함하고있는 프리페어드 스테이트먼트(SELECT * FROM user_info WHERE age = ?)

### 캐시 만료
* 캐싱된 데이터가 수정된 경우, 캐시 메모리에서 해당 캐시 데이터 제거
* row 단위가 아닌, 테이블 단위로 제거 수행
	> ex) user_info 테이블에 새로운 데이터 삽입시, 캐시 메모리에 user_info 테이블 쿼리 엔트리 모두 삭제

### 캐시 메모리 크기 설정
* 캐시 메모리 크기를 크게 설정할시 캐시 만료 과정에서 큰 부하가 발생할 우려가 있으므로 적절한 크기(32mb ~ 64mb)로 설정
> 1gb 크기의 캐시메모리에 user_info 테이블 관련 쿼리로 꽉차 있을때, user_info 테이블이 수정되어 캐시 만료 실행시 1gb 를 전부 삭제할떄 큰 부하 발생

### 캐시 데이터 크기 제한 설정
* 하나의 쿼리 수행 결과 크기가 방대할시, 캐시 메모리가 하나의 쿼리로 가득 차버리는 문제 발생 가능
* 캐싱할 데이터 크기 제한 필요(일반적으로 1mb ~ 2mb)

### 캐시 히트율
* Qcache_hits, Com_select 값을 통해 캐시 히트율 계산
	* Qcache_hits : 캐시 hit 횟수
	* Com_select : 캐시 miss 하여 쿼리 수행된 횟수
	* Qcache_hits + Com_select = 전체 Select 쿼리 요청 횟수
* 쿼리 캐시 히트율 = Qcache_hits / (Qcache_hits + Com_select) * 100
* 쿼리 캐시 효율성은 히트율이 아닌, 절쟉한 컴퓨팅 자원을 기준으로 판단
	* 히트율이 1%라도 그 히트된 1% 의 쿼리가 컴퓨팅자원과 시간을 많이 소모하는 쿼리였다면 캐시 효율성은 좋은것