# ORDER BY 처리
* MySql 옵티마이저는 ORDER BY 처리시, 상황에 따라 인덱스 또는 Filsort 를 이용하여 정렬 수행

### 인덱스
* 이미 인덱스가 정렬되어 저장되어있으므로, 순차적으로 Scan 만 수행하여 매우 빠름
* 레코드 수정/삽입시 인덱스 동기화로 인해 오래 걸리고, 인덱스가 많아질수록 메모리 소모량 증가하는 단점 존재

### Filesort
* 인덱스를 사용하지 않고, 테이블에서 Scan 한 레코드들을 임시 테이블에 저장후 정렬하는 방식
* 인덱스가 없으므로 레코드 수정/삽입시 추가 작업이 없고, 메모리 절약 가능하나 정렬 작업이 오래걸림

<br>

# 소트버퍼
* Filesort 로 정렬 처리시 정렬 수행을 위해 사용되는 메모리 공간
* 소트버퍼의 최대 가용 공간 크기는 sort_buffer_size 로 설정하고, sort_buffer_size 이내에서 정렬해야할 레코드 크기에 따라 가변적으로 버퍼 사이즈 증가
	* sort_buffer_size 크기와 정렬 속도는 관련 없으며, 215KB ~ 512KB 크기로 설정하는것이 적당
* 정렬해야할 레코드 크기가 sort_buffer_size보다 클 경우, 레코드를 분할하여 분할정렬 수행

### 분할 정렬
* 정렬해야할 레코드 크기가 소트버퍼의 sort_buffer_size보다 클 경우 사용
* 전체 레코드를 소트 버퍼에 저장할 수 있는 크기로 분할
* 분할한 레코드 조각을 소트 버퍼에서 정렬 수행 후, 정렬된 결과를 임시로 디스크에 기록
* 모든 레코드 조각들을 정렬하여 디스크에 저장 완료시, 저장된 정렬 결과들을 디스크에서 읽어 다시 병합하여 정렬 수행(멀티머지)
* 정렬 작업중에 많은 디스크 I/O 가 필요하므로 성능이 떨어짐

<br>

# 정렬 알고리즘
* 소트버퍼에 레코드 전체를 저장할지, 정렬 기준 칼럼값만 저장할지에 따라 구분

### 싱글 패스 알고리즘
* 정렬기준 칼럼 뿐만 아니라 SELECT 되는 칼럼들도 함께 소트버퍼에 저장하여 정렬하는 알고리즘
* 테이블을 한번만 읽어 정렬과 SELECT 를 함께 처리할수 있어 효율적이지만, SELECT 되는 칼럼값에 따라 많은 소트버퍼 공간 필요
* 최신버전 MySql 에선 defaul 로 싱글패스 알고리즘을 사용하나, 특수한 경우엔 투패스알고리즘으로 정렬 수행
	* SELECT 되는 칼럼들의 크기가 소트버퍼 최대 크기가보다 크거나, 칼럼 타입이 BLOB/TEXT 인경우 > 방대한 크기의 소트버퍼를 필요로 하므로
* 레코드의 크기나 건수가 작은경우에 효율적

### 투 패스 알고리즘
* 정렬기준 칼럼과 기본키만 소트버퍼에 저장하여 정렬하는 알고리즘
* 소트버퍼에서 정렬된 순서대로 기본키를 통해 테이블에서 다시 SELECT 수행
* 테이블을 2번 읽어야 하기때문에 성능이 떨어지나, 적은 소트 버퍼공간만을 사용하여 정렬 가능
* 레코드의 크기나 건수가 큰경우에 효율적

<br>

# 정렬 처리 방식
* mySql 옵티마이저는 ORDER BY 절 칼럼의 인덱스 유무에 따라 인덱스를 이용한 정렬 또는 직접 정렬 수행
* 조인 쿼리일 경우, 정렬 기준 칼럼에 따라 드라이빙 테이블 정렬 또는 임시 테이블 정렬 방식으로 정렬 수행

### 인덱스를 이용한 정렬
* 인덱스는 자동 정렬되어있으므로, 정렬을 위한 별도의 작업이 불필요하여 성능이 매우 좋음  
* 조건
	* ORDER BY 절의 칼럼에 해당하는 인덱스 필요
	* 명시된 칼럼이 여러개일 경우, 명시된 순서와 동일한 순서로 생성된 인덱스 필요
	* WHERE 절을 포함하고 있을경우, 정렬에 사용되는 인덱스의 칼럼만 WHERE 절에 사용 가능
	
### 직접 정렬
* ORDER BY 절의 칼럼에 해당하는 인덱스가 없는경우 수행되며 쿼리플랜의 extran 칼럼에 'using filesort' 출력
* 조회된 레코드들을 정렬용 메모리 버퍼에 복사 후 퀵소트 정렬 수행

### 드라이빙 테이블 정렬
* 조인쿼리에서 ORDER BY 처리시, mySql 의 Nested Loop Join 특성을 이용하여 드라이빙 테이블만 정렬 수행
* 드라이빙 테이블의 레코드 조회및 정렬 수행 후, 그 결과로 드리븐 테이블과 조인 수행
* 임시 테이블 없이, 정렬용 메모리 버퍼만 사용
* 조건
	* ORDER BY 절의 칼럼이 드라이빙 테이블의 칼럼으로만 구성

### 임시 테이블 정렬
* 조인 쿼리에서 ORDER BY 처리시, 두 테이블의 조인 먼저 수행후, 조인된 결과가 저장되어있는 임시테이블의 정렬 수행
* 일반적으로 조인 수행시, 레코드 수가 몇배로 불어나므로, 정렬이 매우 오래걸려 성능이 떨어짐

<br>

# 인덱스와 정렬 처리 성능
### 인덱스를 이용한 정렬과 스트리밍 방식
* 인덱스를 이용한 정렬처리시, 정렬을 위한 별도 작업없이 인덱스 순차 scan 하므로, 스트리밍 방식을 이용하여 빠른 성능 보장 가능
* 스트리밍 방식을 이용하므로 LIMIT 절을 통한 성능 향상의 효과도 큼
#### 스트리밍 방식
* 테이블 scan하면서, 레코드 select 될때마다 바로바로 클라이언트로 전송해주는 방식
* 클라이언트는 전송되는 레코드들부터 먼저 가공작업이나 후처리 작업 시작할 수 있으므로 mySql로부터 응답을 받기위해 대기하는 시간이 줄어듬 
* 마지막 select 되는 레코드는 언제 전송할지 알 수 없으나, scan 해야하는 전체 테이블 크기에 상관없이 첫번쨰 select 되는 레코드는 매우 빠른 응답시간 보장
* LIMIT 절을 통해 전체 테이블 scan 필요 없이, LIMIT 수치만큼의 레코드만 select 하고 scan을 중단할 수 있으므로 성능 향상 가능

### 직접정렬과 버퍼링 방식
* 인덱스 없이 직접 정렬처리시, 테이블 scan 하여 select 된 레코드들을 버퍼에 모아두고(버퍼링) 정렬을 수행한 후에 클라이언트로 응답하므로 select 하면서 바로바로 응답하는 스트리밍 방식 사용 불가
* 전체 테이블 scan 및 정렬 작업까지 완료된 후에야 클라이언트로 전송핳므로, 클라이언트의 대기시간이 길어지고 성능이 떨어짐
* 전체 테이블 scan 및 정렬 작업까지 완료 후에 LIMIT 절이 적용되므로 성능향상이나 작업량 감소나 처리시간 단축 효과 거의 없음
> cf) 좀 더 엄밀히 말하자면, 정렬 과정에서 LIMIT 절이 적용됨, 정렬 작업 수행하면서 LIMIT 수치만큼의 상위 레코드가 정렬 완료되면 클라이언트로 전송. 하지만 mySql 의 정렬알고리즘인 퀵소트의 특성상 전체 정렬 후 LIMIT 절 적용과 작업량의 큰 차이 없음
> cf) 이러한 이유때문에, 직접정렬방식을 사용해야하는 쿼리에서 페이지네이션 처리는 클라이언트의 메모리상에 이득만 있을뿐, mySql 작업량의 이득은 거의 없음

### 튜닝 포인트
* 인덱스를 이용한 정렬과 직접정렬의 성능차이가 크게 나므로, 가급적 인덱스를 사용하여 정렬수행하도록 유도
* 인덱스를 이용한 정렬 처리 불가시, 최소한 드라이빙 테이블만 정렬하는방식으로 정렬처리 하도록 유도