# ORDER BY 처리
* MySql 옵티마이저는 ORDER BY 처리시, 상황에 따라 인덱스 또는 Filsort 를 이용하여 정렬 수행

### 인덱스
* 이미 인덱스가 정렬되어 저장되어있으므로, 순차적으로 Scan 만 수행하여 매우 빠름
* 레코드 수정/삽입시 인덱스 동기화로 인해 오래 걸리고, 인덱스가 많아질수록 메모리 소모량 증가하는 단점 존재

### Filesort
* 인덱스를 사용하지 않고, 테이블에서 Scan 한 레코드들을 임시 테이블에 저장후 정렬하는 방식
* 인덱스가 없으므로 레코드 수정/삽입시 추가 작업이 없고, 메모리 절약 가능하나 정렬 작업이 오래걸림

<br>

# 소트버퍼
* Filesort 로 정렬 처리시 정렬 수행을 위해 사용되는 메모리 공간
* 소트버퍼의 최대 가용 공간 크기는 sort_buffer_size 로 설정하고, sort_buffer_size 이내에서 정렬해야할 레코드 크기에 따라 가변적으로 버퍼 사이즈 증가
	* sort_buffer_size 크기와 정렬 속도는 관련 없으며, 215KB ~ 512KB 크기로 설정하는것이 적당
* 정렬해야할 레코드 크기가 sort_buffer_size보다 클 경우, 레코드를 분할하여 분할정렬 수행

### 분할 정렬
* 정렬해야할 레코드 크기가 소트버퍼의 sort_buffer_size보다 클 경우 사용
* 전체 레코드를 소트 버퍼에 저장할 수 있는 크기로 분할
* 분할한 레코드 조각을 소트 버퍼에서 정렬 수행 후, 정렬된 결과를 임시로 디스크에 기록
* 모든 레코드 조각들을 정렬하여 디스크에 저장 완료시, 저장된 정렬 결과들을 디스크에서 읽어 다시 병합하여 정렬 수행(멀티머지)
* 정렬 작업중에 많은 디스크 I/O 가 필요하므로 성능이 떨어짐

<br>

# 정렬 알고리즘
* 소트버퍼에 레코드 전체를 저장할지, 정렬 기준 칼럼값만 저장할지에 따라 구분

### 싱글 패스 알고리즘
* 정렬기준 칼럼 뿐만 아니라 SELECT 되는 칼럼들도 함께 소트버퍼에 저장하여 정렬하는 알고리즘
* 테이블을 한번만 읽어 정렬과 SELECT 를 함께 처리할수 있어 효율적이지만, SELECT 되는 칼럼값에 따라 많은 소트버퍼 공간 필요
* 최신버전 MySql 에선 defaul 로 싱글패스 알고리즘을 사용하나, 특수한 경우엔 투패스알고리즘으로 정렬 수행
	* SELECT 되는 칼럼의 크기가 소트버퍼 최대 크기가보다 크거나, 칼럼 타입이 BLOB/TEXT 인경우 > 방대한 크기의 소트버퍼를 필요로 하므로
* 레코드의 크기나 건수가 작은경우에 효율적

### 투 패스 알고리즘
* 정렬기준 칼럼과 기본키만 소트버퍼에 저장하여 정렬하는 알고리즘
* 소트버퍼에서 정렬된 순서대로 기본키를 통해 테이블에서 다시 SELECT 수행
* 테이블을 2번 읽어야 하기때문에 성능이 떨어지나, 적은 소트 버퍼공간만을 사용하여 정렬 가능
* 레코드의 크기나 건수가 큰경우에 효율적