# 쿼리 실행 과정
### 1. Sql 파싱
* Sql 파서
* Sql 문장 분해 및 Sql 파스트리로 재 구성
* Sql 문장의 문법 오류 검출

### 2. 옵티마이징
* 옵티마이저
* Sql 파스트리를 참조하여 쿼리 플랜 수립
* 불필요한 조건 제거 및 복잡한 연산 단순화 등의 쿼리 최적화 수행
* 통계 테이블을 기반으로 사용할 인덱스 선택 및 조회할 테이블 순서 결정

### 3. 테이블 Read
* 스토리지엔진
* 쿼리플랜에 따라 스토리지 엔진에게 테이블 조회 요청
* 조회한 결과에 또다른 가공(정렬, 조인등)이 필요할 경우 MySql 엔진에서 처리

<br>

# 옵티마이저
* Sql 쿼리의 최적화 및 가장 효율적인 쿼리 플랜 수립
* 규칙기반, 비용기반 옵티마이저로 구분

### 규칙기반
* 대상 테이블의 레코드수나 인덱스 선택도 등은 고려하지 않고 미리 정의된 우선순위에 따라 실행계획 수립
* 비효율적, 현대에는 거의 사용되지 않음

### 비용기반
* 테이블 레코드수, 선택도등의 통계정보를 기반으로 실행계획 수립
* 효율적, 대부분의 DBMS 에서 사용 
* ANALYZE 명령을 통해 통계 정보 갱신 요청 가능(일반적으로 자동 갱신됨) 

```sql
ANALYZE TABLE user_info
```

<br>

# 실행 계획
# id
* 쿼리 수행 과정에서 실행된 단위 SELECT 쿼리 각각에 부여되는 고유한 식별값
* 1부터 시작하며, 서브쿼리나 UNION 등으로 단위 쿼리가 여러개일 경우, 1씩 증가하여 부여됨
```sql
SELECT *
FROM
	(SELECT user_name AS name FROM user_info) UNION
    (SELECT emp_name AS name FROM emp_info)
```

<br>

# select_type
* SELECT 쿼리의 타입을 명시하는 칼럼

### SIMPLE
* UNION 이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리

### PRIMARY
* UNION 이나 서브쿼리를 포함하고있는 쿼리의 가장 바깥쪽 SELECT 쿼리

### UNION
* UNION 으로 결합된 단위 쿼리 가운데 첫번째 단위쿼리를 제외한 나머지 단위쿼리
```sql
SELECT *
FROM (SELECT user_name FROM paid_user_info) UNION
	(SELECT user_name FROM free_user_info) UNION
	(SELECT user_name FROM abuse_user_info)
```
* 첫번째 단위쿼리의 경우, UNION 한 결과 테이블이 사용되는 위치에 따라 결정 (SELECT 절 : PRIMARY, FROM 절 : DERIVED)

### DEPENDENT UNION
* UNION 단위쿼리중, 외부의 값이나 조건이 사용된 쿼리
```sql
SELECT *
FROM (
  		(SELECT user_name FROM paid_user_info) UNION
		(SELECT user_name FROM free_user_info) UNION
		(SELECT user_name FROM abuse_user_info WHERE user_dept_name = d.dept_name)
  	 ) u,
     dept_info d
WHERE
	u.user_name = d.member_name
```

### UNION RESULT
* UNION 으로 결합한 결과를 담아두는 임시 테이블

### SUBQUERY
* SELECT, WHERE 절에 사용된 서브쿼리
> 서브쿼리의 위치별 명칭
> * SELECT 절 : 중첩 쿼리 (Nested Query)
> * WHERE 절 : 서브 쿼리 
> * FROM 절 : 파생 테이블 (Derived)
```sql
SELECT
	COUNT(1) AS userCnt,
    (SELECT COUNT(1) FROM dept_info) AS deptCnt
FROM
	user_info
``` 
```sql
SELECT
	user_id
FROM
	user_info
WHERE
	user_age >= (SELECT AVG(user_age) FROM user_info)
```

### DEPENDENT SUBQUERY
* 서브쿼리중, 외부의 값이나 조건이 사용된 쿼리
```sql
SELECT
	user_name AS userName,
    (SELECT dept_name FROM dept_info WHERE dept_role = u.user_role) AS deptName
FROM
	user_info u
``` 

### DERIVED
* FROM 절에 사용된 서브쿼리
```sql
SELECT
	COUNT(1)
FROM
	(SELECT dept_name FROM dept_info WHERE dept_role IN ('fe', 'be')) d,
     user_info u
WHERE
	d.dept_name = u.dept_name
```

### UNCACHEABLE SUBQUERY
* 수행 결과의 캐싱이 불가능한 서브 쿼리
	* mySql 에선 서브쿼리 수행 결과를 별도의 내부 캐시 메모리에 저장후 추후 동일한 조건의 서브쿼리 수행시 재사용 
* 서브쿼리에 결과값이 호출할때마다 달라지는 함수나 조건이 사용된 경우 (사용자 변수, RAND() 등)

<br>

# type
* 테이블 스캔 방식
* 쿼리 성능과 매우 밀접한 정보이므로 쿼리 튜닝시 가장먼저 확인
* 이론상 다음의 나열한 순으로 효율적이나, 레코드 건수나 인덱스 선택도에 따라 효율성이 달라질수 있으므로, 옵티마이저는 통계데이터를 기반으로 선택

### system
* 레코드가 1건만 존재하는 테이블 스캔시 사용
* MyISAM 스토리지엔진에만 존재(InnoDB X)

### const
* 유니크 칼럼 동등조건으로 검색시 사용
* 1개의 레코드만 반환 보장
```sql
SELECT * FROM user_info WHERE user_id = 'foo'
```

### eq_ref
* 여러 테이블 조인 쿼리에서, 선행 테이블 칼럼값으로 후행 테이블 유니크 칼럼 동등조건 검색시 사용
```sql
SELECT * FROM user_info u, emp_info e WHERE u.user_no = e.emp_no
```  

### ref
* 일반 칼럼 동등조건으로 검색시 사용
* 복수 레코드 반환 가능
```sql
SELECT * FROM user_info WHERE user_age = 20
```

### fulltext
* 전문검색 쿼리를 전문검색 인덱스로 검색시 사용

### ref_or_null
* 일반 칼럼 동등조건 또는 NULL 조건으로 검색시 사용
```sql
SELECT * FROM user_info WHERE user_age = 20 OR user_age IS NULL
```

### unique_subquery
* IN (subQuery) 에서 subQuery 가 유니크 값만 반환하는 경우 사용
```sql
SELECT * FROM user_info WHERE user_id IN (SELECT emp_id FROM emp_info WHERE emp_role = 'boss')
```

### index_subquery
* IN (subQuery) 에서 subQuery 가 중복값 반환하는 경우 사용
* 중복 제거과정 수행
```sql
SELECT * FROM user_info WHERE user_id IN (SELECT emp_id FROM emp_info WHERE emp_role = 'engineer')
```

### range
* 인덱스 레인지 스캔
* 고성능까지는 아니나 어느정도의 성능 보장
```sql
SELECT * FROM user_info WHERE user_no BETWEEN 1 AND 100;
```

### index_merge
* 2개 이상의 인덱스를 이용해 검색
* 각각의 인덱스로 검색한 결과 레코드들을 병합하는 처리방식
* 여러 인덱스를 스캔해야하고, 스캔후 병합과정이 필요하므로 인덱스 레인지 스캔보다 비효율적
```sql
SELECT * FROM user_info WHERE user_id LIKE 'a%' OR user_no > 1
```

### index
* 인덱스 풀 스캔
* 풀 스캔이면서 커버링 인덱스 쿼리인 경우 > 테이블 스캔 생략 가능
```sql
SELECT user_id FROM user_info 
```
* 풀 스캔이면서 ORDER BY 나 GROUP BY 쿼리인 경우 > 스캔한 레코드들에 대한 정렬 작업 생략 가능
```sql
SELECT * FROM user_info ORDER BY user_id DESC 
```

### ALL
* 테이블 풀 스캔
* 대량의 디스크 I/O 발생하므로 매우 느림

<br>

# 튜닝 포인트
### DEPENDENT
* UNION 단위쿼리나 서브쿼리중 외부 값이나 조건을 사용하는 쿼리
* 일반적으로 서브쿼리 수행 후 외부쿼리 수행하는것이 더 효율적
* DEPENDENT 쿼리의 경우, 외부값에 의존하므로 외부쿼리 먼저 수행
* 비효율적이고 쿼리 성능이 떨어지므로 튜닝 필요

### DERIVED
* FROM 절에 사용된 서브쿼리
* 서브쿼리 수행결과를 임시테이블로 만들어 임시 테이블에 대해 외부쿼리 수행
* 임시테이블엔 어떠한 인덱스도 없으므로 쿼리 성능이 안좋은 경우가 많음
* FROM 절에 서브쿼리 사용시, 가급적 조인으로 대체하고 불가피할경우 최대한 성능을 염두에 두고 사용