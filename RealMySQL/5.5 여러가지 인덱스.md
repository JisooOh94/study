# 해시 인덱스
* 인덱스 키로 키 칼럼의 해시값을 사용하는 인덱스
* 체이닝 구조의 해시테이블
* 디스크 기반의 대용량 인덱스로는 사용되지 않고, 메모리 기반의 소규모 인덱스에 주로 사용
* 동등 비교 검색 속도는 매우 빠르나, 범위 검색이나 정렬 검색에 사용 불가능
* 키 칼럼 해쉬값을 저장하므로 칼럼값의 크기에 상관없이 인덱스 테이블의 크기가 작음

<br>

# 공간 인덱스
* R-Tree 인덱스 알고리즘을 이용해 2 차원 데이터를 인덱싱하는 인덱스
* 인덱스 키가 2차원
* 주로 위치 기반 서비스(지도)에 사용

<br>

# 전문 검색 인덱스
* 문서 내용 전체를 인덱싱하는 인덱스
* 특정 키워드가 포함된 문서를 검색하는 전문검색에 주로 사용
* 문서 내용 전체에서 사용자가 검색하게 될 키워드를 분석 및 추출한 값으로 인덱스 키 설정
* 키워드 분석 및 추출 알고리즘으로 구분자 기법, N그램 기법 사용

<br>

# 함수 기반 인덱스
* 레코드에 대해 특정 함수를 수행한 결과값을 키값으로 사용하는 인덱스
> e.g. 레코드 특정 칼럼값의 해쉬값(해싱함수) 
* 함수의 결과값을 저장할 별도의 칼럼 생성 후 해당 칼럼을 인덱스 키 칼럼으로 사용

<br>

# 클러스터링 인덱스
* 키 값이 비슷한 레코드들끼리 묶어서 인덱싱하는 인덱스
* 데이터베이스 조회시 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안
* 인덱스 키 칼럼으로 기본키 칼럼만 사용 가능
* 기본키 기반 검색이 매우 빠르나 레코드 수정 성능 저하 

<br>

# 유니크 인덱스
* 유니크 제약조건이 설정되어있는 칼럼을 인덱스 키 칼럼으로 사용하는 인덱스
* 유니크 제약조건이 없는 일반 보조인덱스에 비해 성능상 이점이 거의 없으므로 반드시 필요한 경우에만 사용
	* 인덱스 검색
		* 유니크 인덱스의 경우 중복되는 값이 없으므로 동등 비교 검색시 O(1) 로 검색 가능
		* 보조 인덱스의 경우 값 중복이 허용되므로 1차적으로 동등 비교 검색후 검색된 인덱스 레코드들에 대해 2차로 full scan 다시 수행
		* 하지만 full scan 의 경우 검색된 인덱스 레코드들이 메모리에 로드된후 메모리 상에서 수행되기 때문에 매우 빠름
		* 따라서 인덱스 검색의 경우, 보조 인덱스가 1차 동등비교 검색시 랜덤 Disk I/O 를 조금 더 수행하는데서 오는 성능 저하 외엔 유니크인덱스와 성능 차이 없음  
	* 인덱스 삽입
		* 보조 인덱스의 경우 중복값이 허용되므로 비어있는 디스크 블록에 바로 삽입 가능
		* 유니크 인덱스의 경우 삽입전, 중복값이 존재하는지 인덱스 검색 후 삽입
		* 인덱스 검색시 읽기 잠금, 삽입시 쓰기 잠금을 사용하게 되는데, 이 과정에서 데드락 빈번히 발생
