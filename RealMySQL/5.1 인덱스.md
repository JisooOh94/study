# 인덱스
* 데이터베이스는 데이터를 기계식 장치인 Disk 에 저장하므로 속도가 느림
* 따라서 데이터베이스 CRUD 시, 테이블 Full-Scan 을 최소화하고, 필요한 데이터만 최소한으로 읽는것이 중요
* 데이터베이스 조회시, 인덱스를 통해 매우 빠르게 원하는 데이터만 조회 가능

### 장단점
* 장점 : 정렬되어있는 인덱스 트리를 통해 매우 빠르게 원하는 데이터 탐색 및 조회 가능
* 단점 : 새로운 데이터의 삽입이나 기존 데이터의 수정, 삭제시 그 내용에 따라 인덱스 트리도 함께 업데이트 해줘야하므로 느림
> 실제서비스에서 데이터의 쓰기 작업보다 읽기 작업이 훨씬 많으므로 쓰기 성능을 어느정도 희생하여 읽기 성능을 높이는 것이 더 효율적

### 인덱스 분류
* 인덱스 키에 따라
	* 프라이머리 키
	* 보조인덱스
* 자료구조에 따라
	* B-Tree
	* Hash
	* Fractal-Tree
* 인덱스 키의 유니트 여부에 따라
	* 유니크 인덱스
	* 넌유니크 인덱스

<br>

# 인덱스 CRUD Internal
### 인덱스 추가
* 추가할 키값에 해당하는 리프 노드 탐색 하여 추가
* 탐색한 리프노드의 디스크블록이 꽉 차 있을경우, 새로운 리프노드를 추가해야하는데, 이는 전체 인덱스 트리도 재정렬이 필요하므로 부하가 크고 응답도 지연됨
* MyISAM 엔진은 바로 인덱스 트리에 새로운 인덱스를 추가하나, InnoDB 엔진의 경우 버퍼풀에 임시 저장 후, 추후 데이터베이스 서버 자원에 여유가 있을때 백그라운드 스레드(인서트 버퍼 머지 스레드)로 인덱스 추가 작업 수행

### 인덱스 삭제
* 삭제할 인덱스 키를 찾아 삭제 마킹 수행 > 옵션에 따라 마킹된 공간을 방치하거나 재활용 가능
* 인덱스 추가에 비해 상대적으로 간단하나 마찬가지로 Disk I/O 가 필요하므로 저속
* InnoDB 엔진의 경우 인덱스 추가와 마찬가지로 버퍼풀에 삭제작업 버퍼링 후 추후 처리 가능

### 인덱스 변경
* 기존 인덱스 삭제 후 변경된 값으로 인덱스 추가 수행

### 인덱스 검색
* 키값의 완전 일치 / 앞부분 일치 조건으로 검색시 인덱스 사용 가능
	> 부등호 비교 / 뒷부분 일치 조건 검색시 인덱스 사용 불가능
```sql
//인덱스 사용
WHERE 
	user_id = 'foo'
	OR user_id LIKE 'f%'

//인덱스 사용 불가능
WHERE
	user_id <= 'foo'
	OR user_id LIKE '%o'

```

<br>

# 인덱스 성능 이슈
### 키값 크기

### 선택도

### 조회될 레코드 수