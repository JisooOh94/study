# 인덱스
* 데이터베이스는 데이터를 기계식 장치인 Disk 에 저장하므로 속도가 느림
* 따라서 데이터베이스 CRUD 시, 테이블 Full-Scan 을 최소화하고, 필요한 데이터만 최소한으로 읽는것이 중요
* 데이터베이스 조회시, 인덱스를 통해 매우 빠르게 원하는 데이터만 조회 가능

### 장단점
* 장점 : 정렬되어있는 인덱스 트리를 통해 매우 빠르게 원하는 데이터 탐색 및 조회 가능
* 단점 : 새로운 데이터의 삽입이나 기존 데이터의 수정, 삭제시 그 내용에 따라 인덱스 트리도 함께 업데이트 해줘야하므로 느림
> 실제서비스에서 데이터의 쓰기 작업보다 읽기 작업이 훨씬 많으므로 쓰기 성능을 어느정도 희생하여 읽기 성능을 높이는 것이 더 효율적

### 인덱스 분류
* 인덱스 키에 따라
	* 프라이머리 키
	* 보조인덱스
* 자료구조에 따라
	* B-Tree
	* Hash
	* Fractal-Tree
* 인덱스 키의 유니트 여부에 따라
	* 유니크 인덱스
	* 넌유니크 인덱스

<br>

# 인덱스 CRUD Internal
### 인덱스 추가
* 추가할 키값에 해당하는 리프 노드 탐색 하여 추가
* 탐색한 리프노드의 디스크블록이 꽉 차 있을경우, 새로운 리프노드를 추가해야하는데, 이는 전체 인덱스 트리도 재정렬이 필요하므로 부하가 크고 응답도 지연됨
* MyISAM 엔진은 바로 인덱스 트리에 새로운 인덱스를 추가하나, InnoDB 엔진의 경우 버퍼풀에 임시 저장 후, 추후 데이터베이스 서버 자원에 여유가 있을때 백그라운드 스레드(인서트 버퍼 머지 스레드)로 인덱스 추가 작업 수행

### 인덱스 삭제
* 삭제할 인덱스 키를 찾아 삭제 마킹 수행 > 옵션에 따라 마킹된 공간을 방치하거나 재활용 가능
* 인덱스 추가에 비해 상대적으로 간단하나 마찬가지로 Disk I/O 가 필요하므로 저속
* InnoDB 엔진의 경우 인덱스 추가와 마찬가지로 버퍼풀에 삭제작업 버퍼링 후 추후 처리 가능

### 인덱스 변경
* 기존 인덱스 삭제 후 변경된 값으로 인덱스 추가 수행

### 인덱스 검색
* 키값의 완전 일치 / 앞부분 일치 조건으로 검색시 인덱스 사용 가능
	> 부등호 비교 / 뒷부분 일치 조건 검색시 인덱스 사용 불가능
```sql
//인덱스 사용
WHERE 
	user_id = 'foo'
	OR user_id LIKE 'f%'

//인덱스 사용 불가능
WHERE
	user_id <= 'foo'
	OR user_id LIKE '%o'

```

<br>

# 인덱스 성능 이슈
### 키값 크기
* 인덱스는 디스크의 하나의 블록에 [키 - 주소] 형태로 저장 (루트/브랜치 노드 - 자식 블록 주소, 리프 노드 - 레코드 저장 주소)
* 하나의 블록(16kb)에 저장할 수 있는 인덱스 수는 인덱스의 키 값 크기에 따라 달라짐
	* 키 칼럼 타입이 BIGINT(8 byte) 이고 주소 크기가 12 byte 일경우 하나의 블록에 저장할 수 있는 인덱스 개수 :  16000 / 20 = 800 개
	* 키 칼럼 타입이 SMALLINT(2 byte) 이고 주소 크기가 12 byte 일경우 하나의 블록에 저장할 수 있는 인덱스 개수 : 16000 / 14 = 1142개
* 하나의 블록에 저장되어있는 인덱스 개수가 많을수록 인덱스 조회시 수행되는 Disk I/O (Block 단위 read) 작업이 줄어드므로 더 효율적
* 인덱스 크기가 작을 수록, 메모리에 캐싱되어있을수 있는 인덱스 개수가 늘어나므로 더 효율적
* 따라서 인덱스 키 칼럼 선택시 크기가 더 작은 데이터 타입의 칼럼 선택  

### 선택도
* 전체 인덱스 키값중, 유니크한 키값(키 값의 종류)의 비율
	* '거주지역' 칼럼을 키로가지는 인덱스 100개중, 유니크한 키값이 (서울, 대구, 울산, 제주) 4개라면 선택도는 4
	* '직업' 칼럼을 키로하는 인덱스 100개중, 유니크한 키값이 (교사, 판사, 검사, 변호사, 의사, 회계사, 경찰, 경비) 8개라면 선택도는 8
* 조회쿼리 수행시 선택도가 높을수록(중복되는 키값이 적을수록) 탐색대상이 줄어들기때문에 더 효율적
	* '거주지역' 칼럼값을 where 조건으로 조회 쿼리 수행시, 평균적으로 25개의 레코드 scan 필요
	* '직업' 칼럼값을 where 조건으로 조회 쿼리 수행시, 평균적으로 16개의 레코드 scan 필요	>> 더 적에 scan 하므로 더 빠름 
* 따라서 인덱스 키 칼럼 선택시 unique 제약조건이 걸려있거나, 혹은 중복값이 덜 발생할것 같은 칼럼 선택

### 조회될 레코드 수
* 일반적으로 데이터 조회시, 인덱스를 통해 조회하는 비용이, 테이블에서 직업 조회(탐색 비용 제외)하는 비용보다 4~5배 정도 더 비쌈
	* 테이블에 레코드가 1개만 존재한다 가정했을때, 테이블에서 바로 레코드를 조회하는 비용보다 인덱스의 root > leaf 노드까지 거쳐서 레코드에 도달하는 비용이 더 비쌈
* 따라서 조회쿼리를 통해 읽어야 할 레코드수가 전체 레코드수의 20~25 % 이상일 경우, 인덱스를 타지 않고 테이블 full scan 으로 조회하는것이 더 효율적 (쿼리 옵티마이저가 자동으로 full scan 수행)