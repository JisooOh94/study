# 인덱스
* 데이터베이스는 데이터를 기계식 장치인 Disk 에 저장하므로 속도가 느림
* 따라서 데이터베이스 CRUD 시, 테이블 Full-Scan 을 최소화하고, 필요한 데이터만 최소한으로 읽는것이 중요
* 데이터베이스 조회시, 인덱스를 통해 매우 빠르게 원하는 데이터만 조회 가능

### 장단점
* 장점 : 정렬되어있는 인덱스 트리를 통해 매우 빠르게 원하는 데이터 탐색 및 조회 가능
* 단점 : 새로운 데이터의 삽입이나 기존 데이터의 수정, 삭제시 그 내용에 따라 인덱스 트리도 함께 업데이트 해줘야하므로 느림
> 실제서비스에서 데이터의 쓰기 작업보다 읽기 작업이 훨씬 많으므로 쓰기 성능을 어느정도 희생하여 읽기 성능을 높이는 것이 더 효율적

### 인덱스 분류
* 인덱스 키에 따라
	* 프라이머리 키
	* 보조인덱스
* 자료구조에 따라
	* B-Tree
	* Hash
	* Fractal-Tree
* 인덱스 키의 유니트 여부에 따라
	* 유니크 인덱스
	* 넌유니크 인덱스

<br>

# 인덱스 CRUD Internal
### 인덱스 추가
* 추가할 키값에 해당하는 리프 노드 탐색 하여 추가
* 탐색한 리프노드의 디스크블록이 꽉 차 있을경우, 새로운 리프노드를 추가해야하는데, 이는 전체 인덱스 트리도 재정렬이 필요하므로 부하가 크고 응답도 지연됨
* MyISAM 엔진은 바로 인덱스 트리에 새로운 인덱스를 추가하나, InnoDB 엔진의 경우 버퍼풀에 임시 저장 후, 추후 데이터베이스 서버 자원에 여유가 있을때 백그라운드 스레드(인서트 버퍼 머지 스레드)로 인덱스 추가 작업 수행

### 인덱스 삭제
* 삭제할 인덱스 키를 찾아 삭제 마킹 수행 > 옵션에 따라 마킹된 공간을 방치하거나 재활용 가능
* 인덱스 추가에 비해 상대적으로 간단하나 마찬가지로 Disk I/O 가 필요하므로 저속
* InnoDB 엔진의 경우 인덱스 추가와 마찬가지로 버퍼풀에 삭제작업 버퍼링 후 추후 처리 가능

### 인덱스 변경
* 기존 인덱스 삭제 후 변경된 값으로 인덱스 추가 수행

### 인덱스 검색
* 키값의 완전 일치 / 앞부분 일치 조건으로 검색시 인덱스 사용 가능
	> 부등호 비교 / 뒷부분 일치 조건 검색시 인덱스 사용 불가능
```sql
//인덱스 사용
WHERE 
	user_id = 'foo'
	OR user_id LIKE 'f%'

//인덱스 사용 불가능
WHERE
	user_id <= 'foo'
	OR user_id LIKE '%o'

```

<br>

# 인덱스 성능 이슈
### 키값 크기
* 인덱스는 디스크의 하나의 블록에 [키 - 주소] 형태로 저장 (루트/브랜치 노드 - 자식 블록 주소, 리프 노드 - 레코드 저장 주소)
* 하나의 블록(16kb)에 저장할 수 있는 인덱스 수는 인덱스의 키 값 크기에 따라 달라짐
	* 키 칼럼 타입이 BIGINT(8 byte) 이고 주소 크기가 12 byte 일경우 하나의 블록에 저장할 수 있는 인덱스 개수 :  16000 / 20 = 800 개
	* 키 칼럼 타입이 SMALLINT(2 byte) 이고 주소 크기가 12 byte 일경우 하나의 블록에 저장할 수 있는 인덱스 개수 : 16000 / 14 = 1142개
* 하나의 블록에 저장되어있는 인덱스 개수가 많을수록 인덱스 조회시 수행되는 Disk I/O (Block 단위 read) 작업이 줄어드므로 더 효율적
* 인덱스 크기가 작을 수록, 메모리에 캐싱되어있을수 있는 인덱스 개수가 늘어나므로 더 효율적
* 따라서 인덱스 키 칼럼 선택시 크기가 더 작은 데이터 타입의 칼럼 선택  

### 선택도
* 전체 인덱스 키값중, 유니크한 키값(키 값의 종류)의 비율
	* '거주지역' 칼럼을 키로가지는 인덱스 100개중, 유니크한 키값이 (서울, 대구, 울산, 제주) 4개라면 선택도는 4
	* '직업' 칼럼을 키로하는 인덱스 100개중, 유니크한 키값이 (교사, 판사, 검사, 변호사, 의사, 회계사, 경찰, 경비) 8개라면 선택도는 8
* 조회쿼리 수행시 선택도가 높을수록(중복되는 키값이 적을수록) 탐색대상이 줄어들기때문에 더 효율적
	* '거주지역' 칼럼값을 where 조건으로 조회 쿼리 수행시, 평균적으로 25개의 레코드 scan 필요
	* '직업' 칼럼값을 where 조건으로 조회 쿼리 수행시, 평균적으로 16개의 레코드 scan 필요	>> 더 적에 scan 하므로 더 빠름 
* 따라서 인덱스 키 칼럼 선택시 unique 제약조건이 걸려있거나, 혹은 중복값이 덜 발생할것 같은 칼럼 선택

### 조회될 레코드 수
* 일반적으로 데이터 조회시, 인덱스를 통해 조회하는 비용이, 테이블에서 직업 조회(탐색 비용 제외)하는 비용보다 4~5배 정도 더 비쌈
	* 테이블에 레코드가 1개만 존재한다 가정했을때, 테이블에서 바로 레코드를 조회하는 비용보다 인덱스의 root > leaf 노드까지 거쳐서 레코드에 도달하는 비용이 더 비쌈
* 따라서 조회쿼리를 통해 읽어야 할 레코드수가 전체 레코드수의 20~25 % 이상일 경우, 인덱스를 타지 않고 테이블 full scan 으로 조회하는것이 더 효율적 (쿼리 옵티마이저가 자동으로 full scan 수행)

<br>

# 인덱스 스캔
### Range Scan
* 스캔해야할 인덱스 범위가 정해졌을 경우 수행
* WHERE 조건절에서 인덱스 키 칼럼에 대해 범위 연산자가 사용된 경우
```sql
SELECT user_id FROM user_info WHERE user_no BETWEEN 0 AND 10
```
![image](https://user-images.githubusercontent.com/48702893/110203311-d3f00b00-7eb0-11eb-8d85-434a57420e70.png)


* 인덱스 range scan을 통해 스캔해야되는 레코드 수가 전체 테이블의 25% 이상일경우, 인덱스를 상요하지 않고 table range scan 으로 동작
	
```sql
SELECT user_id FROM user_info WHERE user_no > 0
```
![image](https://user-images.githubusercontent.com/48702893/110203297-c63a8580-7eb0-11eb-98d3-3174e6e38b62.png)

> cf) 인덱스를 사용하지 않는 쿼리의 range scan 쿼리 플랜
> ```sql
>	SELECT user_id FROM user_info WHERE update_ymdt > '2020-02-01'
> ```
> ![image](https://user-images.githubusercontent.com/48702893/110203261-968b7d80-7eb0-11eb-9ddb-7d7cd29d2697.png)

* 인덱스를 통해 범위 시작값에 해당하는 리프노드 탐색 후, 범위 끝값에 도달할때까지 리프노드 순차 스캔 

![image](https://user-images.githubusercontent.com/48702893/110125673-edd51380-7e06-11eb-8696-132c305ad335.png)

### Full Scan[[참고]](http://wiki.gurubee.net/display/CORE/Index+Full+Scan)
* 전체 인덱스의 키를 정렬하여 Scan (별도의 정렬 과정 필요없이 전체 리프노드만 순차적으로 Scan 함)
* 커버링 인덱스 쿼리 이면서 전체 인덱스 리프노드를 정렬해서 스캔해야하는 쿼리일 경우 수행
	* 주로 키 칼럼에 ORDER BY 나 MIN/MAX 함수가 적용되어있을경우 Full Scan 으로 동작
	```sql
	SELECT user_no FROM user_info ORDER BY user_no
	```
	
	![image](https://user-images.githubusercontent.com/48702893/110203956-0b13eb80-7eb4-11eb-9a1d-3ecc82398922.png)
	
	* MIN/MAX 집단함수 쿼리의 경우 index full scan 으로 표시되긴 하지만, full scan 없이 첫번째, 마지막 리프노드만 조회
	```sql
	SELECT MAX(user_no) FROM user_info
	```
	
	* MIN, MAX 함수 함께 사용시 진짜로 리프노드 전체 Scan 수행하여 부하가 커짐
	```sql
    	SELECT MAX(user_no), MIN(user_no) FROM user_info
	```
	> but 실제 테스트 시 시간차이가 거의 크지 않았음 (MIN select : 0.004s, MIN, MAX select : 0.005s)
	* MIN, MAX 값 따로 조회하여 UNION_ALL 로 조인하는것이 더 효율적
	```sql
       SELECT MAX(user_no) FROM user_info UNION ALL SELECT MIN(user_no) FROM user_info;
	```
	
> * 책에는 MIN, MAX 가 index full scan 으로 수행된다고 되어있는데 실제 쿼리 플랜 확인시 'select tables optimized away' 로 출력 (MIN, MAX Select 시에도 동일) 
> ![image](https://user-images.githubusercontent.com/48702893/110204084-85dd0680-7eb4-11eb-8e14-13c2228efdc1.png) 
> * 인덱스를 사용하는 집계함수나 COUNT 함수만 사용하고 GROUP BY 절이 없어 Optimizer 가 하나의 행만을 리턴할때 보여주는 문구
> * 즉 가장 최적화가 잘된 쿼리 라는 의미..? 로 간주되는것같음

* 인덱스 키 칼럼이 NOT NULL 제약조건이 아닐경우 Table Full Scan 으로 수행됨
	* 인덱스 Full Scan시 키값이 NULL 인 레코드들은 Scan 되지 않음(키값이 NULL 인 레코드들은 인덱싱 되지 않으므로)

#### 커버링 인덱스 쿼리
* 테이블에 접근할 필요 없이 인덱스 데이터 만으로 처리가 가능한 쿼리
```sql
SELECT user_no FROM user_info
```
![image](https://user-images.githubusercontent.com/48702893/110204354-e6207800-7eb5-11eb-85fb-71f89b58fe1f.png)

* 인덱스 데이터가 일반적으로 테이블 데이터보다 훨씬 작아 레코드 읽기 속도가 더 빠름
* 인덱스에서만 처리시, 테이블 조회를 위한 디스크 랜덤 I/O 가 수행되지 않으므로 더 효율적
* 쿼리의 인덱스 키 칼럼이 아닌 칼럼이 포함되어 있는경우, 테이블 랜덤 I/O 발생
	* 인덱스 Full Scan 으로 처리되던 쿼리에 일반 칼럼 select/조건 추가시 table full scan 으로 동작(전체 테이블 레코드의 25 % 이상 조회시 Optimizer 가 Full scan 강제)
	```sql
	SELECT user_no FROM user_info > SELECT user_no, user_id FROM user_info
	```
> 커버링 인덱스 쿼리의 Range Scan 쿼리 플랜
> ![image](https://user-images.githubusercontent.com/48702893/110203742-27fbef00-7eb3-11eb-8fdc-8302e5acbbdd.png)

### Fast Full Scan[[참고]](http://wiki.gurubee.net/display/CORE/Index+Fase+Full+Scan?decorator=printable)
* 전체 인덱스의 키 Scan
* Full Scan 과 달리 정렬하여 Scan 하지 않으므로 Scan 속도가 더 빠름 
	* Full Scan 은 Single Block I/O 인데 반해 Fast Full Scan 은 Multi Block I/O 로 동작
	* Full Scan 은 Single Scan 만 가능한데 반해, Fast Full Scan 은 Parallel Scan 가능
#### Single Block I/O - Multi Block I/O [[참고]](http://wiki.gurubee.net/display/STUDY/03.+Single+Block+vs+Multiblock+IO) 
* Single Block I/O : 한번의 랜덤 I/O 수행에 하나의 데이터 블록만 읽어 메모리에 적재
* Multi Block I/O : 한번의 랜덤 I/O 수행에 인접한 데이터 블록들까지 함께 읽어 메모리에 적재
* 인덱스의 리프노드들은 연속된 디스크블록에 저장되는것이 아닌, 제각각의 블록에 저장
* 인덱스 Full Scan 이 Single I/O 로 동작하는 이유
	* 링크드 리스트로 인덱스 리프 노드 관리하여 마치 연속된 디스크 공간에 저장되어있는것 처럼 관리
	* 인덱스 Full Scan 은 리프노드들을 순차적으로 Scan 해야 하므로 Multi Block I/O 로 인접 블록들까지 읽어와도 사용하지 못함
	* 인덱싀 Fast Full SCan 은 리프노드들을 읽기만 하면 되므로 Multi Block I/O 로 동작 
