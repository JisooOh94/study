# 파티션
* 하나의 테이블을 여러 테이블로 분리해서 저장하는것
* 동일한 서버장비에서 테이블 파일만 분리하는것이기때문에, 여러 장비에 걸친 부하 분산 개념 X

### 파티션 장점
* 인덱스 테이블 크기 축소를 통한 데이터 DML 작업의 효율성 증대
	* 테이블이 너무 클경우, 인덱스 테이블또한 커지게되고, 그로인해 데이터 생성,수정,삭제 뿐만 아니라 인덱스를 통한 조회작업의 효율성도 떨어지게됨
	* 테이블이 너무 커져, 인덱스 테이블의 크기가 MySql 이 가용한 메모리 크기보다 커질경우, DML 작업이 매우 느려짐
* 주기적으로 특정 그룹의 데이터를 삭제해야하는 작업에 특화
	* 테이블의 reg_ymdt 칼럼값으로 레인지 파티셔닝시, DELETE 쿼리 수행 없이 파티션 drop 을 통해 간단하게 특정 reg_ymdt 인 레코드 삭제 가능
* 파티션 프루닝을 통해 조회 작업의 효율성 증대
	* 옵티마이저가 쿼리 최적화 하며, 조회할 필요가 없는 파티션을 필터링하여 총 scan 해야하는 인덱스/레코드 가 줄어듬

<br>

# 파티션 테이블 CRUD
### CREATE
* 명령어 : PARTITION BY 파티션종류 (기준칼럼) ...
```
-- 레인지 파티션
CREATE TABLE emp_info (...)
PARTITION BY RANGE (YEAR(emp_age)) (
	PARTITION p_1 VALUES LESS THAN (20),
	PARTITION p_2 VALUES LESS THAN (30),
	PARTITION p_3 VALUES LESS THAN (40),
	PARTITION p_4 VALUES LESS THAN (60)
)
```

### INSERT
* 추가하는 레코드의 파티션 키 칼럼값으로 파티션 선택 후, 해당 테이블에 삽입

### UPDATE
* WHERE 조건에 파티션 키 칼럼 조건 존재
	& 해당 조건으로 파티션 선택 후, 해당 파티션 테이블에서 레코드 찾아 update
* WHERE 조건에 파티션 키 칼럼 조건 없음
	* 전체 파티션 테이블에서 레코드 찾아 update
* 파티션 키 칼럼 값 수정
	* 수정할 레코드의 파티션에서 레코드 삭제 후, 수정되는 키 칼럼값으로 파티션 다시 선택하여 수정 레코드 삽입
* 일반 칼럼 값 수정
	* 그냥 수정
	
### SELECT
* WHERE 조건에 파티션 키 칼럼 조건 존재
	* 해당 조건으로 파티션 선택 후, SELECT 쿼리 수행
* WHERE 조건에 파티션 키 칼럼 조건 없음
	* 전체 파티션 테이블에 대해서 SELECT 수행

### 인덱스
* 파티션 테이블에 생성되는 인덱스는 모두 로컬 인덱스
	* 전체 파티션간 정렬이된 글로벌 인덱스 지원하지 않음
* 따라서 여러 파티션에 걸쳐 인덱스 스캔시, 스캔 결과의 정렬이 보장되지 않음
	* MySql 에선 우선순위큐를 이용해 스캔 결과의 정렬 보장

<br>

# 주의사항
* 파티션 키 칼럼은 INTEGER 타입(또는 INTEGER 타입을 반환하는 함수) 만 설정 가능
	> MySql 5.5 부터 문자열/날짜 타입도 설정 가능
* 파티션 키 칼럼으로 함수 사용시, YEAR(), TO_DAYS(), TO_SECONDS() 만 파티션 프루닝 사용 가능
* 유니크 칼럼이 있는 테이블 파티셔닝시, 파티션간 유니크 칼럼의 중복 레코드가 존재하지 않도록 파티션 키 설정 필요
	> 유니크 칼럼의 중복 레코드 체크는 동일 파티션 테이블내에서만 가능
```sql
CREATE TABLE emp_info (
  emp_no, emp_name, emp_age
  UNIQUE KEY(emp_no, emp_name)
) PARTITION BY HASH(emp_age)
-- emp_age만 다르고, emp_no, emp_name 이 동일한 레코드가 서로 다른 파티션에 존재 가능

CREATE TABLE emp_info (
  emp_no, emp_name, emp_age
  UNIQUE KEY(emp_no),
  UNIQUE KEY(emp_name)
) PARTITION BY HASH(emp_no + emp_name)
-- emp_no 만 다르고 emp_name 은 동일한 레코드가 서로 다른 파티션에 존재 가능

CREATE TABLE emp_info (
  emp_no, emp_name, emp_age
  PRIMARY KEY (emp_no)
  UNIQUE KEY(emp_name, emp_age)
) PARTITION BY HASH(emp_no + emp_name)
-- emp_name 만 다르고 emp_no 는 동일한 레코드가 서로 다른 파티션에 존재 가능
``` 

* 파티션된 테이블에 데이터 수정 쿼리 수행시, WHERE 절 조건에 파티션키가 있는지 없는지에 따라 성능이 많이 달라짐
  * 파티션 키 값 조건이 있는경우 : 해당하는 파티션 테이블만 잠금 수행 (정확히 말하자면, innoDB 의 경우 레코드 단위 잠금을 지원하므로 해당하는 파티션 테이블의 레코드만 잠금)
  * 파티션 키 값 조건이 없는경우 : 전체 파티션이 scan 되며, 전체 파티션의 수정 대상 레코드에 잠금 수행
	
<br>

# 파티션 테이블 쿼리 플랜
* 쿼리를 수행하는 테이블이 파티셔닝된 테이블일 경우, 파티션 프루닝을 통해 읽어야하는 파티션이 얼마나 줄어드는지가 성능에 매우 큰 영향
* EXPLAIN PARTITIONS 명령어를 통해 쿼리 수행시 조회할 파티션 정보 확인 가능
	> 기존 쿼리 플랜 항목들에 partitions 항목 추가, 조회될 파티션 리스트 출력

<br>

# 파티션 성능
### 조회쿼리
* 글로벌 인덱스를 사용할 수 없는 쿼리이면서 파티션 프루닝을 사용할 수 있는 쿼리인경우 성능 향상

### 수정쿼리
* 약 30% 정도의 성능 향상 효과가 있으나, ~수정 쿼리 수행시, 전체 파티션에 잠금을 거는 이슈로 인해 파티션 개수가 많아지면 오히려 성능 떨어짐~

### 결론
* 다음의 경우엔 파티셔닝을 권장하나 그 외엔 정밀한 성능 비교 필요 
	* 날짜 칼럼을 이용해 주기적으로 특정 날짜범위의 대량의 데이터 수정 작업을 수행할 일이 있음(e.g. 오래된 로그성 데이터 삭제)
	* 쓰기 쿼리가 빈번히 수행되는 테이블의 테이블크기가 커, 쿼리 성능이 떨어질 경우
