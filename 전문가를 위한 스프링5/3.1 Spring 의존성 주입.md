# 의존성 주입 컨테이너
* Bean 객체 생성 및 등록, 관리, 각 Bean 객체간의 의존관계 설정등의 기능을 수행하는 컨테이너, 즉 의존성 주입을 수행하는 주체
* Spring에서 DI 컨테이너 인터페이스 인 BeanFactory 인터페이스를 구현한 여러 구현체 제공 (ApplicationContext, DefaultListableBeanFactory 등)

### BeanFactory
* ApplicationContext
   * Bean pre-loading (ApplicationContext 객체가 생성될때 등록정보에 명시되어있는 모든 bean 생성 및 등록 수행)
   * BeanFactory 초기화작업(DI 컨테이너 객체 생성및 bean 등록, 의존성 주입) 을 Spring에 위임하여 자동으로 수행됨(web.xml의 ContextLoaderLister가 수행)
   * 특수한 경우가 아니라면 코드가 더 간결해지고 버그 위험성도 적은 ApplicationContext 구현체를 사용하는것이 권장됨
* 그외의 BeanFacotry 구현체
   * Bean lazy-loading (구현체 객체 생성 후, 런타임에서 bean 객체가 호출될때 bean 생성 및 등록 수행)
   * 코드로 직접 BeanFactory 초기화 작업 수행 필요
      * Bean 등록정보가 있는 설정파일이나 클래스를 BeanDefinitionReader 를 통해 읽어 BeanFactory 객체 생성시 명시해주어야 함
      * 등록정보 형태에 따라 사용되는 BeanDefinitionReader 가 다름(properties 파일 : PropertiesBeanDefinitionReader, xml 파일 : XmlBeanDefinitionReader 등)
      * 생성후, getBean(beanName) api 를 통해 의존성 생성
      > cf) 내가 보기엔 의존성 룩업처럼 보인다.
   * DefaultListableBeanFactory 등...

```java
public static void main(Stringp[] args) {
	DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	
	XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);
	beanDefinitionReader.loadBeanDefinitions(new ClassPathSource("path/to/bean/file.xml"));
	
	Foo foo = beanFactory.getBean("foo");	//의존성 룩업 아닌감...
}

//beanDefinitionFile.xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context">
	<bean id="foo" class="com.naver.drive.Foo"/>
</beans>
```

<br>

# Spring 빈 등록 방식
### 직접 등록
* xml 파일에 등록 : <bean> 태그를 통해 xml 파일에 직접 등록
```java
//applicationContext.xml
<beans>
	<bean id = "foo" class = "com.naver.Foo"/>
</beans>
```

* Java class에 등록 : @Bean 어노테이션을 bean 객체 getter 메서드에 추가하여 직접 등록
```java
//ApllcationContext.class
@Configuration
public class Foo {
	@Bean
    public Foo foo {
    	return new Foo();
    }
}
```

### 어노테이션을 통한 자동 등록
* xml 파일에 등록
   * Bean 클래스에 스테레오 타입 어노테이션 추가
      * 스테레오타입 : 빈 등록 어노테이션 클래스들이 정의되어있는 패키지(org.springframework.stereotype)
      * 패키지명을 따서 빈 등록 어노테이션들을 스테레오타입 어노테이션이라 통칭
      * 등록할 빈의 기능에 따라 여러 스트레오타입 어노테이션 존재(e.g. @Service : BO 클래스, @Repository : Dao 클래스)
      * 등록할 빈의 이름을 파라미터로 전달 가능(default : 클래스명 카멜표현식)
		```java
		@Service("UserDefineFoo")		//bean 이름 : UserDefineFoo
		public class Foo {}

		@Service		//bean 이름 : foo
		public class Foo {}
		```
   * xml 파일에 <context:component-scan> 태그 추가하여 Bean 등록할 클래스 패키지 경로 명시
      * <context:component-scan> 에 base-package 값으로 명시한 패키지 하위에 있는 스테레오타입 어노테이션이 추가되어있는 모든 클래스가 bean 으로 등록
      ```java
         <context:component-scan base-package="com.naver.foo" />
      ```
      
      * ',' 를 구분자로 여러개의 패키지 명시 가능
      ```java
         <context:component-scan base-package="com.naver.foo, com.naver.bar" />
      ```      
      
      * exclude-filter, include-filter 파라미터를 통해 base-package 로 명시한 패키지 하위의 클래스들중 bean 등록할/제외할 클래스 컨트롤 가능
      ```java
         <context:component-scan base-package="com.naver.foo">
            //foo 패키지 하위 클래스들중 @Controller 어노테이션이 추가된 클래스는 제외하고 bean 등록 
            <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller">
            //foo 패키지 하위 클래스들중 이름이 ~NaverController 로 끝나는 클래스들은 bean 으로 등록(@Controller 어노테이션이 추가되어있어도) 
            <context:include-filter type="regex" expression="^.*NaverController$">
         </context:component-scan>
      ```
      
* Java class에 등록
	* getter 메서드 정의 후 추가하던 @Bean 어노테이션 대신, 클래스에 @ComponentScan 어노테이션만 추가하여 Bean 등록할 클래스 패키지 경로 명시
	```java
	@ComponentScan(basePackages = {"com.naver.foo"})
	@Configuration
	public class BeanConfiguration {//클래스 내용 불필요}
	```
	* 패키지 경로 명시시, basePackages 를 통한 명시보다 basePackageClass 를 통한 명시가 더 안전
		* basePackages 를 통한 명시의 경우, 패키지경로를 하드코딩으로 명시하는것이므로 실수의 우러가 있고 컴파일러에서 실수를 잡아줄수 없음.
		* basePackageClass 는 명시한 클래스가 위치한 패키지를 경로로 사용하는것이기때문에 컴파일러가 검증 가능
	```java
	@ComponentScan(basePackagesClass = Foo.class)
	@Configuration
	public class BeanConfiguration {}
	```
	* @ImportResource 어노테이션을 통해 xml에 정의되어있는 bean 등록 정보를 가져와 Java class 방식을 통해 bean 등록 가능
	```java
	@ImportResource(locations = {"classpath:resources/applicationContext.xml"})
	@Configuration
	public class BeanConfiguration {}
	```
	
# Spring 의존성 주입 방식
### 수정자 주입

### 생성자 주입

### 필드 주입

### 필드 주입의 단점

### 생성자 주입의 단점

### 수정자 주입을 사용해야하는 이유
   