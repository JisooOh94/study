# ZGC: A Scalable Low-Latency Garbage Collector [[ref]](http://cr.openjdk.java.net/~pliden/slides/ZGC-FOSDEM-2018.pdf) [[ref]](https://johngrib.github.io/wiki/java-gc-zgc/) [[JEP 377]](https://openjdk.java.net/jeps/377)
* 대용량 힙에 대한 GC 를 수행하면서 STW 시간을 최소화 하기 위한 차세대 GC
    * 최근 장비의 메모리 크기가 크게 증가하면서, 그만큼 가용한 Heap 크기도 늘어났고, 그에따라 큰 규모의 Heap 에 대해 고성능을 보장하는 GC 수요 증가
* G1GC 와 동일한 처리량을 보장하면서 STW 시간을 더욱 단축
    * marking 과정에서만 STW 로 처리, evacuation 은 concurrent로 수행
* STW 시간이 heap 크기, 또는 live 객체 크기에 상관없이 항상 균일

![image](https://user-images.githubusercontent.com/48702893/159253489-01410632-569d-4274-9f5e-bd590222821b.png)

![image](https://user-images.githubusercontent.com/48702893/159253521-cf0dfad8-a7d8-45ac-ac46-dbe4bfb4a484.png)


ZGC는 10ms 미만의 짧은 대기 시간이 필요하거나 테라 바이트 큐모의 매우 큰 heap을 사용하는 애플리케이션을 위한 GC이다.

ZGC는 모든 비싼 작업들을 concurrently하게 수행하는데, 그러면서도 애플리케이션 스레드들이 약간의 millisecond 이상 멈추지 않도록 합니다.
따라서 ZGC는 low latency를 요구하는 애플리케이션에 적합합니다.
정지 시간은 사용되고 있는 heap의 크기와 무관합니다.

ZGC의 특징
대기 시간이 낮으면서 규모 확장이 가능한 GC이다.

GC에 관련된 모든 작업을 Application과 동시에 작업한다. (Concurrently)
CMS나 G1의 경우 Mark 작업의 일부를 Application과 Concurrently 하게 수행한다.
Application이 수행되는 동안 GC Thread를 여러 개 동작시킬 수 있다.
동시 수행 Thread가 적은 경우에는 Garbage가 점점 누적되며 (메모리 누수), Thread가 많은 경우에는 Application의 CPU 수행 시간을 많이 소모함으로 요청 처리량을 떨어트린다.

ZGC의 주요 원리는 Load barrier와 Colored Pointer를 함께 사용하는 것이다.
이를 통해 Thread가 동작하는 중간에도 ZGC가 객체 재배치 같은 작업을 수행할 수 있다.


ZGC는 메모리를 ZPages라고 불리는 영역으로 나눈다. ZPages는 동적 사이즈(G1 GC와 다름)로 2MB의 배수가 동적으로 생성 및 삭제될 수 있다.



Setting the Heap Size
The most important tuning option for ZGC is setting the max heap size (-Xmx). Since ZGC is a concurrent collector a max heap size must be selected such that, 1) the heap can accommodate the live-set of your application, and 2) there is enough headroom in the heap to allow allocations to be serviced while the GC is running. How much headroom is needed very much depends on the allocation rate and the live-set size of the application. In general, the more memory you give to ZGC the better. But at the same time, wasting memory is undesirable, so it’s all about finding a balance between memory usage and how often the GC needs to run.

Setting Number of Concurrent GC Threads
The second tuning option one might want to look at is setting the number of concurrent GC threads (-XX:ConcGCThreads). ZGC has heuristics to automatically select this number. This heuristic usually works well but depending on the characteristics of the application this might need to be adjusted. This option essentially dictates how much CPU-time the GC should be given. Give it too much and the GC will steal too much CPU-time from the application. Give it too little, and the application might allocate garbage faster than the GC can collect it.

released! : https://openjdk.org/jeps/377

### ZPage

### Colored Pointers

### Load barriers

# Shenandoah: A Low-Pause-Time Garbage Collector [[ref]](https://velog.io/@recordsbeat/Low-Pause-Shenandoah-GC) [[ref]](https://wiki.openjdk.java.net/display/shenandoah/) [[JEP 379]](https://openjdk.java.net/jeps/379)
* ZGC 와 함께 차세대 GC 로서, ZGC 와 마찬가지로 STW 시간을 최소화 하기위한 GC
* 기존 GC 알고리즘들의 근간이었던 약한세대가설을 부정하고 단일 세대로만 동작함으로서 generational copy 비용 제거
    * generational copy : 세대 가설에 따라, 객체들을 나이에 해당하는 힙 공간으로 이주시키는 작업
  > "GC에 익숙한 사람이라면 모두 Generational GC가 최고라고 이야기합니다. 'generational hypothesis 는 대부분 상황에서 Young Object는 Old Object 보다 죽을 가능성이 클 것으로 내다본다.' 2008년에는 맞는 말이었죠. 하지만 지금은 설득력이 떨어집니다."
  Red Hat 개발자 Christine Flood - DevNation 2016 中
* G1GC 의 단점이었던 Compaction 과정의 오버헤드를 Concurrent Compaction 으로 감축
* 이를 통해 STW 시간을 최소화하면서, heap 크기에 상관없이 항상 균일한 성능 보장

![image](https://user-images.githubusercontent.com/48702893/159258729-0cfcaae6-6715-4d3b-946f-2fed0d7d368b.png)

![image](https://user-images.githubusercontent.com/48702893/159258166-e4052e2e-00b1-4f43-819f-33d2406c9731.png)

