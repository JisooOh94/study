# 확장성
* 특정 컴포넌트의 처리량을 넘어서는 요청이 몰릴때, 시도할 수 있는 대책으로 Scale-up(수직적 규모확장) 과 Scale-out(수평적 규모확장)이 있음
* Scale-up 은 확장할 수 있는 한계가 존재(한대의 서버에 CPU 나 메모리를 무한대로 증설할 순 없음)하고, 가용성 측면에서도 좋지 않다.
* 따라서 Scale-out 을 통한 확장이 일반적으로 더 나음


# 다중화
* master - master 또는 master - slave, leader-replication 구성을 통한 부하분산 및 고가용성 보장


# 데이터베이스
### 다중화
* master - slave 구조를 통한 부하분산 및 고가용성 보장
  * 쓰기작업 - master, 읽기작업 - slave
  * master 에 장애 발생시, slave 중 한대를 master 로 승격시킬 수도 있음
    * 다만, slave 가 in-sync 상태가 아닐수도 있으니, 복구 스크립트등(리두 로그?)을 통한 데이터 동기화 필요
    * 혹은 다중 마스터/원형 다중화 기법도 존재하나 master 간 데이터 동기화가 복잡하여 잘 사용되지 않음
* master - master 구조를 통한 부하분산 및 고가용성 보장
  * load balancer 를 이용해 n개의 master 로 요청 분배
  * master 한대에 장애 발생시, 자동으로 나머지 master 로 요청 할당
* leader - replication 구조를 통한 고가용성 보장
  * leader 에 장애 발생시, in-sync replication 중 한대를 leader 로 승격

### 확장성
* 샤딩을 통한 Scale-out
* 데이터를 각 샤드에 고르게 분포시킬 수 있는 샤드키 선택이 중요
    * 특정 샤드에 요청이 몰리는 hotspot key 문제 발생 가능
* 샤드키에 따른 샤드 선택 로직 구현시, Consistent hashing 기법을 통해 샤드의 Scalability 보장
* 샤드간 테이블 join 은 불가능. 따라서 역정규화를 통해 join 필요성 해소

### NoSql
* 다음과 같은 이유로 관계형 데이터베이스보다 처리속도가 더 빠르고 확장에도 더 용이
  1. 스키마 없는 구조: 고정된 데이터 스키마가 없기때문에, 데이터를 추가하거나 수정할 때 복잡한 스키마 마이그레이션 또는 조정이 필요 없음. 데이터 구조 변경이 간단하고 빠르기 때문에, 개발 속도와 데이터 처리 속도가 빠름
  2. 단순한 쿼리 모델: 관계형 데이터베이스 처럼 복잡한 JOIN 연산이 필요 없이 key-value 형태로 저장되기떄문에, 쿼리 수행 시간이 단축되어 빠른 응답 속도 제공
  3. 수평적 확장성: 수평적 확장에 용이, 그에 따라 분산 데이터 처리도 용이

* 다음의 경우에 RDB 대신 NoSql 도입 검토
  1. DB 에 저장하고자 하는 데이터가 비정형 데이터인경우
     * 비정형 데이터 : 미리 정의된 데이터 모델이나 스키마가 없이 자유 형식으로 존재하는 데이터(e.g 텍스트 데이터(메일, SNS 게시물 등), 미디어 데이터(이미지, 오디오 등), 로그 데이터, 센서 데이터 등)
  2. 아주 낮은 latency 가 요구되는 경우
  3. 아주 많은 양의 데이터를 저장해야할 경우

* NoSql 도입하기에 좋은 예시는 다음과 같다
  1. 실시간 분석 및 모니터링 시스템(실시간 트래픽 모니터링 시스템)
     * 대량의 실시간 트래픽 데이터를 수집하고 분석해야 할 때, 빠른 읽기 및 쓰기 성능을 제공하는 NoSql 사용
  2. 대규모 웹 애플리케이션(소셜 미디어 플랫폼)
     * 소셜 미디어와 같은 대규모 웹 애플리케션은 막대한 양의 사용자 데이터를 NRT 로 처리해야함. 분산 데이터 처리 및 병렬 처리하기에 용이한 NoSql 사용
  3. 유연한 스키마가 필요한 애플리케이션(전자 상거래 플랫폼)
     * 전자 상거래 플랫폼에서는 상품 정보, 사용자 리뷰, 거래 데이터 등 다양한 유형의 데이터가 지속적으로 변화하고 추가됨. 스키마가 없이 비정형 데이터를 저장할 수 있는 NoSql 사용
  4. 분산 데이터 저장이 중요한 애플리케이션 (CDN)
     * CDN 은 전세계 여러 위치 서버에 데이터를 분산 저장 필요. 데이터를 여러 서버에 분산하여 저장하기에 용이한 NoSql 사용

* 자세한 Use-case 는 [Real-World NoSQL Database Use Cases: Examples and Use Cases for Developers](https://www.datastax.com/guides/nosql-use-cases) 참조


# 캐시
* 어플리케이션의 성능은 DB IO 호출 횟수에 따라 크게 바뀜. 캐싱을 통해 DB IO 를 많이 줄일 수 있음
    * 캐시는 메모리에 데이터 저장 및 key 값을 통한 데이터 조회, 어플리케이션과 같은 로컬 네트워크 혹은 동일한 서버에 위치하므로 DB 보다 속도가 빠름
* 일반적으로, 수정은 잘 일어나지 않으면서 조회는 많은 데이터에 적합

### Consistency
* 캐시 적용시, 원본 데이터와의 일관성(consistency)을 보장하는것이 중요
  * 원본 데이터 수정시, 캐싱되어있는 데이터에도 수정이 적용되거나 혹은 만료시켜 원본 데이터를 다시 조회해가 캐싱해야한다.
* FaceBook 'Scaling Memcache at Facebook' 논문의 캐시 일관성 유지 전략 참조

### Eviction
* 캐시 메모리 크기 설정 및 캐시 메모리 포화시 eviction 정책도 고려 필요
* 캐시 메모리가 너무 작을경우, 갑자기 요청이 몰렸을때 hit 될법한 데이터가 만료되버리는 상황 발생
* evition 정책엔 일반적으로 LRU, LFU 등이 존재

### 분산 캐시
* 캐시 서버가 단일 장애 지점(Single Point of Failure)이 되는것을 방지하기 위해 일반적으로 여러개의 캐시서버를 묶은 분산 캐시 형태로 운영
* 분산 캐시 적용시, 캐시 노드간 데이터 동기화 정책이나 고정 캐시 노드 선택 로직등(e.g. Consistent hashing)이 필요

### 캐시 전략
* Cache-Aside
  * 애플리케이션이 데이터 요청시 캐시 조회. 캐시에 데이터가 없는 경우(캐시 미스), Origin 으로부터 데이터 가져와 캐시에 저장한 후 클라이언트에 응답. 원본 데이터 수정시, 캐싱되어있는 데이터 expire
  * 웹 서비스에서 사용자 프로필 정보처럼 자주 변경되지 않지만 자주 조회되는 데이터 캐싱할때 적합. 사용자가 로그인할 때마다 프로필 정보를 데이터베이스에서 가져와 캐시에 저장하고, 이후의 요청은 캐시에서 빠르게 처리
* Write-Through
  * 데이터가 캐시에 쓰여질 때 동시에 데이터베이스에도 쓰여짐. 데이터의 일관성을 유지하는 데 유리하지만 쓰기 연산의 지연 시간이 증가
  * 금융 거래 시스템과 같이 데이터 일관성과 신뢰성이 매우 중요한 애플리케이션에 적합. 모든 트랜잭션이 즉시 데이터베이스에 반영되어야 하며, 동시에 캐시도 최신 상태로 유지되어야 할때 적용
* Write-Behind
  * 데이터가 먼저 캐시에 쓰여지고, 비동기적으로 일정 시간 후에 데이터베이스에 반영. 쓰기 연산의 성능을 향상시킬 수 있지만, 시스템 장애 시 데이터 손실의 위험 존재
  * 소셜 미디어 플랫폼에서 사용자의 상태 업데이트나 댓글과 같이 높은 쓰기 요청을 처리해야 하지만, 즉각적인 데이터베이스 반영이 필수적이지 않은 경우에 적합. 사용자 경험을 개선하기 위해 쓰기 응답 시간을 최소화할 때 적용
* Read-Through
  * Cache-Aside 전략과 유사하나 캐시 미스 발생시, 캐시 자체가 Origin 으로부터 데이터를 가져와 캐싱 후 요청한 클라이언트에게 데이터 응답. 이후 같은 데이터에 대한 요청은 캐시에서 처리
  * 온라인 상점의 제품 정보 페이지와 같이 데이터가 자주 업데이트되지 않고, 데이터베이스 부하를 줄이면서 읽기 성능을 향상시키고 싶은 경우에 적합. 제품 정보가 요청될 때 한 번만 데이터베이스에서 읽어오고, 이후 요청은 캐시에서 처리하여 빠른 응답 속도를 제공


# CDN
* 정적 컨텐츠를 서빙하는 지리적으로 분산된 서버
* 라스트 마일 지연 절약, 더 넓은 네트워크 대역폭 할당등으로 빠른 컨텐츠 서빙 가능
* 캐싱된 컨텐츠의 TTL 전략, CDN 장애시 failover 전략 등 고려 필요


# stateless 웹서버
* 요청처리를 위해 어플리케이션이 들고있던 상태정보(e.g. 사용자 세션정보)를 공유 저장소(e.g. session storage)로 옮겨 statless 한 상태를 만듦으로서 어플리케이션의 scailabilty 보장
* 요청 인입시, 요청 처리에 필요한 상태정보를 공유 저장소로부터 조회하여 처리
    * 공유 저장소로 많은 부하가 몰릴 수 있으므로 공유 저장소 설계 중요 (일반적으로 Redis cluster 사용)


# 메시지큐
* 처리에 오래 걸리는 작업을 비동기적으로 수행할때 메시지큐 사용


# 데이터센터
* 글로벌 서비스의 경우, 지역별 사용자의 거리에 따른 지연을 최소화 하기 위해 여러 지역의 데이터센터에 어플리케이션 배포하여 운영
    * 사용자가 어플리케이션으로 요청을 전송하기 위해 DNS 에 IP adrress 질의시, DNS 는 사용자의 지역에 가장 가까운 데이터 센터의 IP address 로 resolving (geo-routing)
* 다중화된 데이터센터 운영시, 단순히 거리에 따른 지연 최소화 뿐만 아니라 특정 데이터센터에 장애가 발생했을떄 failover 로도 활용 가능
    * 이떄, 데이터센터간 데이터 동기화가 중요.
    * [Netflix Active-Active for Multi-Regional Resiliency](https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b) 참고


# 설계시 고려
1. 어플리케이션은 stateless 하게 설계
2. 모든 컴포넌트를 다중화 하여 설계
3. 가능한 한 많은 데이터를 캐싱하여 캐시 사용 극대화
4. 정적 컨텐츠는 CDN 을 통해 서빙
5. 데이터베이스는 샤딩을 적용하여 Scailabilty 보장
6. 응답데이터가 클때는 압축하여 응답
7. 처리하는 데이터 또는 서비스 특성을 고려하여 구조 설계
