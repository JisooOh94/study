# 유일 ID 생성기
## 1. 요구사항 파악
* 다음의 질문들이 가능하다.
    * ID 는 어떤 종류의 값만 가능한지 (숫자, 특수문자, 영어 등)
    * ID 생성 시간에 따라 정렬이 가능해야하는지
    * ID 생성 요청 평균 TPS 가 어느정도 일지
    * ID 의 크기는 몇바이트인지
    * 분산 환경에서의 ID 생성 요청 처리가 가능해야하는지

## 2. 개략적인 설계
* 가능한 방법은 다음의 것들이 있다.

### 1. 다중 마스터 복제
* 데이터베이스의 auto_increment 기능을 이용하여 데이터베이스에 유일 ID 조회하여 생성
* n 개의 데이터베이스로 구성된 데이터베이스 클러스터를 통해서도 생성 가능
  * 클러스터내 각각의 데이터베이스에 index 를 부과하고, 각 데이터베이스는 auto increment 단위를 클러스터내 데이터베이스 개수로 설정
  * 이를 통해, 각 데이터베이스에서 생성하는 ID 의 유일성은 보장
    * 클러스터내 데이터베이스가 5개 라고 가정했을떄, DB#1 이 생성하는 id 는 1, 6(1+5), 11(1+5+5)... 이고, DB#2 가 생성하는 id 는 2, 7, 12 이다.
  * 그러나, 생성 시간에 따른 정렬은 불가능하다.
    * Client1 이 00:01 초에 전송한 id 생성요청이 DB#2 로 가고, Client2 가 00:02 초에 전송한 요청이 DB#1 으로 가면 Client2 의 유일 id 가 Client1 의 유일 id 값보다 작음
  * 더불어, 운영중에 새로운 데이터베이스를 추가하거나 삭제했을때 동기화 처리도 복잡해진다.

### 2. UUID
* 중복될 일이 없으므로, 각 서버에서 개별적으로 UUID 생성하여 사용
  * 공유 storage 와의 통신도 필요없으므로 성능이 매우 뛰어남
* 그러나 ID 생성 시간에 따른 정렬 불가능

### 3. 티켓 서버
* 1번과 비슷하나, 단일 데이터베이스만 사용하는 방식
* 수평 확장도 불가능하고, 데이터베이스가 SPOF 가 되어 위험함

### 4. Snowflake Id
* 트위터에서 사용하는 유일 ID 생성 기법으로, ID 를 유일하게 식별할 수 있는 여러가지 정보를 조합하여 생성하는 방식
* 다음의 정보들이 id 에 포함된다.
  * 타임스탬프
    * 유일 id가 생성된 시간, ms 단위까지 표현
    * 이를 통해 id 생성 시간에 따라 정렬이 가능
  * 데이터센터 ID
    * 타임스탬프는 ms 단위까지만 표현하기때문에, 운에 따라서 2개이상의 인스턴스에 동일한 ID 가 생성될 수 있음
    * 이같은 중복을 방지하기 위해 아래의 서버 ID 를 ID 에 포함시켰으나, 데이터센터간 동일한 서버 ID 를 가진 서버가 존재 가능함
    * 따라서, 위와같은 중복을 방지하고자 데이터센터 ID 도 ID 에 포함
  * 서버 ID
    * 타임스탬프 중복으로 인한 ID 중복을 방지하기 위한 구별값
  * 일련번호
    * 마찬가지로, 타임스탬프 중복으로 인한 ID 중복을 방지하기 위한 구별값
    * 하나의 장비로, 동일한 타임스탬프에 ID 생성요청이 인입이 된경우, 생성한 첫번째 ID 는 일련번호가 0 이되고, 두번째 생성하는 ID 는 일련번호가 1이 된다.
    * 1밀리초가 경과할때마다 이값은 0 으로 초기화된다.
* 장점
  * 공유 스토리지가 필요 없으므로 성능도 뛰어나고, 수평확장시에도 영향 없다.
* 단점
  * ID 생성 서버들이 전부 같은 시계를 사용한다는 보장이 있어야한다. 만약 서버가 여러 코어에서 실행되거나 혹은 여러 서버가 여러 장비에서 독립적으로 실행될 경우 이같은 보장이 안된다.
  * 위 문제를 해결하기 위해 Network Time Protocol 과 같은 수단을 고려할 수 있다.

## 3. 상세 설계
* 유일 ID 는 나노초 단위 타임스탬프로 생성한다.
  * ms 단위까지만 표현하는 타임스탬프는 중복 발생확률이 높지만, 나노초 까지 표현하는 타임스탬프는 중복 확률이 극히 낮을듯
  * 나노초 단위 타임스탬프로만 생성하는게 복잡도도 낮고 오버헤드도 적을듯하다.
* 유일 ID 를 생성하는 이유는 요청이나 사용자를 식별하기 위함이다. 따라서 생성한 유일 ID (e.g. sessionId) 를 어딘가에 저장해두고 사용할 수 있어야 한다.
  * DB 에 저장 및 조회는 속도가 느리다. Redis cache 를 통해 빠른 저장 및 조회 성능 보장
  * ID 를 영속적으로 보관해야할 필요가 있다면, 결국 DB 에 저장해야한다. Kafka MQ 를 이용해 비동기적으로 DB 에 저장되도록 하여 성능 저하 방지
* 최종적으로 아키텍쳐는 아래와 같은 형상이 된다.

<img width="1454" alt="image" src="https://github.com/JisooOh94/study/assets/48702893/5c36c836-72b4-4dc5-b1fd-f69a74aa0bb9">



