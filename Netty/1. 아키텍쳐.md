# Netty
* Java의 NIO 를 이용한 비동기 Event-driven 방식의 네트워크 프레임워크
### 배경
* 어려운 NIO API를 내부에 숨겨 놓고, 추상화한 간단한 네트워크 통신 API를 제공함으로서 개발자가 비즈니스로직 개발에만 집중가능
  > TCP 및 UDP 소켓 서버와 같은 네트워크 프로그래밍을 크게 단순화하고 간소화

물론 Java NIO 역시 강력하지만 순수 NIO만을 이 용해서 네트워크 애플리케이션을 작성하는 일은 매우 어렵고 비효율적이다.때문에 예상치 못한 버그를 만들어 낼 수 있다.

덕분에 자바 프로 그래머들은 네트워크 프로그래밍이나 멀티스레드와 관련된 처리보다는 자신들의 비즈니스 로직에 좀 더 집중할 수 있게되었다.

### 생산성 향상을 위한 장치
빠른 개발을 위한 수 많은 컴포넌트들을 가지고 있다
#### Event Model
Netty는 입출력을 위해 잘 정의된 Well-defined 이벤트 모델을 가지고 있다. 사용자가 코어 로직을 손대지 않고도 직접 이벤트 타입을 구현할 수 있도록 지원한다.
각 이벤트 타입은 엄격하게 계층화되어 있어 서로 잘 구분된다. 다른 NIO 프레임 워크들은 이벤트 타입을 추가할 경우 기존 코드에 영향을 주거나 아예 커스텀 이벤트 추가를 막는 경우도 많다.
ChannelEvent는 ChannelHandlers에 의해 ChannelPipeline에서 처리된다. 파이프라인은 Intercepting Filter 패턴을 구현한다.
사용자는 이벤트가 어떻게 처리 되는지 어떻게 파이프라인의 핸들러들이 서로 상호작용하는지에 대해 컨트롤을 할 수 있다.

#### Universal Asynchoronous IO API
Netty는 Channel이라는 Async IO 인터페이스를 가지고 있다. 이 채널은 PointtoPoint 통신을 추상화한 개념이다
일단 Netty앱을 개발하면 추상화를 통해서 실제 통신 부분과 상관없이 로직을 개발할 수 있다. Netty는 여러개의 필수적인 transports를 하나의 API를 통해서 제공한다
* NIO 기반의 TCP/IP
* OIO 기반의 TCP/IP
* OIO 기반의 UDP/IP
* Local transport
이 transport 사이를 전환하는 것은 팩토리 클래스인 ChannelFactory를 고르는 몇 줄만 고치면 된다.
심지어는 아직 구현되지 않은 transport를 사용하는 클라이언트 코드를 미리 구현할 수도 있다 transport 역시 직접 구현해서 사용할 수 있다

#### ChannelBuffer
Netty는 NIO의 ByteBuer를 사용하지 않고 독자적인 Buer API를 구현해서 사용했다 ByteBuer는 사용해본 개발자는 알겠지만 flip을 중간중간에 호출하면서 사용해야되므로 매우 헷갈린다
쓰기 어렵고 헷갈린다는 것은 곳 버그 발생 확률이높다는 뜻이다.
또, ByteBuer를 사용하는 경우 GC가 많이 발생할 수도 있다. Netty는 이런 ByteBuer 대신 독자적인 버퍼를 구현했다.
독자적인 버퍼를 구현해서 제로카피 Zero Copy도 지원하고, ByteBuer보다 빠른 성능을 구현했다 다이나믹 버퍼 타입도 지원한다

### 핵심 컴포넌트
* Channel
    * IO 작업 수행 대상인 엔티티(파일, 네트워크소켓 등)에 대한 열린 연결
    * 엔티티와 주고받는 데이터의 운송수단, 통로
    * 하나 이상의 입출력 작업을 수행할 수 있는 하드웨어 장치, 파일, 네트워크 소켓이나 프로그램 컴포넌트와 같은 Open된 Connection 을 의미합니다.
* Callback
    * IO 작업 완료 이벤트 발생시 IO 작업 결과에 따른 이벤트 처리를 수행할 메서드
    * 애플리케이션에게 작업 완료를 알리는 방법
    * 다른 메서드로 자신에 대한 참조를 제공하는 메서드입니다. 이벤트를 처리할 때 Netty 내부적으로 콜백을 이용하는데, 이때 ChannelHandler 인터페이스를 통해 이벤트를 처리합니다.
* Future
    * 비동기 IO 작업의 결과를 담는 PlaceHolder
    * IO 작업이 완료되었는지 확인할 수 있으며 작업 완료시 그 결과에 접근가능
    * 메인스레드가 폴링 해야하는 방식이기때문에 완전한 Non-Blocking이라 할 수 없음. 따라서 Netty 에선 Listener 등록을 통해 폴링 없이도 작업 완료를 알 수 있는 ChannelFuture를 제공
    * 작업이 완료가 될 경우 애플리케이션에 알립니다. Future 객체는 비동기 작업의 결과를 담는 Plachloder의 역할을 합니다. 이때 ChannelFuture 인터페이스를 이용해 결과값을 활용합니다

    ```java
    ChannelFuture future = channel.connect(new InetSocketAddress("192.168.0.1", 25));
    future.addListener(new ChannelFutureListener() {
        @Override
        public void operationComplete(ChannelFuture future){
            if(future.isSuccess()){}
        }
    }
    ```
* Event 와 Handle
  * Netty는 작업 상태의 변화를 알리기 위해 이벤트를 이용하고, 발생한 이벤트를 기준으로 Handler를 통해 트리거합니다.
* EventLoop
  * 유저가 입출력을 요구할 경우의 흐름
    ![image](https://user-images.githubusercontent.com/48702893/162732665-88304d3b-9fe5-4015-a709-aeb867a65b1d.png)
* PipeLine
  * 이벤트 루프에서 이벤트를 받아 핸들러에 전달하는 역할
    ![image](https://user-images.githubusercontent.com/48702893/162732726-0bcda52f-0115-4573-98b6-194cf027a397.png)
  * 각각의 SocketChannel은 ChannelPipeline을 가지고 있다. 채널파이프라인은 ChannelHandler 인스턴스의 리스트다.
    EventLoop이 데이터를 SocketChannel에서 읽으면 데이터는 파이프라인에 있는 첫번째 채널핸들러에게 넘겨진다. 첫 번째핸들러는 넘겨받은 데이터를 처리하고 필요한 경우 파이프라인의 다음 핸들러로 데이터를 넘길 수 있다.
    데이터를 SocketChannel로 쓰는 경우도 마찬가지로 ChannelPipeline을 타게 되며 핸들러들을 거친다음 SocketChannel로 쓰여지게 된다.
  * 채널 파이프라인은 Netty 애플리케이션의 핵심이다 각 TCP 연결에 해당하는 SocketChannel은 ChannelPipeline을 가지고 있다.
    채널 파이프라인은 ChannelHandler 인스턴스의 리스트다. 각 ChannelHandler 인스턴스들은 SocketChannel쪽으로 데이터를 넘기거나 SocketChannel 쪽에서 데이터를 얻어온다.
    ChannelHandler는 두가지 서브 인터페이스가 있다.
      * ChannelInboundHandler
      * ChannelOutboundHandler
* SocketChannel
Netty의 SocketChannel은 TCP 연결을 대표한다. 네트워크 프로그램에서 Server나 Client가 Netty를 사용한다면 머신 사이에서 데이터를 전달하는 과정은 Socket Channel을 통해서 이뤄진다.
SocketChannel은 항상 같은 EventLoop에 의해 관리가 된다. 같은 EventLoop은 항상 같은 스레드에서 실행이 되기 때문에 SocketChannel은 항상 같은 스레드에서 접근된다.
이 때문에 순서가 보장된다 따라서 같은 SocketChannel에서 동시에 데이터가 읽히는 것에 대해서는 걱정하지 않아도된다.
* 



### 동작 방식
* Channel에서 발생하는 이벤트를 EventLoop인 Selector 가 스레드에 위임하여 처리하는 구조로 동작
* Selector가 지속적으로 select 를 호출하여 등록된 Channel 에서 발생하는 이벤트 모니터링

<img src="https://user-images.githubusercontent.com/48702893/131709571-af197f5c-b8b5-405c-bf75-7d4f78d63ab6.png" width="400" height="400" align="center">
