# 코드 작성 형식
### 1. 적절한 파일 크기
* 큰 파일보다 작은 파일이 이해가 쉬움
* 가급적 한 파일의 크기가 200줄을 안넘어가도록 구현
   * FilInfoValidation.java : 736
   * BillBo.java : 851
### 2. 개념은 빈 행으로 분리
* 코드로 구현하는 개념이 바뀔때에는 빈 행을 넣어 분리
* 개념 : 패키지 선언부, import 문, 각 함수 등
### 3. 세로 밀집도
* 서로 밀접한 코드행은 세로로 인접되어있어야 한눈에 들어온다.
* 밀접하게 동작하는 코드행이 서로 떨어져있을경우, 코드를 읽을때 밀접한 코드행을 이러저리 찾아다녀야함
* 밀접하게 동작하는 코드행이 서로 떨어져있을경우, 두 코드행의 밀접한 관계가 한눈에 보이지 않음
```JAVA
PhotoUploadInvoker.java
private String uploadToPhotoInfra(ExportInfo exportInfo, ExportFileInfo exportFileInfo, PhotoServiceInfo photoServiceInfo, ClientHttpResponse response) {  
  
   String uploadResult;  
  
  // 빈팩토리 생성  
  PhotoUploaderFactory photoUploaderFactory = new PhotoUploaderFactory(photoServiceInfo.getServiceUrl(), photoServiceInfo.getSname(), photoServiceInfo.getApiKey());  
  // 업로더 클라이언트 빈생성(Singleton)  
  GeneralPhotoUploaderClient upphotoClient = photoUploaderFactory.generalPhotoUploaderClient();  
  
  UpphotoSession session = null;
```
```JAVA
PhotoUploadInvoker.java
private String uploadToPhotoInfra(ExportInfo exportInfo, ExportFileInfo exportFileInfo, PhotoServiceInfo photoServiceInfo, ClientHttpResponse response) {  
   String uploadResult;  
   UpphotoSession session = null;
   PhotoUploaderFactory photoUploaderFactory = createBeanFactory(PhotoUploaderFactory.class, photoServiceInfo);
   GeneralPhotoUploaderClient upphotoClient = photoUploaderFactory.createPhotoUploaderClientBean();  
```
### 4. 수직거리
* 서로 연관성이 깊은 개념은 가급적 동일한 파일내에 세로로 가까이 배치되어야 함
* 서로 밀접한 개념이 다른 파일에 속할경우, 코드 동작을 이해하는 과정에서 이파일, 저파일 찾아다니게 됨
### 5. 변수 선언 위치
* 지역 변수 : 각 함수 첫 시작 부분
* 루프제어 변수 : 루프문 내부
* 인스턴스 변수 : 클래스 첫 시작 부분
```JAVA
/**  
 * CmsInfoData를 갱신한다. 
 */
public void reloadCmsInfoData() {  
   int[] idcNos = envDmsInvoker.getIdcInfo();  
   Map<Integer, List<Map<String, Object>>> cmsInfoListsByIdcNo = new HashMap<Integer, List<Map<String, Object>>>();  
   for (int idcNo : idcNos) {
	  cmsInfoListsByIdcNo.put(idcNo, new ArrayList<Map<String, Object>>());  
   }  
   List<Map<String, Object>> tempList = null;  
   List<Map<String, Object>> cmsInfoList = envDmsInvoker.getCmsInfo();
   for (Map<String, Object> cmsInfo : cmsInfoList) {
	  if (isAliveCms(MapUtils.getString(cmsInfo, "server_ip"), MapUtils.getString(cmsInfo, "service_port"))) {
		  tempList = cmsInfoListsByIdcNo.get(cmsInfo.get("server_set_idc_no"));
		  tempList.add(cmsInfo);  
	  }  
      logger.debug("cmsInfo reset :" + cmsInfo);
   }  
  
   for (int idcNo : idcNos) {  
      logger.info("cmsInfo reset - " + "idcNo:" + idcNo + ", serverCount:" + cmsInfoListsByIdcNo.get(idcNo).size());  
   }  
  
   CmsInfoData.resetCmsInfoList(cmsInfoListsByIdcNo);  
}
```
### 6. 종속함수 위치
* 종속함수와 주인함수는 세로로 가까이 배치한다.
* 주인함수가 종속함수보다 위에 배치어야 코드가 자연스럽게 읽힌다.
```JAVA
MemoDmsInvoker.java
public Map<String, Object> deleteMemo(String userId, int userIdx, String ownerId, int ownerIdx, long shareNo, int shareType, long targetNo, int messageType, long messageNo) {  
   DmsRequest req = new DmsRequest(dmsDomainRepository.getCommonDmsDomainId(), DmsCommand.REMOVE_SHARE_MESSAGE);  
  req.setParam(userId);  
  req.setParam(userIdx);  
  req.setParam(ownerId);  
  req.setParam(ownerIdx);  
  req.setParam(shareNo);  
  req.setParam(shareType);  
  req.setParam(targetNo);  
  req.setParam(messageType);  
  req.setParam(messageNo);  
  return dmsInvoker.invoke(req);  
}  

public Map<String, Object> deleteReply(String userId, int userIdx, String ownerId, int ownerIdx, long shareNo, int shareType, long targetNo, long messageNo) {  
   return deleteMemo(userId, userIdx, ownerId, ownerIdx, shareNo, shareType, targetNo, MESSAGE_TYPE_REPLY, messageNo);  
}
```
### 7. 개념적 유사성
* 종속관계가 없더라도 개념적 친화도가 높은 코드(이름과 기능이 비슷한 코드)들은 인접해 배치한다.
```JAVA
ShareHttpDmsInvoker.java
/**  
 * 기 공유자 목록 조회 * * @param userId  
  * @param option  
  * @return List<ShareUserInfo>  
 */  
public List<ShareUserInfo> getShareUserList(String userId, String option) {  
   MultiValueMap<String, String> parameters = createParam();
   parameters.add("userId", userId);  
   if (StringUtils.isNotEmpty(option) && option.equals(SAFE_LINK_OPTION)) {  
      parameters.add("option", option);  
   }  
  
   return invoke(httpDmsDomainRepository.getCommonDmsDomain(), ShareHttpDmsCommand.GET_ALREADY_SHARE_USER_LIST, parameters, new TypeReference<HttpDmsResult<List<ShareUserInfo>>>() {  
   });  
}

/**  
 * 공유 폴더 공유자 리스트 조회 * * @param userId  
  * @param shareNo  
  * @param ownerId  
  * @return List<ShareUserInfo>  
 */  
public List<ShareUserInfo> getSharingUserList(String userId, long shareNo, String ownerId) {  
   ShareFolderInfo shareFolderInfo = getShareFolderInfo(userId, shareNo, ownerId);  
   if (shareFolderInfo == null || shareFolderInfo.getSharingUserList() == null) {  
      return Collections.emptyList();  
   } else {  
      return shareFolderInfo.getSharingUserList();  
   }  
}
```

### 8. 가로형식
* 한 행의 길이는 120자 이하로 제한

### 9. 가로공백
* 가로로 공백을 두어 밀접한 개념과 느슨한 개념 구분
   1. 할당연산자 앞뒤에 공백을 두어 왼쪽, 오른쪽 요소 구분
   ```
   int leftValue = rightValue;
   ```
   2. 함수와 인수는 붙여주어 둘 사이의 밀접한 관계 표현
   ```
   public class getAge(String name) {}
  ```
   3. 공백을 통해 연산자 우선순위 강조
   ```
   public double determinant(double a, double b, double c) {
      return b*b - 4*a*c;
   }
   ```


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEzNDg4ODQ4ODhdfQ==
-->