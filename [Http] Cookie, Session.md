# 등장 배경
* HTTP 프로토콜의 비연결성(Connectionless), 비상태성(Stateless)에 따라 사용자를 식별할 수 없음
	* 서버 자원 절약을 위해, 위해 매 사용자 요청마다 연결과 해제의 과정 반복
	* 이로인해 연결 상태가 유지되지 않고, 연결 해제 후에 상태 정보도 저장되지 않음
	* 이에따라 사용자를 식별할 수 없어, 같은 사용자가 요청을 하더라도 매번 새로운 사용자로 인식
* HTTP 요청동안 사용자 식별정보를 유지하여, 서버가 동일한 사용자로 인식할 수 있도록 하는 장치 필요

<br> 

# 쿠키
* 사용자의 웹 브라우저에 저장되는 사용자 정보
* 사용자 요청 전송시, 쿠키도 함께 전송
* 샤용자 식별 데이터, 개인화 데이터 등을 저장
	* 식별 데이터 : 세션ID, 사용자 닉네임, 접속시간 등
	* 개인화 데이터 : 사용자 장바구니 항목, 맞춤 광고 키워드 등 

### 단점
* 방문한 웹 사이트 정보 및 개인정보가 기록되기 때문에 사생활 침해 우려
* 사용자 웹 브라우저에 저장되기 때문에, 쿠키데이터 위변조 및 탈취가 쉬워 보안이 약함

<br>

# 세션
* 서버가 클라이언트를 식별하는 방법
* 세션ID 를 생성하여 클라이언트를 식별하며, 브라우저 종료시 세션ID 는 자동 소멸
* 생성한 세션ID는 클라이언트의 브라우저 쿠키 저장소, 서버의 세션스토리지 각각에 저장
	> 브라우저 쿠키 저장소에 저장시, Memory cookie 타입으로 저장되어, 브라우저 종료시 함께 소멸됨

### 세션을 통한 인가처리 과정
1. 클라이언트가 서버에 로그인 요청 전송
2. 서버는 클라이언트의 로그인 요청 검증후(아이디와 비밀번호 검사) sessionId 생성
3. 생성한 sessionId 를 세션스토리지에 저장후, 응답메시지 set-cookie 헤더에 추가하여 클라이언트로 응답
	> set-cookie: sessionid:...
4. 클라이언트는 sessionId 를 쿠키 저장소에 저장
5. 이후 클라이언트는 서버로 요청전송시, 쿠키 저장소로부터 sessionId 를 가져와 요청헤더에 추가하여 전송
5. 서버는 요청헤더의 sessionid 값과 세션스토리지의 sessionId 값을 비교하여 사용자 인식

### 장점
* sessionId 를 클라이언트와 서버 모두 가지고 비교하므로 쿠키에 비해 보안이 좋음

### 단점
* 서버가 모든 클라이언트의 sessionId 를 관리해야하므로 많은 부하 발생 및 리소스 필요
	> Token 방식의 인가(e.g. JWT Token)를 통해 해결 간으 

<br>

![image](https://user-images.githubusercontent.com/48702893/146778624-c686ca34-dd83-4248-9d24-57d6cc84fc3d.png)


***
> Reference
> * https://chrisjune-13837.medium.com/web-%EC%BF%A0%ED%82%A4-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80-aa6bcb327582
> * https://devuna.tistory.com/23#recentComments
> * https://mohwaproject.tistory.com/entry/HTTP-Session-%EC%9D%B4%EB%9E%80