# Java 동기화 장치 종류
# 1. volatile
* 통신(메모리) 동기화 장치 (CPU 캐시 및 코드 재배치 비활성화)
* Scope : 변수
```java
private volatile boolean updated = false;
```
* volatile 이 선언된 변수를 사용하는 코드 수행시, 쓰기작업은 메인 메모리로 바로 쓰고, 읽기 작업은 메인 메모리에서 바로 읽어 메모리 가시성 보장
* 원자적 연산에서의 동기화만 보장, 배타적 동기화 제공하지 않음
	> 다수의 스레드에서 동시에 변수 조회 및 가공시, 원자성 보장 x
* 상태를 보관하거나 작업 완료 여부 등을 나타내는 플래그 변수에 주로 사용

### 원자적 연산 / 비원자적 연산
* 원자적 연산 : 변수가 저장되어있는 메모리 공간에 한번만 접근하는 연산
```java
a = 1;
flag = false;
if(flag)
b = a;
```
* 비원자적 연산 : 변수가 저장되어있는 메모리 공간에 두번 이상 접근하는 연산
```java
a++;
a *= b;
```

### volatile double / long
* 64 bit 데이터로 이루어진 double, long 타입 데이터의 경우, 32 비트 단위로 데이터를 나누어 IO 수행
* 따라서 멀티스레드 환경에서 double, long 타입 데이터의 데이터 정합성이 깨질 위험 존재
* volatile 로 선언시, double, long 타입 데이터의 64 비트 단위 데이터 IO 원자성 보장

### 단점
* CPU 캐시를 사용하지 않고 항상 메인메모리에서 데이터 IO 를 수행하므로 성능 저하
* 성능 향상을 위한 코드 재배치를 비활성화 하므로 성능 저하

<br>

# 2. synchronized
* 통신 동기화 + 배타적 실행 동기화 장치
* Scope : 변수, 함수, 코드블록
	* synchronized 함수 : 클래스 내의 다른 모든 synchronized 메서드를 block 하게 되므로 성능상 좋지 않음
	* synchronized 코드블록 : 필요한 코드 영역에만 synchronized 를 적용하여 임계영역을 최소화해 성능 저하 적음 
* Lock 객체 및 Monitor를 이용해 배타 동기화 수행
* 임계영역(synchronized 키워드가 선언된 변수, 함수, 코드블록) 코드를 한번에 하나의 스레드만 수행함을 보장

### 단점
* Lock 획득/반환 연산 부하로 인한 성능저하 발생

<br>

### 3. lock(ReentrantLock)
상기에서 synchronized(this)에서 this는 일반적으로 사용되는 Statement인데 뜻은 이 클래스를 사른 Thread가 Locking 하고 있지 않다면이라는 의미가 된다. 그래서 꼭 this를 쓸 필요는 없다. 임의의 객체를 사용해서 synchronized 처리 해도 상관은 없다.

* synchronized를 더욱 유연하고 정교하게 처리해주는 모듈
* 내부적으로 synchronized를 사용해 구현되었으며 설정값에 따라 lock 획득에 순서를 부여해 스레드 굶주림 방지 가능  
	> 쓰레드를 공정하게 관리하는 것보다 불공정하게 관리할 때 성능이 더 우수하다.
* lock(), unlock()으로 시작과 끝을 명시하기 때문에 임계 영역을 여러 메서드에 나눠서 작성 가능
	> synchronized는 블록 구조를 사용하기 때문에 하나의 메서드 안에서 임계 영역의 시작과 끝 설정 강제
*  인스턴스에 한개 이상의 Condition을 지정 가능(monitor 역할). 
	> Condition : Object 클래스의 monitor method인 wait(>await), nofity(>signal), notifyAll(>notifyAll ) 메서드를 대체 

<br>

### atomic
* Atomic Type 은  단일 변수에 대해서 Atomic Operations을 지원
* 내부적으로 Compare-And-Swap(CAS) 알고리즘을 사용해 lock 없이 동기화 처리(Lock-Free)
	* CAS : 현재 주어진 값(=현재 쓰레드에서의 데이터)과 실제 메모리에 저장된 데이터를 비교해서 두 개가 일치할때만 값을 업데이트
	
### CAS

### ABA

멀티 쓰레드 환경에서 최신 데이터임이 보장되는 변수를 선언

synchronized처럼 임계영역에 같은 시점에 두개 이상의 쓰레드가 접근하려 하면 쓰레드 자체를 blocking 시키는 메커니즘이 아니다. 
현재 연산에서 기대하는 값과 메모리 상에서의 값이 일치하지 않는다면 '중간에 다른 쓰레드가 끼어들었군!'으로 판단해 write를 실패시키고 재시도를 하게된다. 
lock-free 방식으로 루프를 돌기 때문에 block<->unblock 상태 변경 처리에 쓰이는 비용을 절감할 수 있게된다.


# Condition

# Semaphore

> Reference
> * https://jronin.tistory.com/110
> * https://zion830.tistory.com/58?category=752447
> * https://zion830.tistory.com/57
> * https://enumclass.tistory.com/169
> * https://it.donga.com/215/
> * https://dingue.tistory.com/8
> * https://parkcheolu.tistory.com/16#recentComments