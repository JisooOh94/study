# TCP/IP 프로토콜 통신 레이어
* 호스트 영역
	* CPU 가 작업을 수행하는 영역
	* 유저영역(애플리케이션), 커널영역 으로 구성
* 디바이스 영역
	* NIC(Network Interface Card. 랜카드) 가 작업을 수행하는 영역
	* 패킷 송수신 담당

<br>

# Socket 생성 및 연결 과정

### 소켓 생성
```
int socket(int domain, int type, int protocol)
```
* domain
  * 리눅스에서 제공하는 소켓 클래스
  * 각 클래스별로 통신에 사용하는 고유한 주소 표현법을 가지고 있어 address family 로 부르기도함
    |domain|description|
    |:-:|:-:|
    |UNIX|유닉스 도메인 소켓 (Unix domain socket)|
    |INET|TCP/IP 프로토콜을 이용한 통신을 지원하는 인터넷 주소 패밀리|
    |AX25|아마추어 라디오 X.25|
    |IPX|노벨의 IPX 프로토콜|
    |APPLETALK|애플사의 Appletalk DDP 프로토콜|
    |X25|X.25 프로토콜|
* type
  * 각 address family 별로 제공하는 소켓 통신 타입
  * Stream : 신뢰성있는 양방향 순차 데이터 스트림 통신 소켓(TCP)
  * Datagram : 신뢰성을 보장하지않은 데이터 통신 소켓(UDP)
  * Raw : 프로세스가 하부 프로토콜에 직접 접근할 수 있는 소켓
  * 기타 Reliable Delivered Messages, Sequenced Packets, Packet 등
* 소켓 생성 성공시 파일 디스크립터를, 실패시 -1 반환
* 생성되는 소켓 은 default 로 blocking 소켓이며, fcntl() 함수를 통해 non-blocking 소켓으로 변환 가능 

### 바인딩
```java
int bind(int sockfd, struct sockaddr *local_addr, socklen_t addrlen)
```
* 생성한 소켓(sockfd)에 소켓 주소(로컬 IP 주소 및 포트 번호) 할당하여 프로세스와 bind
* bind 된 프로세스는 해당 소켓을 통해 네트워크 IO 수행

### 연결
```java
int connect(int sockfd, const struct sockaddr *remote_host, int addrlen)
```
* 클라이언트에서 서버와 TCP 커넥션 수립을 위해 사용
* 3-way handshake 를 통해 원격 호스트(서버)와 TCP 소켓 연결 수행
* 연결된 정보는 remote_host 구조체에 저장

### Listen
```java
int listen(int sockfd, int backlog_queue_size);
```
* 클라이언트의 connection 수립 요청 수신 대기
* connection 수립 요청 수신시, 우선 connection 요청 대기열(backlog queue)에 저장, 대기열의 앞에서부터 순차적으로 connection 수립 처리
* backlog queue 크기는 backlog_queue_size 로 설정 가능하며 backlog queue 가 가득 찰경우, blocking / non-blocking 에 따라 다르게 동작
  * blocking : backlog queue 에 유휴 공간이 생길때까지 block
  * non-blocking : EWOULDBLOCK/EAGAIN 에러 응답

### Accept
```java
int accept(int sockfd, struct sockaddr *remote_addr, socklen_t *addrlen);
```
* 클라이언트의 connection 수립 요청 수락
* 연결된 원격 컴퓨터(클라이언트)의 정보는 remote_host에 저장 

<br>

# TCP/IP 프로토콜 데이터 송신 과정

![image](https://user-images.githubusercontent.com/48702893/104942692-22784180-59f8-11eb-857d-677bc52d5907.png)

### 1. Application
* 애플리케이션에서 write 시스템 콜 호출하여 커널모드전환, 데이터 전송 시작
  * POSIX 운영체제(linux, unix등)는 소켓을 하나의 파일처럼 인식하고 사용하므로, 소켓의 file descriptor 를 통해 (파일처럼 동작하는) 소켓을 조회하여 데이터 read/write 수행
```java
ssize_t write(int fd, const void *buf, size_t count);
```

> 파일 디스크립터(File Descriptor)
> * 운영체제가 만든 파일 또는 소켓등을 지칭하기 위해 부여하는 숫자
> * 파일/소켓을 open() 함수로 열면, 고유한 숫자를 가진 파일 디스크립터(fd) 반환
> * 파일 디스크립터 테이블의 정보를 조회하는데에 사용되는 key

> 파일 디스크립터 테이블
> * 파일 관리 및 read/write 하기위해 필요한 정보가 저장되는 테이블
> * 파일이름, 파일 저장 위치, 파일 유형 등의 정보 저장

![image](https://user-images.githubusercontent.com/48702893/104943958-dc23e200-59f9-11eb-820f-7e8f800db65f.png)

### 2. File
* 파일 디스크립터 validation 및 파일입출력 시스템 콜(write)를 구현한 소켓 API 호출

### 3. Sockets
* 전송요청된 데이터를 유저영역 메모리(애플리케이션 Head/Stack 메모리)에서 커널영역 메모리의 send socket buffer 로 복사
* write 시스템 콜 호출 시점에 send socket buffer 가 가득차있을시, 소켓의 blocking / non-blocking 에 따라 다르게 동작
  * blocking : send socket buffer 가 비워질때까지 block
  * non-blocking : EWOULDBLOCK/EAGAIN 에러 응답

### 4. TCP
* 소켓에 연결되어있는 TCB 로부터 TCP 커넥션 정보 조회
* TCP 커넥션 상태 확인후, 데이터 전송 가능한 상태(ESTABLISHED) 일경우 TCP 세그먼트 생성
* 생성한 세그먼트의 페이로드에 send socket buffer 에 있는 데이터 적재
	* send socket buffer 에 있는 데이터중 현재 TCP 커넥션 상태에 따라 전송가능한 양만 적재
	* 전송 가능한 양 : receive window(흐름제어 크기 제한), congestion window(혼잡제어 크기 제한), MSS(Maximum Segment Size) 중 최대값 
* 세그먼트 헤더, 페이로드 데이터로부터 체크섬 계산하여 세그먼트 헤더에 추가
	* TCP 세그먼트 송신도중 발생할 수 있는 비트 오류 검출 장치(TCP/IP 프로토콜의 오류없는 데이터 송수신 보장)
	* 수신측에서 전송받은 세그먼트로부터 직접 계산한 체크섬 값과 헤더에 들어있는 체크섬 값을 비교하여 오류 검출  

> TCP 체크섬 계산 알고리즘
> 1. Pseudo Header 생성 : 총 12바이트 길이로서 IP Header + TCP 세그먼트 데이터로부터 생성
> ![image](https://user-images.githubusercontent.com/48702893/105041277-206cbc00-5aa6-11eb-8e27-890b6ce242dd.png)
> 2. Pseudo Header, TCP 세그먼트 각각을 16비트 단위로 분할후 더하여 총합 계산
> 3. Pseudo Header 총합과 TCP 세그먼트 총합을 더한후 1의 보수를 적용하여 체크섬 도출

> TCP Control Block(TCB)
> * TCP 프로토콜 데이터 전송 및 TCP 커넥션 식별을 위한 데이터가 저장되는 구조체
> * TCP 커넥션 상태, receive windown, congestion window 등 저장

> checksum offload
> * TCP 체크섬 계산을 커널 영역에서 수행하지 않고 디바이스 영역인 NIC 가 수행하는것
> * 최신 네트워크스택은 checksum offload 를 통해 OS의 작업을 NIC가 대신하게함으로서 서버 성능 향상

```java
$ ethtool -k eth0       //checksum offload 확인 명령어
Offload parameters for eth0:
rx-checksumming: on     //checksum offload 활성화 여부
tx-checksumming: on
scatter-gather: on
tcp segmentation offload: on
```

### 5. IP
* IP 패킷 생성하여 TCP 세그먼트 적재 및 체크섬(IP 헤더 validation 용) 계산하여 헤더에 추가
* IP 라우팅 수행[[참고]](https://github.com/JisooOh94/study/blob/master/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/7.%20%EB%9D%BC%EC%9A%B0%ED%84%B0.md)
    * 목적지 IP 로 가기 위한 다음장비(next hop) IP 주소를 찾는 과정

### 6. Ethernet
* IP 패킷에 Ethernet 헤더 추가
* ARP[[참고]](https://github.com/JisooOh94/study/blob/master/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/1.%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EA%B0%9C%EC%9A%94.md#%EB%B8%8C%EB%A1%9C%EB%93%9C%EC%BA%90%EC%8A%A4%ED%8A%B8) 수행하여 next hop IP 의 MAC 주소 탐색 

### 7. Driver
* NIC 에게 패킷 전송 요청
* 패킷캡쳐 프로그램(Fiddler) 작동중일시, 커널은 드라이버 레이어 수행 전, 패킷을 패킷 캡쳐 프로그램이 사용하는 메모리 버퍼에 복사

### 8. NIC
* 호스트의 메모리버퍼(메인메모리)에 있는 패킷을 자신의 메모리로 복사후 네트워크 통신 선을 통해 전송
* Ethernet flow control(CSMA/CD)[[참고]](https://github.com/JisooOh94/study/blob/master/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/1.%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EA%B0%9C%EC%9A%94.md#csmacd) 에 따라 전송할 수 있는 상황(네트워크상에 캐리어가 없을떄)일때 전송
* 전송 전, 패킷에 IFG(Inter Frame Gap), preamble(패킷의 시작점 체크), CRC(일종의 NIC 체크섬) 추가
IFG, preamble은 패킷의 시작을 판단하기 위해 사용하고(네트워킹 용어로는 framing), CRC는 데이터 보호를 위해 사용한다

<br>

# TCP/IP 프로토콜 데이터 수신 과정

![image](https://user-images.githubusercontent.com/48702893/105046814-e5ba5200-5aac-11eb-9f0d-9ae6ece2dfc4.png)

### 1. NIC
* 수신한 패킷을 자신의 메모리에 저장 후, CRC로 패킷 오류 검사
* 오류가 없을시, 호스트의 메모리버퍼(메인메모리)에 패킷 저장 후, OS에 인터럽트 전송 [[참고]](https://github.com/JisooOh94/study/blob/master/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/3.%20%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC%20%EC%9E%A5%EB%B9%84.md#%EB%9E%9C%EC%B9%B4%EB%93%9C%EC%9D%98-cpu-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%EC%9B%90%EB%A6%AC) 

### 2. Driver
* 메모리버퍼에 있는 패킷 확인하여 자신이 처리할 수 있는 패킷인지 검사
* 패킷을 운영체제가 사용하는 패킷 구조체로 포장하여 상위 레이어 작업에 사용할 수 있도록 함
    * Linux - sk_buff, Windows - NET_BUFFER_LIST

받는 쪽에서도 마찬가지로 메시지가 오면 일단, 소켓 버퍼(Receive socket buffer)에 저장 된 후 Application에서 read함수 호출을 통해 소켓 버퍼에 쌓인 메시지를 읽어 들인다.

### 3. Ethernet
* 패킷 오류 검사

### 4. IP
* 패킷 오류 검사(IP 체크섬 확인)

### 5. TCP
* 패킷 오류 검사(TCP 체크섬 확인)
* <출발지 IP, 출발지 포트, 목적지 IP, 목적지 포트> 를 식별자로 TCB 탐색
* 탐색된 TCB 에 연결되어있는 소켓의 receive socket buffer 에 패킷 추가

### 6. Application
* 애플리케이션에서 read() 시스템콜 호출하여 커널모드 전환
* receive socket buffer 의 데이터를 유저 영역 메모리에 복사 후 buffer 에서 삭제
* TCP 는 비워진 receive socket buffer(receive window) 크기를 ACK 패킷과 함게 송신자에게 전송