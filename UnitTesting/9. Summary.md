1. 단위 테스트를 작성하기 어려운 코드는 개선이 필요한 코드로 볼 수 있다. 
  * 보통 강결합된 코드들에서 이와같은 현상이 발생한다. 
  * 대상 코드의 단위 테스트 작성이 어려운경우, 코드 분리부터 먼저 시도해보자.
2. 모든 코드의 단위 테스트를 작성할 필요는 없다.
  * 불필요한 단위테스트의 경우 오류를 방지하지도 못하면서 유지 보수 비용만 소모한다.
  * 따라서 프로젝트에 해당 코드의 단위테스트가 도움이 될지를 명확하게 파악해 테스트의 가치와 유지 비용을 모두 고려하여 작성해야한다.
3. 단위 테스트도 비즈니스 로직과 마찬가지로 유지보수가 필요하다. 
  * 코드를 리팩터링할때 그에 해당하는 단위테스트도 함께 리팩토링해야한다.
4. 일반적으로 사용하는 커버리지 지표(코드 커버리지, 브랜치 커버리지)는 어플리케이션의 단위 테스트 코드의 품질(검증이 필요한 핵심 모듈의 모든 동작 케이스가 테스트되고있는지)측정에 도움이 되지 않는다.
  * 좀 더 개선된 커버리지 지표는 없는지 poc 중 :
5. 단위 테스트코드 작성시 AAA 패턴(Given-When-Then 패턴) 을 사용하자.
   * 모든 테스트가 단순하면서 일관된 구조를 갖게 함으로서 가독성 증대 및 유지보수에 용이해진다.
6. 단위 테스트에 AAA 패턴 적용시, 테스트당 1개의 given-when-then 구절만 있어야 한다.
   * 한개 이상의 given-when-then 구절이 있는 테스트(다단계 테스트)는 더이상 단위 테스트가 아닌 통합 테스트가 되어버린다.
   * 한번에 너무 많은것을 검증한다는 의미이므로 각각 개별적인 결과를 검증하는 테스트로 분리하는것이 좋다.
7. 단위 테스트내에 if 문이 존재해선 안된다.
   * 테스트의 가독성을 떨어뜨린다. 테스트는 분기가 없는 간단한 일련의 과정이 되어야한다.
8. 한 테스트 클래스내 여러 단위 테스트간 Given 구절 중복 코드가 있을경우, 별도의 팩토리 메서드로 분리하자.  
   * 중복 코드 분리를 팩토리 메서드로 분리함으로, 테스트간 결합도를 해소하고 테스트 코드 가독성을 증대시킨다. 
9. When 구절은 코드 한 줄 이어야 한다.
   * 두줄 이상인 경우 테스트 하고자하는 기능의 api 설계가 잘못된 경우이다
10. 하나의 기능/동작을 여러가지 값으로 검증해야하는 경우가 빈번하게 존재한다. 이럴때 매개변수화된 테스크를 적극 활용하자
     * 매개변수화된 테스트를 통해 중복 코드 해소 및 테스트코드 양을 죽일 수 있다.
11. 테스트 명명시 개발자만 이해할 수 있는 방식보다, 도메인에 익숙한 비개발자에게 시나리오를 설명하는것처럼 명명하도록 한다.
    * AS IS : admitStudent_MissingMandatoryFields_FailToAdmit, testStudentIsNotAdmittedIfMandatoryFieldsAreMissing
    * TO BE : StudentIsNotAdmittedIfMandatoryFieldsAreMissing
    * 테스트 명명 Best practice 조사중 : 
12. 단위 테스트내에서 스텁의 동작은 검증하지 않는것이 좋다.
    * 내부구현 세부사항인 스텁의 동작을 테스트코드에서 검증한다는것은 테스트코드와 코드를 강결합시켜 리팩토링내성을 떨어뜨린다.(과잉명세)
    * 최종 결과만 올바르다면, 코드내부에서 최종결과를 어떻게 생산하는지는 중요하지 않다. 따라서 스텁의 동작을 검증해서는 안된다.
13. Mock 동작 검증시 동작의 대상이 애플리케이션 외부 객체, 즉 목의 동작으로 발생하는 사이드 이펙트가 외부 환경에서 확인이 가능한 동작만을 검증해야한다.
    * e.g. 애플리케이션에서 사용자 정보를 수정하기 위해 database update --> O
    * 애플리케이션에서 사용자 정보 수정됨을 email 애플리케이션에 요청하여 메일을 통해 사용자에게 알림 --> O
    * 애플리케이션에서 사용자 정보 수정 이력을 로그로 기록 --> x (시스템 내부 통신)
    * 애플리케이션에서 사용자 정보 수정 이력을 감사 시스템에 전송하여 감사 로그로 기록 --> X (시스템 외부 통신이나, 사이드 이펙트가 외부 환경에서 확인이 불가능)
14. 출력 기반 테스트가 가장 좋은 단위 테스트 조건에 부합하므로 항상 다른 테스트 스타일보단 출력 기반 테스트 스타일을 우선적으로 적용해보는것이 좋다.
    * 테스트 대상 시스템에 입력을 넣고, 반환되는 출력값만 검증하는 테스트 스타일
    * 테스트 대상 시스템의 함수가 사이드 이펙트(e.g. 내부 필드 값 변화 등)를 발생시키지 않는 함수형 프로그래밍 방식의 함수일때 사용 적용 가능하다.
15. 소스코드 분류 기준에 따라 "지나치게 복잡한 코드" 는 험블 객체 패턴을 이용하여 책임을 분리하자.
    * 이를 통해 기반 코드의 유지 보수성도 증대되고 출력 기반 테스트도 적용할 수 있게된다.
    * 하지만 코드에 따라 함수형 아키텍쳐(험글 객체 패턴)를 적용할 수 없는경우도 있고, 적용했을때 오히려 얻는 효과 대비 비용만 증가하는 케이스도있으니 전략적으로 적용해야한다.
16. 비공개(private) 메서드의 단위테스트는 작성하면 안된다.
    * 비공개 메서드는 구현 세부사항이다. 비공개 메서드의 단위테스트를 작성하면 해당 테스트는 구현 세부사항과 강결합되는것이므로 리팩터링 내성이 떨어진다. 
    * 비공개 메서드가 너무 복잡해 공개 메서드 단위 테스트로는 비공개 메서드 로직에 대한 충분한 커버리지 달성이 어려운 경우 복잡한 비공개 메서드를 별도의 클래스로 도출해야하는 추상화과 누락됐다는 징후다. 별도 클래스로 분리하자.
17. 제품 코드의 알고리즘을 그대로 테스트 코드로 복사해 사용하면 안된다.
    * 테스트코드가 구현 세부 사항과 강결합되어 리팩터링 내성이 매우 떨어지게 된다.
    * 알고리즘을 복사하여 expected result 를 도출하는대신, 차라리 결괄르 테스트에 하드코딩하는편이 낫다.
18. Mockito.spy 의 사용은 지양하자.
    * Mockito.spy 를 사용할 수 밖에 없다면, 이는 테스트 대상 메서드 내에 비즈니스 로직과 외부 의존성 통신 책임이 혼재되어 있어서이다.
    * 험블 객체 패턴을 이용해 책임을 분리해주자.