# 좋은 단위테스트
* 좋은 단위테스트엔 다음 네가지 특성이 있다.
  * 회귀 방지
  * 리팩터링 내성
  * 빠른 피드백
  * 유지보수성

### 회귀 방지
* 회귀 : 기존 기능 개선, 새로운 기능 출시등을 위해 코드를 수정한 후, 기능이 의호한 대로 동작하지 않는 경우 즉 한마디로 버그
* 회귀 방지가 잘 된 테스트 코드는 회귀가 발생했을때 테스트 코드를 통해 조기에 파악하고 수정할 수 있게 해준다.
* 회귀를 방지할 수 있도록 테스트 코드를 짜기위해선 가능한한 테스트코드가 많은 코드를 실행하는것을 목표로 해야한다.
  * 하지만 여기서 말하는 '많은 코드' 는 선택적이다. 핵심 비즈니스로직을 수행하는 코드 부분은 가능한 많이 커버해야할것이고, 보일러 플레이트 코드는 테스트하기에 거의 가치가 없다.
* 거짓음성
  * 코드가 수정되었을때, 버그가 있어 기능이 의도한대로 동작하지 않음에도 테스트 코드가 성공하는 경우
  * 거짓음성은 버그가 있는 코드가 프로덕션 환경에 배포될 수 있게하여 매우 위험하다.

### 리팩터링 내성
* 코드를 리팩터링 했을떄, 테스트코드가 실패하지 않는지에 대한 척도
* 거짓양성
  * 코드의 동작에는 변함 없이 리팩토링만 수행했을떄, 즉 코드가 의도한 대로 작동하지만 테스트코드가 실패하는것을 거짓 양성이라 한다.
  * 테스트스튀트에 이러한 거짓양성이 많을수록 테스트 스위트에 대한 신뢰도가 서서히 떨어져 더이상 테스트 스위트가 쓸모가 없어지게 만든다.
  * 테스트 스위트가 무용지물이 되면 더이상 회귀 방지 수단이 없어지므로 회귀를 우려해 리팩토링을 하지 않게되며 코드 품질이 점점 나빠질것이다.
* 거짓양성을 줄이고 리팩토링 내성을 향상시키기 위한 방법
  * 거짓양성은 테스트코드가 테스트 대상 시스템의 구현 세부사항에 강결합되었을때 발생한다.
  * 따라서 테스트는 구현세부사항과 분리되어 최종 사용자에게 의미있는 결과만을 검증하는 블랙박스 테스트로 작성되어야한다.

### 빠른 피드백
* 테스트 스위트 수행 속도를 나타내는 지표
* 테스트 스위트 수행하는데에 오래 걸릴수록 버그를 발견하고 수정하는 비용이 증가하고 테스트 스위트를 자주 실행하지 못하게 하여 잠재적인 회귀 위험성을 높힌다.

### 유지보수성
* 테스트 코드가 유지보수하는데에 용이한가를 나타내는 지표
* 단순히 테스트 코드의 가독성뿐만 아니라, 테스트 실행이 간단한지도 포함(테스트가 데이터베이스, 타서버 등의 외부 종속성을 사용한다면 그에 소모되는 비용도 포함됨)


# 좋은 단위테스트 조건
* 이상적인 테스트는 좋은 단위테스트 특성 4가지를 모두 만족하는 테스트이나 현실적으로 불가능
* 게다가 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이라 한가지를 희생하고 두가지를 만족시켜야하며 희생하는 한 조건도 완전히 배제해선 안되고 어느정도는 지켜야한다.
* 상호 배타적인 새 특정중 하나를 완전히 배제 해버릴경우 가치가 없는 테스트가 됨

### 한 특성을 배제한 테스트 예
* 회귀 방지를 배제
  ```java
  //code
  public class UserInfo {
    public void setName(String name) {
      this.name = name;  
    }
  }
  
  //test
  @Test
  public void setNameWithEmptyStr {
    //given
    UserInfo userInfo = new UserInfo();      
    String emptyStr = "";
    
    //when
    userInfo.setName(emptyStr);      
    
    //then
    assertEquals(userInfo.getName(), emptyStr);      
  }
  ```
  * 아주 간단한 코드 조각을 테스트하는 간단한 테스트코드가 이해 해당된다.
  * 테스트코드 자체가 간단해지므로 리팩토링 내성도 높고 피드백도 빠르다.
  * 하지만 기반코드에 버그가 발생할 여지가 거의 없으므로 회귀를 방지할일이 거의 없는 문의미한 테스트 코드이다.

* 리팩터링 내성을 배제
```java
//code
public class UserInfo {
  private Static String KEY_ZIPCODE = "zipCode";
  private Map<String, String> address;
  
  public void setAddress(String zipCode, ...) {
    address = new HashMap<>();
    address.put(KEY_ZIPCODE, zipCode);
    ...
  }
}

//test
@Test
public void setUserAddress() {
  //given
  String zipCode = "AL1032";
  UserInfo userInfo = new UserInfo();
  userInfo.setAddress(zipCode, ...);
  
  //when
  Map<String, String> actualResult = userInfo.getAddress();
  
  //then
  actualResult.get("zipCode", zipCode);
  ...
}
```
  * 내부 구현과 강결합 되어있는 테스트가 이에 해당된다.
  * 사용자 입장에서의 입출력 뿐만 아니라 내부 코드 동작까지 검증하므로 회귀 방지도 잘되고, 때에따라 피드백도 빠를수 있다.
  * 하지만 코드 동작은 변하지 않으면서 내부 구현만 수정될경우, 테스트코드가 실패하며 거짓 양성을 유발한다.

* 빠른 피드백을 배제
  * 최종 사용자의 관점에서 UI, 데이터베이스, 외부 애플리케이션을 포함한 모든 시스템구성요소를 테스트하는 엔드투엔드 테스트가 이에 해당된다.
  * 모든 시스템 구성요소를 함께 테스트하므로 회귀 방지도 잘되고, 최종 사용자 관점에서 검증하므로 리팩토링 내성도 높다
  * 하지만 테스트를 수행하기위해 드는비용, 시간이 많이들어 피드백이 느리다.

### 회귀 방지, 리팩토링 내성, 빠른 피드백 사이의 절충
* 세가지 특성중엔 리팩토링 내성이 가장 중요하다. 따라서 리팩토링 내성을 극대화하면서 나머지 회귀방지, 빠른 피드백 사이에 절충을 해야한다.
  * 리팩토링 내성은 절충할 수 없다. 리팩토링 내성을 가지던지 가지지 않던지뿐이다. 이를 대표적으로 보여주는게 블랙박스 테스트 - 화이트박스 테스틑 이다.
* 회귀 방지, 빠른 피드백사이에 절충 정도에 따라 테스트를 3가지로 분류 할 수 있다.

  ![image](https://github.com/JisooOh94/study/assets/48702893/eeb1c45f-f042-4859-85b4-259ff2fa93e0)

  * 엔드 투 엔드 테스트
    * 피드백 속도를 희생하면서 회귀방지를 극대화한 테스트
    * 최종 사용자의 관점에서 UI, 데이터베이스, 외부 애플리케이션을 포함한 모든 시스템구성요소를 테스트하기때문에 외부 의존성 유지에 비용이 많이들어 유지 보수성도 떨어진다.
    * 따라서 엔드 투 엔드 테스트는 가장 중요한 기능 테스트에만 사용해야하며, 따라서 3가지 테스트중 가장 양이 적을수밖에 없다.
  * 통합 테스트
    * 피드백 속도와 회귀방지를 적절히 절충한 테스트
    * 따라서 테스트 양도 중간이다.
  * 단위 테스트
    * 피드백 속도를 극대화하면서 회귀방지를 어느정도 희생한 테스트
    * 코드 조각조각 단위로 테스트하기때문에 코드간 연동에서 발생하는 회귀를 감지할 수 없어 회귀방지가 떨어진다.
    * 반대로 코드 조각조각 단위로 테스트가 작성되기때문에 피드백 속도가 가장 빠르다

### 리팩토링 내성에 따른 분류
* 위에 설명헀듯, 리팩토링 내성은 절충할 수 있는 지표가 아니라 리팩토링을 내성이 있느냐 없느냐만 있고 그에따라 분류한게 블랙박스 테스트 / 화이트박스 테스트 이다.
* 블랙박스 테스트
  * 명세와 요구사항만을 가지고 검증을 수행하는 테스트
  * 애플리케이션의 내부 구조는 상관없이 테스트코드가 동작
* 화이트박스 테스트
  * 소스 코드를 기반으로 검증을 수행하는 테스트
  * 명세, 요구사항 뿐만 아니라 애플리케이션 내부 동작까지 검증
  * 외부 명세에만 의존할때 놓칠 수 있는 회귀들을 검증할 수 있다는 장점이 있으나 그만큼 리팩토링 내성이 떨어진다.
  * 리팩토링 내성은 타협의 대상이 아니므로 화이트 박스 테스트 대신 블랙박스 테스트를 기본 테스트 모델로 선택해야한다.