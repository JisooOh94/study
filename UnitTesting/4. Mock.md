# 목과 스텁
* 목은 테스트 대상 시스템과 그 협력자(의존성) 사이의 상호 작용을 검사할 수 있는 테스트 대역의 다른말
  * 테스트 대역엔 목과 스텁 두가지가 있으나 일반적으로 테스트에 있어 목이 스텁보다 더 중요하므로 보통 목으로 통칭해서 부르기도 한다

### 목과 스텁 구분
* 명령 조회 분리 원칙(CQS)에 따르면 모든 메서드는 명령이거나 조회 둘중에 하나이어야 하며 테스트 대역 또한 이 원칙에 따라 목과 스텁으로 구분
    * 명령 : 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는 메서드, e.g. Map.put 
        > 사이드이펙트 : 객체 상태 변경, 데이터베이스 테이블 변경 등 상태값의 변경
    * 조회 : 사이드 이펙트 없이 값만 반환하는 메서드, e.g. Map.get
* 목
  * 외부로 (의존객체로 데이터가) 나가는 상호 작용 모방
  * SUT 가 의존객체의 상태를 변경하기위한 의존객체 호출, 
  * 의존객체의 사이드 이펙트 발생
* 스텁
  * 내부로 (의존객체로부터 데이터가) 들어오는 상호 작용 모방
  * SUT 가 의존객체로부터 데이터를 얻기 위한 의존객체 호출

### 스텁은 검증하면 안된다
* (목의 동작인)코드의 수행으로 의존객체의 상태가 변경되는것은 원했던 결과로 볼 수 있다.
    ```java
    //code
    public class UserInfoDao {
      private UserRepository userRepository;
      ...
      public void updateUserAge(String id, int age) {
        validateAge(age);
        
        userRepository.update(id, age);
      }
    }
    
    //test
    @Test
    public void updateUserAgeWithValidAge() {
      //given
      Mock userRepositoryMock = new Mock<UserRepository>();
      UserInfoDao userInfoDao = new UserInfoDao(userRepositoryMock.Object());
      String id = "foo";
      int updateAge = 15;
      
      //when
      userInfoDao.updateUserAge(id, age);
      
      //then
      verify(userRepositoryMock, times(1)).update(eq(id), eq(updateAge));
    } 
    ```
    * userRepository 를 통해 db 상태가 update 되는것은 updateUserAge 메서드의 목적이므로 userRepository mock 의 상호작용을 검증해야한다.
* 반면에 스텁의 호출은 최종 결과가 아닌, 최종 결과를 산출하기 위한 수단일 뿐으로서 최종 결과와 상관없는 내부 구현 세부사항일 뿐이다.
  * 따라서 내부구현 세부사항인 스텁의 동작을 테스트코드에서 검증한다는것은 테스트코드와 코드를 강결합시켜 리팩토링내성을 떨어뜨리게되고 이를 과잉명세라 한다.
  * 최종 결과만 올바르다면, 코드내부에서 최종결과를 어떻게 생산하는지는 중요하지 않다. 따라서 스텁의 동작을 검증해서는 안된다.

  ```java
  import java.security.InvalidParameterException;
  
  //code
  public class UserInfoBo {
  
    private UserInfoDao userInfoDao;
    private UserValidateBo userValidateBo;
    ...
  
    //AS-IS
    public int getUserAge(String id) {
      if (userValidateBo.isValidId(id)) {
        return userInfoDao.getUserAge(id);
      } else {
        throw new InvalidParameterException(());
      }
    }
  
    //TO-BE
    public int getUserAge(String id) {
      return userInfoDao.getUserAge(id);
    }
  }
  
  //test
  @Test
  public void getUserAge() {
    //given
    Mock userInfoDao = new Mock<UserInfoDao>();
    Mock validateBo = new Mock<ValidateBo>();
    UserInfoBo userInfoBo = new UserInfoBo(userInfoDao.Object(), validateBo.Object());
  
    String testId = "foo";
    int age = 20; 
    given(validateBo.isValidId(eq(testId))).willReturn(true);
    given(userInfoDao.getUserAge(eq(testId))).willReturn(age);
    //when
    int actualResult = userInfoBo.getUserAge(testId);
  
    //then
    assertEquals(age, actualResult);
    verify(validateBo, times(1)).isValidId(eq(testId));
  } 
  ```
  
  * UserInfoBo 의 getUserAge 메서드가 AS-IS 에서 TO-BE 로 리팩토링되면, 최종결과물은 동일하나 테스트코드는 스텁인 validateBo 의 검증이 거짓으로되어 실패하게된다.

