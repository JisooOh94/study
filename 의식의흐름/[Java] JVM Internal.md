# JVM 내부구조

![image](https://user-images.githubusercontent.com/48702893/108217098-908a6280-7176-11eb-83ea-e1585e5eea08.png)

1. 자바 컴파일러(javac)가 자바코드를 자바 바이트코드(반기계어)로 컴파일
2. 클래스로더(Class Loader)가 자바 바이트코드를 런타임 데이터 영역(Runtime Data Area)에 로드
3. 실행엔진(Execution Engine)이 자바 바이트코드 실행 

# 클래스로더
* 자바 어플리케이션 실행시, 자바 바이트코드를 JVM 의 런타임 데이터 영역에 로드해주는 장치

### 특징
* 동적 로드
	* 일종의 lazy-load
	* 클래스 코드가 실행엔진에 의해 최초로 참조(사용요청)되었을때 런타임 데이터 영역으로 로드
* 계층 구조
	* 로드 하는 바이트 코드에 따라 하나의 JVM 내에 여러 클래스 로더가 계층적으로 존재
* 캐싱
	* 한번 로드한 클래스 바이트코드는 '네임스페이스' 라는 캐시메모리에 캐싱
	* 이후 같은 같은 코드 로드 요청시, 네임스페이스에서 탐색하여 로드

### 클래스 로더 원칙
* 위임 원칙(Delegation Principle)
	* 바이트코드 로드 요청시, 요청을 받은 클래스로더는 자신의 클래스로더 캐시 탐색하여 요청된 바이트코드가 캐싱되어있는지 확인
	* 캐시데이터가 없다면, 계층구조에 따라 상위 클래스로더에게 로드 위임 (위임받은 상위 클래스 로더는 같은 과정 반복)
	* 최상단 클래스로더까지 캐시데이터가 없다면, 최초 클래스로더가 .class 파일(바이트코드)에서 탐색하여 로드, 캐싱
* 가시성 원칙(Visible Principle)
	* 하위 클래스로더는 위임 원칙을 통해 상위 클래스 로더의 클래스를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없음
* 유일성 원칙(Uniqueness Principle)
	* 하위 클래스로더가 상위 클래스로더에서 로드한 클래스를 다시 로드하지 않아야 함

### 클래스로더 계층 구조

![image](https://user-images.githubusercontent.com/48702893/108221368-0f819a00-717b-11eb-816d-0fd179053a1a.png)

1. 부트스트랩 클래스 로더
	* JRE 에서 제공하는 자바 API 들 로드
2. 익스텐션 클래스 로더
	* JRE 에서 제공하는 여러 자바 확장 기능(e.g. Java 보안 확장 기능)들 로드 
3. 시스템 클래스 로더
	* 사용자가 개발한 애플리케이션 클래스(classpath 내의 클래스)들 로드
4. 사용자 정의 클래스 로더
	* 사용자가 직접 생성해서 사용하는 클래스 로더


