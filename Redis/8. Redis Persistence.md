# Redis Persistence
* Redis는 휘발성 Memory에 데이터를 저장하기때문에 데이터 영속성을 위해 RDB 와 AOF를 지원

# RDB (Redis Database Backup)
- RDB는 특정 시점의 데이터를 스냅샷으로 저장
    - 주기적으로 데이터를 디스크에 덤프하여 스냅샷 파일(RDB 파일)을 생성
- 스냅샷 파일은 서버가 재시작될 때 데이터를 복원하는 데 사용
- AOF 방식이 활성화되지 않았다면 Redis는 default 로 RDB 방식으로 백업을 진행
- 스냅샷 주기에 따라 데이터 손실 가능

### RDB 생성 방식
- `SAVE`: 즉시 데이터베이스의 스냅샷을 생성
    - Redis 서버가 스냅샷을 생성하는 동안 모든 클라이언트 요청을 블로킹
    - 서버가 잠시 멈추고 스냅샷을 생성하므로, 서비스 중단 발생 가능
- `BGSAVE`: 백그라운드에서 스냅샷을 생성
    - Redis는 `fork()` 시스템 호출을 사용하여 자식 프로세스를 생성
    - 자식 프로세스가 스냅샷을 생성하는 동안 메인 프로세스는 계속해서 요청을 처리하기에 서비스 중단 없이 스냅샷을 생성 가능
- `BGSAVE`와 메모리 사용
    - 자식 프로세스가 RDB 파일 생성중, 쓰기 요청 인입시 메인 프로세스는 써야할 데이터가 위치한 메모리 공간을 복사하여 복사된 공간에 쓰기 수행 
    - 자식 프로세스 생성 후, Redis에서 쓰기 작업이 많아지면, 변경된 데이터로 인해 많은 메모리 페이지가 복사되고 이로인해 전체 메모리 사용량을 증가 
        - 특히, 대량의 쓰기 작업이 발생하는 경우, 메모리 사용이 급증할 수 있음

### 장점
- 빠른 로딩 속도
  - 데이터가 압축된 스냅샷으로 저장되어 비교적 스냅샷 파일 크기가 작음 
  - 따라서 Redis 에 장애가 발생하여 재시작시, 스냅샷 파일 스캔 및 로딩 속도가 빠름
- 디스크 I/O가 적음
  - 주기적인 스냅샷만 기록하므로 일반적인 작업 중에는 I/O가 적음

### 단점
- 데이터 손실 가능성
    - 마지막 스냅샷 저장 이후, 다음 스냅샷 저장 전 Redis가 비정상 종료되면 그 사이의 데이터는 유실될 수 있음.
- 스냅샷 생성 시 CPU와 메모리 사용이 증가
    - 스냅샷 생성 과정에서 시스템 자원을 많이 소모할 수 있음.
- 스냅샷 생성에 시간이 오래 걸릴 수 있음
    - 특히 대용량 데이터의 경우, 스냅샷 생성 시간이 길어져 서비스에 영향

### 주의점
- 적절한 스냅샷 주기 설정 필요
    - 데이터 손실과 자원 사용 간의 균형을 맞춰야 함
- 대용량 데이터 처리 시 주의 필요
  - 스냅샷 생성 시간이 길어져 서비스에 영향 줄 수 있음

### 설정값
- `save`: RDB 스냅샷 주기를 설정
    - e.g. `save 900 1` : 900초마다 최소 1개의 변경이 있을 때 스냅샷 생성


# AOF(Append On File)
- 모든 쓰기 명령을 로그 파일(AOF 파일)에 기록
    - 각 쓰기 명령이 순차적으로 기록되어 데이터 변경 사항을 보존함
- 서버 재시작 시 AOF 파일을 다시 재생하여 데이터를 복원
- appendfsync 옵션(e.g. always, everysec)에 따라 데이터 손실 가능
  
### 장점
- 데이터 무손실 복구
  - 모든 쓰기 작업이 실시간으로 기록되므로, Redis 가 어떤 시점에 비정상 종료되든 상관없이 데이터 무손실 복원 가능
  - RDB는 마지막 스냅샷 이후의 변경사항이 유실될 수 있는 반면, AOF는 지속적으로 모든 변경을 기록함. 따라서 데이터 손실이 없음
- 빠른 AOF 파일 생성 속도
  - 마지막 수행된 쓰기 명령어만 append하기 때문에 log write 속도가 빠름
- AOF 파일 편집을 통한 데이터 선택적 복원
    - AOF 파일은 텍스트 형식이므로, 필요에 따라 기록되어있는 쓰기 명령들을 수동으로 편집 가능
    - 이를 통해, 데이터 복원시 제외하고 싶은 명령어를 삭제후 복원 가능
      - e.g. flush all 을 잘못 날려 모든 데이터가 삭제되었다면, AOF 파일에서 flush all 명령어만 삭제후 Reids 재구동해 데이터 복원 가능

### 단점
- AOF 파일의 크기가 큼
  - 모든 쓰기 명령을 기록하므로 AOF 파일 크기가 커질 수 있음.
  - 이로인해, 디스크 사용량이 증가
- 느린 로딩 속도
  - 쓰기 명령어를 하나하나 다시 수행해줘야 하므로 로딩에 오래 걸림

### Rewrite
- AOF 파일 크기가 과도하게 커지는것을 방지하기 위한 장치
- AOF 파일이 특정 시점에 사이즈 제한값보다 커진다면 Redis의 현재 메모리 정보를 다시 AOF 파일에 작성
  - e.g. key:Foo 에 대한 쓰기 작업이 100번 수행되어 AOF 파일에도 100개의 쓰기 명령어가 기록되어있다. AOF Rewrite 수행하며 100 개의 쓰기 작업이 수행된 결과값인 현재 메모리에 저장되어 있는 key:Foo 의 상태만 AOF파일에 저장
  - 백그라운드에서 실행되며, 서비스 중단 없이 수행됨
- rewrite는 설정한 주기 또는 AOF 파일 크기가 설정된 임계값을 초과할 때 자동으로 수행됨
  - `auto-aof-rewrite-percentage 100` : AOF 파일 사이즈가 100% 이상 커지면 rewrite trigger 
  - `auto-aof-rewrite-min-size 64mb` : AOF 파일 사이즈가 64mb 이하면 rewrite skip (파일이 작을때 rewrite가 자주 발생하는 것 방지)

### 주의점
- AOF 활성화시, 디스크 성능 고려 필요
  - AOF 파일에 대한 쓰기 작업을 지속적으로 수행해야하므로 디스크 성능이 중요

### 설정값
- `appendonly`: AOF 기능 활성화 여부 (`yes`/`no`)
- `appendfsync`: AOF 파일 동기화 정책 설정
  - `always`: 각 쓰기 명령마다 즉시 파일에 동기화. 가장 안전하지만, 디스크 I/O가 많아 성능에 영향을 줄 수 있음.
  - `everysec`: 매 초마다 파일에 동기화. 성능과 데이터 안전성 간의 균형을 맞춘 기본 설정
  - `no`: 동기화를 명시적으로 수행하지 않음. 성능은 좋지만, 시스템 충돌 시 데이터 손실 위험


# Usa case
### RDB를 선택하는 경우
- 빠른 복구가 중요한 경우:
  - RDB는 데이터가 압축된 스냅샷으로 저장되어 복구 속도가 빠름.
- 디스크 I/O를 최소화하고 싶은 경우:
  - RDB는 주기적으로만 디스크에 기록하므로, 일반적인 작업 중에는 디스크 I/O가 적음.
- 데이터 손실이 어느 정도 허용 가능한 경우:
  - 특정 시점의 스냅샷을 저장하므로, 마지막 스냅샷 이후의 데이터는 유실될 수 있음.

### AOF를 선택하는 경우
- 데이터 무손실이 필요한 경우
  - AOF는 모든 쓰기 명령을 기록하여 데이터 손실이 거의 없음.
- 데이터 변경이 빈번한 경우:
  - AOF는 지속적으로 모든 변경을 기록하므로, 최신 데이터 상태를 유지할 수 있음.
- 데이터 파일의 편집이 필요한 경우:
  - AOF 파일은 텍스트 형식으로, 수동으로 편집할 수 있음.

### RDB와 AOF 함께 사용하는 경우
* RDB와 AOF 방식의 장단점을 상쇄하기 위해 두 가지 방식을 혼용해서 사용하는 것을 권장
* 주기적으로 RDB로 백업하면서, 다음 snapshot까지의 저장을 AOF방식으로 수행
* 이렇게 함으로써 서버가 재시작될 때 백업된 RDB 데이터로 복구하고, 비교적 적은 양의 AOF 로그만 읽어드리면 되기 때문에 로딩 속도도 빠르고 데이터의 유실도 방지 가능


# Persistence 기능이 꺼져 있는 마스터의 데이터 유실 문제
### 데이터 유실 시나리오
- Persistence 비활성화된 마스터
  - 마스터 노드가 RDB와 AOF 둘 다 비활성화된 상태로 운영되는 경우, 모든 데이터는 메모리에만 존재
  - 디스크에 저장되지 않으므로, 마스터가 재시작되면 메모리의 데이터는 모두 사라짐
- 마스터 노드가 Persistence 없이 재시작되거나 장애가 발생하여 데이터가 사라지면, 레플리카 노드는 이 상태를 복제 시도
  - 마스터 노드에 장애가 발생하여 unHealthy 한 상태가 되면 레플리카 노드가 마스터로 승격된다.
  - 하지만 센티널이 장애를 감지하지 못할 정도로 마스터가 빠르게 재시작할 경우 위와같은 상황이 발생 가능하다.
- 레플리카가 마스터의 빈 상태를 복제하여, 모든 데이터를 잃게 됨.
- 결과적으로, 전체 클러스터에서 데이터가 유실

### Solution
- 마스터 노드 Persistence 활성화
- 마스터 노드의 자동 재시작 기능 비활성화

> Reference
> * https://medium.com/garimoo/redis-documentation-1-%EB%A6%AC%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-7bb903189218
> * https://velog.io/@pjh612/Redis%EC%9D%98-%EB%B0%B1%EC%97%85RDB-AOF-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0
> * https://inpa.tistory.com/entry/REDIS-%F0%9F%93%9A-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%98%81%EA%B5%AC-%EC%A0%80%EC%9E%A5%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%9D%98-%EC%98%81%EC%86%8D%EC%84%B1
> * https://dgjinsu.tistory.com/45
