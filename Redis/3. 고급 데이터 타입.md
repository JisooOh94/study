# 셋(SET)
### 특징
* 순서가 없고, 동일한 문자열이 없는 콜렉션
* Set의 모든 Element 값이 Integer인 경우, Set 메모리 영역은 줄어든다.
* 전체 Element 갯수는 set-max-intset-entries 설정 만큼 커질 수 있다.
* 최대 Element 갯수 : 232-1
* 사용예 - 데이터의 필터링, 그룹핑 등

### 커맨드
* SADD key value1 value2 ... : key에 해당하는 Set에 value 값을 저장한다. Set에 이미 존재하는 element를 추가하는 경우, 무시하고 추가된 엘리먼트 갯수를 리턴한다.
```
127.0.0.1:6379> SADD user:max:favorite_artists "Max" "Bravo"
(integer) 2
127.0.0.1:6379> SADD user:hugo:favorite_artists "Max" "Punk" "Kooks"
(integer) 3
```

* SINTER key1 key2 ... : 하나 이상의 Set을 받아, 모든 Set에 공통으로 존재하는 Element를 배열로 리턴한다 (교집합)
```
127.0.0.1:6379> SINTER user:max:favorite_artists user:hugo:favorite_artists
1) "Max"
```

* SDIFF key1 key2 ... : 하나 이상의 Set을 받아, key1 Set에 해당되는 모든 Element 중 다른 Set(key2 ...)에 존재하지 않는 Element를 반환한다. (차집합)
```
127.0.0.1:6379> SDIFF user:max:favorite_artists user:hugo:favorite_artists
1) "Bravo"
 
127.0.0.1:6379> SDIFF user:hugo:favorite_artists user:max:favorite_artists
1) "Punk"
2) "Kooks"
```

* SUNION key1 key2 ... : 하나 이상의 Set을 받아, 모든 Set의 모든 Element를 하나의 배열로 모아 리턴한다. 결과에 중복된 Element는 존재하지 않는다. (합집합)
```
 127.0.0.1:6379> SUNION user:max:favorite_artists user:hugo:favorite_artists1) "Max"2) "Bravo"3) "Punk"
4) "Kooks"
```

* SRANDMEMBER key : key에 해당하는 set에서 무작위로 하나의 element를 뽑는다.
```
 127.0.0.1:6379> SRANDMEMBER user:max:favorite_artists
1) "Max"
 
 127.0.0.1:6379> SRANDMEMBER user:max:favorite_artists
1) "Bravo"
```

* SISMEMBER key value : key에 해당하는 set에서 value에 해당하는 element가 존재하는지 확인한다. 있으면 1, 없으면 0을 리턴한다.
```
 127.0.0.1:6379> SISMEMBER user:max:favorite_artists "MAX"(integer) 1
```

* SREM key value1 value2... : key에 해당하는 set에서 입력받은 value에 해당하는 모든 element를 삭제한다. 삭제된 element의 수만큼 값을 리턴한다.
```
 127.0.0.1:6379> SREM user:hugo:favorite_artists "Punk" "Kooks"
(integer) 2
```

* SMEMBERS key : key에 해당하는 set의 모든 element를 배열로 리턴한다.
```
 127.0.0.1:6379> SMEMBERS user:max:favorite_artists1) "Max"2) "Bravo"
```

# 정렬된 셋(Sorted SET)
### 특징
* 정렬된 셋의 모든 Element는 연관 점수를 가진다. 이 점수에 의해서 정렬된, 중복 문자열이 없는 콜렉션이다.
* 동일한 연관 점수를 가진 Element인 경우, 사전 편집 순서(알파벳 수선소)대로 정렬할 수 있다.
* 점수로 Element를 검색하기 때문에 기본적으로 Set보다는 빠르지 않다.
* 내부 구현은 2개의 분리된 데이터 구조로 되어있다
    * zset-max-ziplist-entries와 zset-max-ziplist-value 설정을 기반으로 하는 Ziplist
    * 해시 데이블이 존재하는 Skiplist
### 커맨드
* ZADD key score1 value1 score2 value2 ... : key에 해당하는 정렬된 set에 score와 value로 이루어진 element를 저장한다. 
```
 127.0.0.1:6379> ZADD leaders 100 "A" 101 "B"
(integer) 2
 127.0.0.1:6379> ZADD leaders 101 "C" 102 "D" 103 "E"
(integer) 3
```

* ZREVRANGE key start_idx end_idx
    * key에 해당하는 정렬된 set을 score 기반으로 start_idx 부터 end_idx에 해당되는 element 배열을 리턴받는다. (end_idx에 음수를 주면 끝 element부터 카운트 된다. -1이면 제일 마지막 element를 의미)
    * ZREVRANGE는 score 기준 내림차순으로 리턴한다. (10 → 1). 동일 score의 경우 알파벳순 내림차순으로 정렬한다 (Z → A)
    * ZRANGE는 ZREVRANGE와 반대되는 커맨드.
    * 만약, score를 보고 싶은 경우에는 WITHSCORES 키워드를 사용해 각 element의 score도 확인이 가능하다. 
```
 127.0.0.1:6379> ZREVRANGE leaders 0 -1
1) "E"
2) "D"
3) "C"
4) "B"
5) "A"
 
 127.0.0.1:6379> ZREVRANGE leaders 0 -1 WITHSCORES
 1) "E"
 2) "103"
 3) "D"
 4) "102"
 5) "C"
 6) "101"
 7) "B"
 8) "101"
 9) "A"
10) "100"
```

* ZREM key value1 value2 ... : key에 해당하는 정렬된 set에 value에 해당되는 element를 삭제 한다. 삭제된 element수만큼 값을 리턴한다.
```
 127.0.0.1:6379> ZREM leaders "A" "B" "F"
(integer) 2
```

* [ZSCORE | ZRANK | ZREVRANK] key value
    * ZSCORE : key에 해당되는 정렬된 set에서 value에 해당되는 element의 score를 가져온다.
    * ZRANK : key에 해당되는 정렬된 set에서 value에 해당되는 element의 순위를 가져온다 (score 오름차순 정렬)
    * ZREVRANK : key에 해당되는 정렬된 set에서 value에 해당되는 element의 순위를 가져온다 (score 내림차순 정렬)
```
 127.0.0.1:6379> ZREVRANGE leaders 0 -1 WITHSCORES
1) "E"
2) "103"
3) "D"
4) "102"
5) "C"
6) "101"
 127.0.0.1:6379> ZSCORE leaders "E"
"103"
 127.0.0.1:6379> ZRANK leaders "E"
(integer) 2
 127.0.0.1:6379> ZREVRANK leaders "E"
(integer) 0
```


# 비트맵(BITMAP)
### 특징
* 레디스의 실제 데이터타입은 아니다. 내부적으로는 문자열 타입이다.
* 문자열의 Bit 연산자 집합이라고 말할 수 있다.
* Bit를 0 또는 1로 저장할 수 있는 Bit 열.
* Redis 문서에서 Bitmap 인덱스를 Offset으로 나타낸다.
* 메모리 효율이 좋다
* 빠른 데이터 검색을 지원한다
* 2^32 Bit(40억 bit 이상) 까지 저장할 수 있다.


### Bitmap과 Set의 비교
* 전제 조건
    * 특정 일자에 웹사이트를 방문한 모든 사용자 ID를 저장하는 시나리오
    * 전체 사용자 : 5백만
    * 각 사용자 ID : 4Byte (32Bit)
    * 해당일 방문자가 2백만 인 경우

| Redis key	| Data Type	| 사용자당 Bit 크기	| 저장된 사용자	| 전체 메모리 |
|:----------:|:----------:|:----------:|:----------:|:----------:|
| visits:2015-01-01	| Bitmap	| 1Bit	| 5백만	| 1 * 5,000,000 bits = 625KB |
| visits:2015-01-01	| Set	| 32Bit	| 2백만	| 32 * 2,000,000 bits = 8MB |




* 만약 전체 사용자에 비해, 방문자 수가 월등히 적은 경우에는 Set 보다 못한 결과를 낳는다.
* 해당일 방문자가 100명인 경우

| Redis key |	Data Type	| 사용자당 Bit 크기	| 저장된 사용자	| 전체 메모리 |
|:-----------:|:-----------:|:-----------:|:-----------:|:-----------:|
| visits:2015-01-01	| Bitmap	| 1Bit	| 5백만	| 1 * 5,000,000 bits = 625KB | 
| visits:2015-01-01	| Set	| 32Bit	| 100	| 32 * 100 bits = 3.125KB |


### 커맨드
* SETBIT key offset value
    * key에 해당하는 Bitmap의 offset에 value(1 또는 0) 값을 Set 한다.
    * return되는 값은 해당 offset에 저장되어있는 value가 return 된다.
```
 127.0.0.1:6379> SETBIT visits:2015-01-01 10 1
(integer) 0
 127.0.0.1:6379> SETBIT visits:2015-01-01 15 1
(integer) 0
 127.0.0.1:6379> SETBIT visits:2015-01-02 10 1
(integer) 0
 127.0.0.1:6379> SETBIT visits:2015-01-02 11 1
(integer) 0
 127.0.0.1:6379> SETBIT visits:2015-01-02 12 1
(integer) 0
```

* GETBIT key offset
    * key에 해당하는 Bitmap의 offset에 저장되어 있는 value(1 또는 0) 값을 return 한다.
```
 127.0.0.1:6379> GETBIT visits:2015-01-01 10
(integer) 1
 127.0.0.1:6379> GETBIT visits:2015-01-02 15
(integer) 0
```

* BITCOUNT key
    * key에 해당하는 Bitmap의 offset value가 1로 되어진 모든 Bit의 갯수를 리턴한다.
```
 127.0.0.1:6379> BITCOUNT visits:2015-01-01
(integer) 2
 127.0.0.1:6379> BITCOUNT visits:2015-01-02
(integer) 3
```

* BITOP [OR|AND|XOR|NOT] dest_key source_key1 source_key2 ...
    * source_key에 해당되는 Bitmap들의 bit에 대해서 논리연산(OR/AND/XOR/NOT)을 수행한 결과 값을 dest_key에 저장한다.
```
127.0.0.1:6379> BITOP OR visits_or visits:2015-01-01 visits:2015-01-02
(integer) 2
127.0.0.1:6379> BITCOUNT visits_or
(integer) 4
127.0.0.1:6379> BITOP AND visits_and visits:2015-01-01 visits:2015-01-02
(integer) 2
127.0.0.1:6379> BITCOUNT visits_and
(integer) 1
```


# 하이퍼로그로그(HyperLogLog)
### 특징
* 하이퍼로그로그 역시 레디스의 실제 데이터 타입은 아니고, 알고리즘에 해당된다. (redis version 2.8.9 부터 소개됨)
* Set에 존재하는 고유 Element 개수를 높은 근사치로 제공하기 위해 확률화를 사용하는 알고리즘이다.
* 하나의 키당 아주 작은 메모리(최대 12KB의 메모리)를 사용하며 항상 O(1)로 동작한다.
* 0.81%의 표준오차를 가진다.
* 커맨드는 PFADD, PFCOUNT, PFMERGE 세 개의 커맨드만 존재한다.


### HyperLogLog과 Set의 비교
* 전제 조건
    * 시간당 사이트의 고유 방문자수를 계산할 때의 메모리 사용량
    * 시간당 평균 100,000명 방문
    * 각 사용자 ID : 32Byte 문자열 (ex: de305d54-75b4-431b-adb2-eb6b9e546014 ...)
    * 각 시간 별 방문자수를 확인하기 위해 시간 단위로 고유 redis_key를 가진다.

| Data Type	| 한 시간 동안 사용할 메모리	| 하루 동안 사용할 메모리	| 한 달 동안 사용할 메모리 |
|:---------:|:---------:|:---------:|:---------:|
| HyperLogLog	| 12KB	| 12KB * 24 = 288KB	| 288KB * 30 = 8.4MB |
|  Set	| 32bytes * 100,000 = 3.2MB	| 3.2MB * 24 = 76.8MB	| 76.8MB * 30 = 2.25GB |

### 커맨드
* PFADD key value1 value2 ...
    * key에 해당하는 HyperLogLog에 value에 해당되는 문자열을 추가한다.
    * HyperLogLog의 개수가 변경되면 1을 리턴하고, 그렇지 않으면 0을 리턴한다.
```
127.0.0.1:6379> PFADD visits:2015-01-01 "carl" "max" "hugo" "arthur"
(integer) 1
127.0.0.1:6379> PFADD visits:2015-01-01 "max" "hugo"
(integer) 0
127.0.0.1:6379> PFADD visits:2015-01-02 "max" "kc" "hugo" "renata"
(integer) 1
```

* PFADD key value1 value2 ...
    * key에 해당하는 HyperLogLog에 value에 해당되는 문자열을 추가한다.
    * HyperLogLog의 개수가 변경되면 1을 리턴하고, 그렇지 않으면 0을 리턴한다.
```
127.0.0.1:6379> PFCOUNT visits:2015-01-01
(integer) 4
127.0.0.1:6379> PFCOUNT visits:2015-01-02
(integer) 4
127.0.0.1:6379> PFCOUNT visits:2015-01-01 visits:2015-01-02
(integer) 6
```

* PFMERGE dest_key source_key1 source_key2 ...
    * source_key에 해당되는 HyperLogLog의 모든 element값을 병합해서 dest_key에 저장한다.
```
127.0.0.1:6379> PFMERGE visits:total visits:2015-01-01 visits:2015-01-02
OK
127.0.0.1:6379> PFCOUNT visits:total
(integer) 6
```







