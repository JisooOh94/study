# pub/sub
* 메시지를 특정 수신자에게 직접 발송하지 못하는 곳에서 쓰이는 패턴
* publisher / subcriber 같은 채널을 리스닝 하고있다면 발송자는 채널에 메시지를 보내고 구독자는 발송자의 메시지를 받는다.
### Command
* PUBLISH : 메세지를 레디스 채널에 보내고, 메시지를 받은 클라이언트 개수를 리턴한다.
* SUBSCRIBE : 클라이언트가 하나이상의 채널을 구독한다
* UNSUBSCRIBE : 하나이상의 채널에서 클라이언트를 구독해지한다
    * 레디스 클라이언트가 SUBSCRIBE나 PSUBSCRIBE커맨드를 실행하면 SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE 커맨드를 제외한 다른 커맨드를 받지않음
* PUBSUB : 레디스의 Pub/Sub상태를 조사한다.
* NUMSUB : 특정 채널과 접속한 클라이언트 개수를 리턴
* NUMPAT : 채널에 접속한 클라이언트를 리턴
# 트랜잭션
* 순서대로 원자적으로 실행되는 커맨드의 열이다.
### Command
* MULTI : 트랜잭션 시작
* EXEC : 트랜잭션의 끝
* MULTI - EXEC 사이의 커맨드는 클라이언트의 큐에 쌓이고 EXEC 가 실행될때 서버로 전달
* DISCARD : 트랜잭션 실행 하지 않음
* WATCH : 주시받는 키를 추가함, 트랜잭션을 조건부로 실행할때 사용
* UNWATCH : 주시목록에 있는 키를 제거함
# 파이프라인
* 커맨드를 그룹화하여 RTT값을 줄일 수 있다.
* 파이프 라인으로 전달된 레디스 커맨드는 독립적이어야 한다.
* 순차적으로 서버에서 실행되지만 트랜잭션 처리는 되지않는다.
* 네트워크 병목 현상을 줄일수 있기때문에 유용하다.
* 하나의 큰파이프라인 보다는 여러개의 파이프라인을 사용하는 것이 좋은 아이디어가 될수 있다.
# 스크립트
* 레디스를 확장하기 위해 루아 언어를 이용하여 스크립트 사용가능
* 예전에는 기능 확장을 위해 C로 작성된 소스 코드를 수정하는 것 뿐이었으나, 루아 스크립트를 이용해 확장이 가능해졌다 (버전 2.6 이후)
### 루아스크립트
* 루아 스크립트는 원자적으로 실행됨 (루아스크립트가 실행 되는 동안 레디스 서버는 블록됨)
    * 기본 5초의 타임아웃 (lua-time-limit 설정 수정)
    * 루아 스크립트 타임아웃이 발생하면 모든 커맨드에 BUSY 메시지를 보낸다.
    * 실행 취소하여 정상으로 만드러면 SCRIPT KILL, SHUTDOWN NOSAVE 호출을 하여 동작중인 스크립트를 종료해야한다.
### 루아 기본문법
* 주석 : --
* 글로벌 변수 선언 : x = 123
* 지역변수 선언 local  y = 456
* 함수정의
```
function hello()
  return "hello"
end
```

* 순회자
```
for i = 1, 10 do
	print(i)
end
```

* 조건문
```
if x == 123 then
	print("a")
else
	print("b")
end
```

* 문자열 연결
```
 print("abc" .. "de")
```

* 테이블 배열 사용하기 (루아의 배열은 1부터 시작함)
```
data_types = {1.2.3}
print(data_type[1]) => 1
```

* 테이블을 해시로 사용하기
```
hash_map = { a = 123, b = 456 , c = 789 }
print(hash_map["a"]) => 123
```

# 기타 커맨드
### INFO
* 레디스 버전과 운영체제, 연결된 클라이언트, 메모리 사용량, 저장소, 복제본, 키스페이스에 대한 정보를 포함한 모든 레디스 서버 통계를 리턴한다.
* 사용할 수 있는 모든 섹션을 보여준다 (메모리, 저장소, CPU, 커맨드, 클러스터, 클라이언트, 복제본)
* 매개변수로 섹션이름을 명세해 결과를 제한 할수도 있음
* ex) INFO memory
* ex) INFO cpu

### DBSIZE
* 레디스 서버에 존재하는 키 개수를 나타낸다.
* ex ) DBSIZE

### DEBUG SEGFAULT
* 올바르지 않은 메모리 접근을 수행해 레디스 서버 프로세스를 종료한다.
* 어플리케이션 개발중 버그를 시뮬레이션 할때 유용하다.
* ex ) DEBUG SEGFAULT

### MONITOR
* 레디스 서버가 처리하는 모든 커맨드를 실시간으로 보여준다.
* 디버깅 시 매우 유용하지만, 비용이 소요된다.
* MONITOR 커맨드가 레디스의 성능을 50% 이상까지 떨어뜨릴수 있다고 언급함

### CLIENT LIST
* 클라이언트에 대한 관련 정보와 통계뿐 아니라 서버에 연결된 모든 클라이언트 목록을 리턴한다
* IP주소, 이름, 유휴시간

### CLIENT SETNAME
* 클라이언트 이름을 변경한다
* 디버깅을 목적으로 할때 유용하다.

### CLIENT KILL
* 클라이언트 연결을 종료한다
* IP나 포트, ID, 타입으로 클라이언트 연결을 종료 할 수 있다.
* ex ) CLIENT KILL ADDR 127.0.0.1:51167
* ex ) CLIENT KILL ID 22
* ex ) CLIENT KILL TYPE slave

### FLUSHALL
* 레디스의 모든키를 삭제, 삭제된 키는 복구 불가능

### RANDOMKEY
* 존재하는 키 이름 중 무작위로 선택한 하나의 키 이름을 리턴
* ex ) RANDOMKEY

### EXPIRE
* 특정 키의 타임아웃을 초단위로 설정

### EXPIREAT
* 유닉스 타임스탬프 기반으로 특정키의 타임아웃을 설정
* 키가 존재하면 1, 존재하지않으면 0

### TTL
* 타임아웃 값이 있는 키의 남아있는 생존 시간을 초단위로 리턴한다
* TTL 값이 없으면 -1
* 키가 존재하지 않으면 -2

### PTTL
* TTL과 동일하지만 리턴값은 초가 아니라 밀리초

### PERSIST
* 특정키에 주어진 현존 타임아웃을 제거한다.

### SETTEX
* 특정키에 값을 저장할때, 만료시간도 함께 원자적으로 설정한다.
* SET과 EXPIRE  커맨드의 조합니다.
* ex ) SETTEX mykey 30 value

### DEL
* DEL 커맨드는 하나이상의 키를 레디스에서 삭제하고 삭제된 키의 개수를 리턴한다.

### EXISTS
* 특정 키가 존재하면 1, 특정키가 존재하지 않으면 0

### PING
* PONG 문자열 리턴, 서버클라이언트 연결 테스트

### MIGRATE
* 특정 키를 대상 레디스 서버로 옮긴다.
* 키를 옮기는 동안 원본 레디스 서버와 키를 저장할 레디스 서버가 둘다 블록됨.
* 레디스 서버에 키가 이미 존재하면 해당 커맨드는 실패한다. (REPLACE 커맨드를 쓰면 가능)
* ex ) MIGRATE host port key destination-db timeout [COPY] [REPLACE]
    * COPY : 로컬 레디스 서버에 키를 유지하고 키를 저장할 레디스 서버에 키의 복사본을 생성한다.
    * REPLACE : 키를 저장할 레디스 서버에 이미 동일한 키가 존재하더라도 키를 교체한다.

### SELECT
* 다중 데이터 베이스의 개념을 가지고 있으나, 다중데이터 베이스 사용하는 것을 추천하지 않음
* 하나의 서버를 사용하는것 보다 여러개의 redis-server 프로세스를 사용하는것이 좋다.
* 다중 프로세스는 다중  CPU 코어를 사용할 수 있고 , 병목을 좀더 잘 해결할수 있음
* SELECT 커맨드는 클라이언트가 연결된 현재의 데이터베이스를 변경한다.

### AUTH
* 레디스에 연결할 수 있는 클라이언트를 허가 하는데 사요오딘다.
* 레디스 서버에서 허가정책을 사용하기로 하면, 클라이언트는 허가키를 포함한 AUTH 커맨드를 실행해야만 사용가능하다.
* ex) AUTH mysecret
* ex ) GET mykey

### SCRIPT KILL
* 스크립트가 더 이상 쓰기작업을 수행하지 않으면 루아스크립트 실행을 종료한다.
* 루아 스크립트가 쓰기작업을 수행하는 중에서는 루아스크립트가 종료되지않는다.
* SHUTDOWN NOSAVE 를 호출하면 종료된다.
* 리턴값
    * OK
    * NOBUSY : 현재 실행중인 스크립트가 없음
    * UNKILLABLE : 루아스크립트가 쓰기 커맨드를 이미 실행하고있음

### SHUTDOWN
* 모든 클라이언트 종료, 최대한 데이터를 저장하려고 한후, 레디스를 종료
* 매개변수
    * SAVE : 저장기능을 활성화 하지 않더라도, 레디스가 dump.rdb라는 파일에 모든 데이터를 저장
    * NOSAVE : 저장기능이 활성화 돼 있더라도, 레디스 서버가 데이터를 디스크에 저장하지 않도록 한다.

### OBJECT ENCODING
* 주어진 키에서 사용중인 인코딩 값을 리턴한다.
* ex) HSET myhash field value

# 데이터 타입의 최적화
* 모든 데이터 타입은 메모리를 저장하거나 성능을 높이는 다양한 인코딩을 사용할수있다.
    * ex) 숫자만 갖는 문자열, 글자만 갖는 문자열은 서로 다른 인코딩을 사용
* redis.conf파일은 모든 설정 지시자를 가지고있음
* CONFIG커맨드나 커맨드 라인 옵션으로 레디스 설정을 명세할 수 있지만 redis.conf 파일을 사용하는 것이 일반적인 방식임

### 문자열
* int: 64비트 signed(부호가 있는) 정수로 문자열을 표현할때 int가 사용됨
* embstr : 40바이트보다 작은 문자열을 표현할때 embstr이 사용됨
* raw : 40바이트보다 큰 문자열을 표현할떄 raw가 사용됨
* ex ) 12345 → int, test → string , testtesttesttesttesttesttesttesttesttesttesttest → embstr

### 리스트
* ziplist : 리스트 크기의 엘리먼트가 list-max-ziplist-entries 설정보다 작고, 리스트의 개별 엘리먼트 바이트가 list-max-ziplist-value 설정보다 작으면 집리스트 사용됨
* linked list : 리스트 크기의 엘리먼트가 list-max-ziplist-entries 설정보다 크거나, 리스트의 개별 엘리먼트 바이트가 list-max-ziplist-value설정보다 크면 연결 리스트가 사용됨

### 셋
* intset : 모든 엘리먼트가 정수고, set의 개수가 set-max-intset-entries 설정보다 작으면 intset이 사용됨
* hashtable : set의 엘리먼트 중 하나라도 정수가 아니거나, set의 개수가 set-max-intset-entries 설정보다 크면 해시테이블이 사용된다.

### 해시
* ziplist : hash의 필드 개수가 hash-max-ziplist-entires 설정보다 작고 , hash의 필드 이름과 값이 hash-max-ziplist-value 설정보다 작으면 ziplist가 사용됨
* hashtable : hash 의 필드개수가 has-max-ziplist-entries 설정보다 크거나, 해시의 필드 값 중 하나라도 hash-max-ziplist-value 설정보다 크면 해시 테이블이 사용된다.

### 정렬된셋
* ziplist : hash의 필드 개수가 set-max-ziplist-entires 설정보다 작고 ,정렬된 셋의 필드 이름과 값이 zseth-max-ziplist-value 설정보다 작으면 ziplist가 사용됨
* skiplist와 hashtable : 정렬된 셋의 개수가 set-max-ziplist-entries 설정보다 크거나 정렬된 셋의 엘리먼트 값 중 하나라도 zset-max-ziplist-value 설정보다 크면 스킵리스트와 해시테이블이 사용된다.

### 메모리 사용 측정
* 각 설정을 통해 메모리 최적화와 성능 두가지를 잡을수 있도록 해야한다
* 해시 : 더 많은 엘리먼트를 소유할수록 성능이 느려짐 O(1)
* 집리스트 : 메모리를 효율적으로 쓰는 이중연결리스트 O(n)
* 각 환경에 따라 설정값을 변경해서 쓰는것이 좋다.