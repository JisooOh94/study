# pub/sub
* 메시지를 특정 수신자에게 직접 발송하지 못하는 곳에서 쓰이는 패턴
* publisher / subcriber 같은 채널을 리스닝 하고있다면 발송자는 채널에 메시지를 보내고 구독자는 발송자의 메시지를 받는다.
### Command
* PUBLISH : 메세지를 레디스 채널에 보내고, 메시지를 받은 클라이언트 개수를 리턴한다.
* SUBSCRIBE : 클라이언트가 하나이상의 채널을 구독한다
* UNSUBSCRIBE : 하나이상의 채널에서 클라이언트를 구독해지한다
    * 레디스 클라이언트가 SUBSCRIBE나 PSUBSCRIBE커맨드를 실행하면 SUBSCRIBE, PSUBSCRIBE, UNSUBSCRIBE, PUNSUBSCRIBE 커맨드를 제외한 다른 커맨드를 받지않음
* PUBSUB : 레디스의 Pub/Sub상태를 조사한다.
* NUMSUB : 특정 채널과 접속한 클라이언트 개수를 리턴
* NUMPAT : 채널에 접속한 클라이언트를 리턴
# 트랜잭션
* 순서대로 원자적으로 실행되는 커맨드의 열이다.
### Command
* MULTI : 트랜잭션 시작
* EXEC : 트랜잭션의 끝
* MULTI - EXEC 사이의 커맨드는 클라이언트의 큐에 쌓이고 EXEC 가 실행될때 서버로 전달
* DISCARD : 트랜잭션 실행 하지 않음
* WATCH : 주시받는 키를 추가함, 트랜잭션을 조건부로 실행할때 사용
* UNWATCH : 주시목록에 있는 키를 제거함
# 파이프라인
* 커맨드를 그룹화하여 RTT값을 줄일 수 있다.
* 파이프 라인으로 전달된 레디스 커맨드는 독립적이어야 한다.
* 순차적으로 서버에서 실행되지만 트랜잭션 처리는 되지않는다.
* 네트워크 병목 현상을 줄일수 있기때문에 유용하다.
* 하나의 큰파이프라인 보다는 여러개의 파이프라인을 사용하는 것이 좋은 아이디어가 될수 있다.
# 스크립트
* 레디스를 확장하기 위해 루아 언어를 이용하여 스크립트 사용가능
* 예전에는 기능 확장을 위해 C로 작성된 소스 코드를 수정하는 것 뿐이었으나, 루아 스크립트를 이용해 확장이 가능해졌다 (버전 2.6 이후)
### 루아스크립트
* 루아 스크립트는 원자적으로 실행됨 (루아스크립트가 실행 되는 동안 레디스 서버는 블록됨)
    * 기본 5초의 타임아웃 (lua-time-limit 설정 수정)
    * 루아 스크립트 타임아웃이 발생하면 모든 커맨드에 BUSY 메시지를 보낸다.
    * 실행 취소하여 정상으로 만드러면 SCRIPT KILL, SHUTDOWN NOSAVE 호출을 하여 동작중인 스크립트를 종료해야한다.
### 루아 기본문법
* 주석 : --
* 글로벌 변수 선언 : x = 123
* 지역변수 선언 local  y = 456
* 함수정의
```
function hello()
  return "hello"
end
```

* 순회자
```
for i = 1, 10 do
	print(i)
end
```

* 조건문
```
if x == 123 then
	print("a")
else
	print("b")
end
```

* 문자열 연결
```
 print("abc" .. "de")
```

* 테이블 배열 사용하기 (루아의 배열은 1부터 시작함)
```
data_types = {1.2.3}
print(data_type[1]) => 1
```

* 테이블을 해시로 사용하기
```
hash_map = { a = 123, b = 456 , c = 789 }
print(hash_map["a"]) => 123
```