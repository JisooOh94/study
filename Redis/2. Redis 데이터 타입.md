# 문자열
* 많은 커맨드를 가지며, 여러 목적으로 사용하기 때문에 레디스에서 가장 다양한 데이터 타입이다.
* 문자열은 정수(Integer), 부동소수점(float), 텍스트 문자열, 비트맵 값이 기반.
* 문자열 텍스트(XML, JSON, HTML, 원문 텍스트)나 정수, 부동소수점, 바이너리 데이터(비디오, 이미지, 오디오 파일)와 같이 어떠한 종류의 데이터라도 저장 할 수 있음
* 문자열 값은 텍스트 또는 바이너리 데이터의 512MB를 초과할 수 없음

### 문자열과 관련된 사용 예시
* 캐시 메커니즘
    * HTML 페이지와 api 응답에서 이미지, 비디오까지 어떠한 텍스트 또는 바이너리 데이터라도 캐시 할 수 있다.
    * SET, GET, MSET, MGET 커맨드를 이용해 간단한 캐시 시스템을 구현 할 수 있음
* 자동 만료되는 캐시
    * 키의 만료를 자동으로 지원하는 문자열은 SETEX, EXPIRE, EXPIREAT 커맨드를 이용해 튼튼한 캐시 시스템 만들 수 있음
    * 일정 시간 동안 캐시되어야 할 때 매우 유용하다.
* 개수 계산(count)
    * 문자열과 INCR, INCRBY 커맨드를 이용해 쉽게 구현 가능한 개수 계산
    * 페이지 뷰, 비디오 뷰, 좋아요와 같은 것이 그 예시
    * DECR, DECRBY, INCRFLOATBY등의 커맨드를 제공

### redis-cli 문자열 관련 커맨드
* MSET 커맨드
    * 한 번에 다중 키의 값을 저장
* MGET 커맨드
    * 여러 개의 키 값을 한꺼번에 가져올 수 있고, 그 이름은 공백으로 구분
```
 127.0.0.1:6379> MSET first "first key value" second "Second key value"
OK
127.0.0.1:6379> MGET first second
1) "first key value"
2) "Second key value"
127.0.0.1:6379> MGET first
1) "first key value"
127.0.0.1:6379>
```

* EXPIRE
    * 주어진 키에 대한 만료 시간(초 단위)를 추가
    * 만료 시간이 다 되면 자동으로 레디스에서 삭제됨
    * 키 만료 커맨드는 성공적으로 설정되면 1을 리턴하고, 키가 존재하지 않거나 설정할 수 없다면 0을 리턴
* TTL
    * 키 값의 생존 시간
    * 양의 정수: 주어진 키가 살아남을 시간(단위:초)
    * -2: 키가 만료되거나 존재하지 않으면 -2
    * -1: 키가 존재하지만 만료시간을 저장하지 않았다면 -1을 리턴
```
127.0.0.1:6379> SET current_chapter "Chapter 1"
OK
127.0.0.1:6379> EXPIRE current_chapter 10
(integer) 1
127.0.0.1:6379> GET current_chapter
"Chapter 1"
127.0.0.1:6379> TTL current_chapter
(integer) -2
127.0.0.1:6379> GET current_chapter
(nil)
```

* INCR
    * 하나씩 값을 증가, 증가된 값을 리턴
* INCRBY
    * 주어진 숫자만큼 키 값을 증가시키고, 증가된 값을 리턴
* DECR, DECRBY
    * INCR, INCRBY처럼 똑같은 기능이고, 값이 감소시킨다는 것이 유일한 차이점
* INCRBYFLOAT
    * 부동 소수점을 받아 키 값을 증가시킨 후, 새롭게 변경된 값을 리턴

```
127.0.0.1:6379> SET counter 100
OK
127.0.0.1:6379> INCR counter
(integer) 101
127.0.0.1:6379> INCRBY counter 5
(integer) 106
127.0.0.1:6379> DECR counter
(integer) 105
127.0.0.1:6379> DECRBY counter 5
(integer) 100
127.0.0.1:6379> GET counter
"100"
127.0.0.1:6379> INCRBYFLOAT counter 2.4
"102.4"
127.0.0.1:6379>
```

# 리스트
* 레디스의 리스트는 간단한 콜렉션, 스택(stack), 큐(queue)와 같이 동작할 수 있기 때문에 레디스에서는 매우 유연한 데이터 타입
* 많은 이벤트 시스템은 레디스의 리스트를 큐로 사용하는데, 병렬 시스템에서 큐의 엘리먼트를 얻어낼 때 중복으로 얻지 않도록 보장해준다.
* 레디스의 리스트에 블록킹(blocking) 커맨드가 존재하는데,
    * 리스트에 get요청을 했을 때 없으면, 값이 들어올 때까지 기다린다는 의미다.
* 레디스의 리스트는 연결 리스트(linked list)
    * 처음 또는 끝에 삽입할 때는 O(1)로 일정 시간의 성능을 가진다.
    * 리스트에서 마지막 엘리먼트에 접근하는 작업은 O(N), 첫번째 또는 마지막 엘리먼트 접근 시에는 O(1)로 일정시간으로 접근한다.
* 리스트의 엘리먼트 최대 개수
    * 2^32 - 1개 (40억개 이상)

```
127.0.0.1:6379> LPUSH books "Clean Code"
(integer) 1
127.0.0.1:6379> RPUSH books "Code Complete"
(integer) 2
127.0.0.1:6379> LPUSH books "Peopleware"
(integer) 3
127.0.0.1:6379> LLEN books
(integer) 3
127.0.0.1:6379> LINDEX books 1
"Clean Code"
127.0.0.1:6379> LRANGE books 0 1
1) "Peopleware"
2) "Clean Code"
127.0.0.1:6379> RRANGE books 0 1
(error) ERR unknown command 'RRANGE'
127.0.0.1:6379> LPOP books
"Peopleware"
127.0.0.1:6379> RPOP books
"Code Complete"
127.0.0.1:6379> LRANGE books 0 -1
1) "Clean Code" 
```

### redis-cli 리스트 관련 커맨드
* LPUSH
    * 왼쪽에 엘리먼트 삽입
* RPUSH
    * 오른쪽에 엘리먼트 삽입
* LRANGE 시작인덱스 종료인덱스
    * 시작인덱스 ~ 종료인덱스까지 출력
    * 종료인덱스에 -1을 넣으면 다 출력

# 해시
* 해시는 필드를 값으로 매핑 할 수 있음 -> 객체를 저장하는데 훌륭한 데이터 구조
* 해시는 메모리를 효율적으로 쓸 수 있고, 데이터를 빨리 찾을 수 있게 최적화돼 있다.
* 해시에서 필드 이름과 값은 문자열
    * 해시는 문자열을 문자열로 매핑한다.
* 위의 예제에서 살펴 본, article:<id>:headline과 article:<id>:votes는 두 개의 필드가 동일한 객체(즉, 기사)에 속하기 때문에 해시를 사용하는 것이 훨씬 의미가 있다.
* 해시의 최적화 내용은 4장에서 살펴 볼 것임
* 해시는 내부적으로 집리스트(ziplist)또는 해시 테이블(hash table)이 될 수 있다.
    * 집리스트는 메모리에 최적화되어 있고, 일정한 시간 내로 검색이 수행되지는 않는다.
    * 해시테이블은 일정한 시간 내로 검색이 되지만, 메모리 최적화가 이루어지지 않는다.

### redis-cli 해시 관련 커맨드
* HSET
    * 주어진 키의 필드에 값을 저장. HSET key field value
    * 필드에 값이 없으면 저장, 이미 존재하면 덮어씀
* HMSET
    * HSET과 같으나, 다중 필드 값을 키에 저장
    * 필드에 값이 없으면 저장, 이미 존재하면 덮어씀
* HINCRBY
    * 주어진 정수만큼 필드를 증가
* HINCRBYFLOAT
    * 주어진 부동소수점만큼 필드를 증가
* HDEL
    * 해시에서 필드를 삭제
* HGETALL
    * 해시에서 모든 필드 / 값의 쌍으로 이루어진 배열을 리턴

```
127.0.0.1:6379> HSET movie "title" "The Godfather"
(integer) 1
127.0.0.1:6379> HGET movie "title"
"The Godfather"

127.0.0.1:6379> HMSET movie "year" 1972 "rating" 9.2 "watchers" 1000000
OK

127.0.0.1:6379> HGET movie "year"
"1972"

127.0.0.1:6379> HMGET movie "title" "year" "rating" "watchers"
1) "The Godfather"
2) "1972"
3) "9.2"
4) "1000000"

127.0.0.1:6379> HDEL movie "watchers"
(integer) 1

127.0.0.1:6379> HGETALL moviewwwwwwwwwwwww
(empty list or set)

127.0.0.1:6379> HGETALL movie
1) "title"
2) "The Godfather"
3) "year"
4) "1972"
5) "rating"
6) "9.2"
127.0.0.1:6379>
```

### 해시 정리
* 해시에 많은 필드가 존재하고 메모리를 많이 사용한다면, HGETALL 커맨드가 문제를 일으킬 수 있음
    * HGETALL커맨드는 모든 해시 데이터를 네트워크를 통해 전달해야 하므로 레디스를 느리게 할 수 있음
* 이러한 경우, HSCAN 커맨드가 좋은 대안
    * HSCAN은 한 번에 모든 필드를 리턴하지 않는다.
    * 커서와 해시 필드의 값을 한번에 리턴한다.
    * 해시에서 모든 필드를 얻으려면, 리턴된 값이 0이 될때까지 HSCAN 커맨드를 실행해야 한다.

```
127.0.0.1:6379> HSCAN movie 0
1) "0"
2) 1) "title"
   2) "The Godfather"
   3) "year"
   4) "1972"
   5) "rating"
   6) "9.2"
```