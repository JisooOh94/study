# 시계열
* 시간 간격 동안 만들어진 순차적인 값(데이터 포인트)의 연속
    * ex) 시간의 흐름에 따른 신문의 특정 단어나 용어의 사용빈도, 연도별 최저임금, 주가의 일일 변동, 월별 제품 구매량, 기후 변화

# 문자열을 이용한 시계열 구축 예시
* insert 메소드를 통해서 시간단위로 데이터를 증가시킨다. 
* 만료시간을 통해 특정 시간이 지나면 키가 지워지도록 한다.

### 최초 데이터 구성
* 초당, 분당, 시간당, 일당 데이터 저장
```
function TimeSeries(client, namespace) {     
	this.namespace = namespace;     
	this.client = client;     
	this.units = {         
		second: 1,         
		minute: 60,         
		hour: 60 * 60,         
		day: 24 * 60 * 60     
	};
    this.granularities = {         
	'1sec' : { name: '1sec', ttl: this.units.hour * 2, duration: this.units.second },         
	'1min' : { name: '1min', ttl: this.units.day * 7, duration: this.units.minute },         
	'1hour' : { name: '1hour', ttl: this.units.day * 60, duration: this.units.hour },         
	'1day' : { name: '1day', ttl: null, duration: this.units.day }     
	}; 
};
```

### 시간단위로 발생한 이벤트를 등록
* 모든 단위를 순회한후에 key 값에 대해서 값을 1증가 시킨다.
* 만료시간이 있으면 expire 명령어를 넣어준다.
```
TimeSeries.prototype.insert = function(timestampInSeconds) {
    for (var granularityName in this.granularities) {
        var granularity = this.granularities[granularityName];
        var key = this._getKeyName(granularity, timestampInSeconds);
        this.client.incr(key);
        if ( granularity.ttl !== null ) {
            this.client.expire(key, granularity.ttl);
        }
    }
};
```

* 시간단위를 기반으로한 key값을 가져온다.(ex: namespace:1min:0)
```
TimeSeries.prototype._getKeyName = function(granularity, timestampInSeconds) {
    var roundedTimestamp = this._getRoundedTimestamp(timestampInSeconds, granularity.duration);
    return [this.namespace, granularity.name, roundedTimestamp].join(':');
}
```

* 정규화된 타임스탬프를 가져온다.(정밀도가 60인 경우 0에서 60사이의 모든 타임스탬프는 0이다.)
```
TimeSeries.prototype._getRoundedTimestamp = function(timestampInSeconds, precision) {
    return Math.floor(timestampInSeconds/precision) * precision;
};
```

* redis에 입력된 시계열 정보를 가져와 콜백함수에 전달
```
TimeSeries.prototype.fetch = function(granularityName, beginTimestamp, endTimestamp, onComplete) {
    var granularity = this.granularities[granularityName];
    var begin = this._getRoundedTimestamp(beginTimestamp, granularity.duration);
    var end = this._getRoundedTimestamp(endTimestamp, granularity.duration);
    var keys =  [];
    for (var timestamp = begin; timestamp  <= end; timestamp += granularity.duration) {
        var key = this._getKeyName(granularity, timestamp);
        keys.push(key);
    }
    this.client.mget(keys, function(err, replies) {
        var results = [];
        for ( var i = 0; i < replies.length ; i++ ) {
            var timestamp = beginTimestamp + i * granularity.duration;
            var value = parseInt(replies[i], 10) || 0;
            results.push({timestamp: timestamp, value: value});
        }
        onComplete(granularityName, results);
    });
};
```

* 위 라이브러리를 사용예시
```
var redis = require("redis"); 
var client = redis.createClient();
if ( process.argv.length < 3 ) {
    console.log("ERROR");
    process.exit(1);
}

var dataType = process.argv[2];

client.flushall(); // 기존 데이터 모두 삭제

var timeseries = require("./timeseries-" + dataType);  // 라이브러리 모듈 가져오기
var item1Purchases = new timeseries.TimeSeries(client, "purchases:item1"); // 초기 세팅

var beginTimestamp = 0;
item1Purchases.insert(beginTimestamp);     		// 0초 추가
item1Purchases.insert(beginTimestamp + 1);		// 1초 추가
item1Purchases.insert(beginTimestamp + 1);		// 1초 추가
item1Purchases.insert(beginTimestamp + 3);		// 3초 추가
item1Purchases.insert(beginTimestamp + 61);		// 61초 추가

function displayResults(granularityName, results) {
    console.log("Results from " + granularityName + ":");
    console.log("Timestamp \t| Value");
    console.log("-------------- | ------");
    for (var i = 0; i < results.length; i++ ){
        console.log('\t' + results[i].timestamp + '\t| ' + results[i].value);
    }
    console.log();
}

item1Purchases.fetch("1sec", beginTimestamp, beginTimestamp + 4, displayResults);	// 1초단위로 0에서 4초까지의 결과를 출력
item1Purchases.fetch("1min", beginTimestamp, beginTimestamp + 120, displayResults);	// 1분단위로 0에서 120초(0분에서 2분)까지의 결과를 출력
client.quit();
```

### 결과
```
Results from 1sec:
Timestamp       | Value
-------------- | ------
        0       | 1
        1       | 2
        2       | 0
        3       | 1
        4       | 0
Results from 1min:
Timestamp       | Value
-------------- | ------
        0       | 4
        60      | 1
        120     | 0
```

# 해시로 최적화 하기 
* 위의 경우에는 하루동안 총 87865의 키가 생성된다. 
* 1초단위로 86400 (60 * 60 * 24)
* 1분단위로 1440 (60 * 24)
* 1시간단위로 24 (24 * 1)
* 1일단위로 1
* 매일 엄청난 수이며 선형으로 키가 증가하기 때문에 비용이 발생
* 해시를 이용해서 메모리 최적화가 가능
* 해시는 집리스트와 해시테이블로 구성되는데 집리스트 형태로 인코딩되야 메모리 최적화가 가능하다.
* 집리스트는 hash-max-ziplist-entries 보다 작은 필드로  유지, hash-max-ziplist-value 설정보다 필드 값이 작아야 한다.
* 24시간 동안 매초 이벤트 추가 테스트 시 문자열 방식 11MB, 해시 방식 800KB 사용
* 다음 형태의 데이터를 3개의 키 그룹을 사용해서 최적화 할 수 있다.

| 키 이름	| 키 값 |
|:----------:|:----:|
| namespace:1sec:0	| 10 |
| namespace:1sec:1	| 15 |
| namespace:1sec:2	| 25 |
| namespace:1sec:3	| 100 |
| namespace:1sec:40	| 200 |
| namespace:1sec:5	| 300 |


* 해시 분포를 위해 각 시간 단위에 quantity 필드를 추가 (hash-max-ziplist-entries 보다 작게 설정)
```
this.granularities = {
    '1sec' : { name: '1sec', ttl: this.units.hour * 2,
                duration: 1, quantity: this.units.minute * 5},              
    '1min' : { name: '1min', ttl: this.units.day * 7,
                duration: this.units.minute, quantity: this.units.hour * 8},
    '1hour' : { name: '1hour', ttl: this.units.day * 60,
                duration: this.units.hour, quantity: this.units.day * 10 }, 
    '1day' : { name: '1day', ttl: null,
                duration: this.units.day, quantity:this.units.day * 30 }    
};
```

* 필드 필드값 형태로 되므로 추가시에 필드를 가져올 수 있게 한다.
```
 TimeSeries.prototype.insert = function(timestampInSeconds) {
    for (var granularityName in this.granularities) {
        var granularity = this.granularities[granularityName];
        var key = this._getKeyName(granularity, timestampInSeconds);
        var fieldName = this._getRoundedTimestamp(timestampInSeconds, granularity.duration);
        this.client.hincrby(key, fieldName, 1);                                             
        if ( granularity.ttl !== null ) {
            this.client.expire(key, granularity.ttl);
        }
    }
};
```

* quantity 를 기준으로 그룹화하기 위해서 key값을 가져올 수 있도록 한다.
* quantity가 3인 경우 roundedTimestamp 0은 0, 1, 2를 3은 3, 4, 5를 6은 6, 7, 8을 그룹화
```
 TimeSeries.prototype._getKeyName = function(granularity, timestampInSeconds) {
    var roundedTimestamp = this._getRoundedTimestamp(timestampInSeconds, granularity.quantity);
    return [this.namespace, granularity.name, roundedTimestamp].join(':');
}
```

* multi/exec 커맨드를 통해 트랜잭션으로 hget을 실행한다.
```
TimeSeries.prototype.fetch = function(granularityName, beginTimestamp, endTimestamp, onComplete) {
    var granularity = this.granularities[granularityName];
    var begin = this._getRoundedTimestamp(beginTimestamp, granularity.duration);
    var end = this._getRoundedTimestamp(endTimestamp, granularity.duration);
                                                                                                  
    var multi = this.client.multi();                                                              
    for (var timestamp = begin; timestamp  <= end; timestamp += granularity.duration) {
        var key = this._getKeyName(granularity, timestamp);
        var fieldName = this._getRoundedTimestamp(timestamp, granularity.duration);               
        multi.hget(key, fieldName);                                                               
    }
    multi.exec(function(err, replies) {                                                           
        var results = [];
        for ( var i = 0; i < replies.length ; i++ ) {
            var timestamp = beginTimestamp + i * granularity.duration;
            var value = parseInt(replies[i], 10) || 0;
            results.push({timestamp: timestamp, value: value});
        }
        onComplete(granularityName, results);
    });
};
```


# 정렬된 셋을 이용한 유일한 엘리먼트 추가
* 유일한 엘리먼트 추가를 지원하는 시계열 구현 (ex: 순 방문자)
* 정렬된 셋은 중복된 키를 무시하므로 같은 시간대 중복된 데이터를 없앨수 있다.
* 정렬된 셋은 집리스트, 스킵리스트와 해시테이블로 인코딩되며 zset-max-ziplist-entries보다 작으면 집리스트 인코딩을 한다.


1.zset-max-zilplist-entries 를 기반으로 quantity 필드를 구성한다.
```
this.granularities = {                                                      
    '1sec' : { name: '1sec', ttl: this.units.hour * 2,                      
                duration: 1, quantity: this.units.minute * 2},              
    '1min' : { name: '1min', ttl: this.units.day * 7,                       
                duration: this.units.minute, quantity: this.units.hour * 2},
    '1hour' : { name: '1hour', ttl: this.units.day * 60,                    
                duration: this.units.hour, quantity: this.units.day * 5 },  
    '1day' : { name: '1day', ttl: null,                                     
                duration: this.units.day, quantity:this.units.day * 30 }    
};                                                                           
```

2.zadd 커맨드를 통해 정렬된 셋에 추가한다.
    * 정렬된 셋은 유일한 엘리먼트를 갖기 때문에 타임스탬프를 붙인 값으로 추가한다.
```
TimeSeries.prototype.insert = function(timestampInSeconds, thing) {                              
    for (var granularityName in this.granularities) {                                            
        var granularity = this.granularities[granularityName];                                   
        var key = this._getKeyName(granularity, timestampInSeconds);                             
        var timestampScore = this._getRoundedTimestamp(timestampInSeconds, granularity.duration);
        var member = timestampScore + ":" + thing;                                               
        this.client.zadd(key, timestampScore, member);                                           
        if ( granularity.ttl !== null ) {                                                        
            this.client.expire(key, granularity.ttl);                                            
        }                                                                                        
    }                                                                                            
};                                                                                                                                                                
```

3. zcount를 통해서 주어진 점수 범위안의 엘리먼트 갯수를 리턴한다.
```
TimeSeries.prototype.fetch = function(granularityName, beginTimestamp, endTimestamp, onComplete) {
    var granularity = this.granularities[granularityName];                                        
    var begin = this._getRoundedTimestamp(beginTimestamp, granularity.duration);                  
    var end = this._getRoundedTimestamp(endTimestamp, granularity.duration);                      
    var fields = [];                                                                              
                                                                                                  
    var multi = this.client.multi();                                                              
                                                                                                  
    for (var timestamp = begin; timestamp  <= end; timestamp += granularity.duration) {           
        var key = this._getKeyName(granularity, timestamp);                                       
        multi.zcount(key, timestamp, timestamp);                                                  
    }                                                                                             
                                                                                                  
    multi.exec(function(err, replies) {                                                           
        var results = [];                                                                         
        for ( var i = 0; i < replies.length ; i++ ) {                                             
            var timestamp = beginTimestamp + i * granularity.duration;                            
            var value = parseInt(replies[i], 10) || 0;                                            
            results.push({timestamp: timestamp, value: value});                                   
        }                                                                                         
                                                                                                  
        onComplete(granularityName, results);                                                     
    });                                                                                           
};                                                                                                                                                                                      
```

cf) 유일한 엘리먼트 라이브러리 사용 예시
```
var redis = require("redis");
var client = redis.createClient();
if ( process.argv.length < 3 ) {
    console.log("ERROR");
    console.log("sdfsdfsdf");
    process.exit(1);
}
 
var dataType = process.argv[2];
client.flushall();
var timeseries = require("./timeseries-" + dataType);
var concurrentPlays = new timeseries.TimeSeries(client, "concurrentplays");

var beginTimestamp = 0;
concurrentPlays.insert(beginTimestamp, "user:max");			// user:max 사용자를 0초에 추가
concurrentPlays.insert(beginTimestamp, "user:max");			// user:max 사용자를 0초에 추가
concurrentPlays.insert(beginTimestamp + 1, "user:hugo");		// user:hugo 사용자를 1초에 추가
concurrentPlays.insert(beginTimestamp + 1, "user:renata"); 		// user:renata 사용자를 1초에 추가
concurrentPlays.insert(beginTimestamp + 3, "user:hugo");		// user:hugo 사용자를 3초에 추가
concurrentPlays.insert(beginTimestamp + 61, "user:kc");			// user:kc를 61초에 추가
function displayResults(granularityName, results) {
    console.log("Results from " + granularityName + ":");
    console.log("Timestamp \t| Value");
    console.log("-------------- | ------");
    for (var i = 0; i < results.length; i++ ){
        console.log('\t' + results[i].timestamp + '\t| ' + results[i].value);
    }
    console.log();
}
 
concurrentPlays.fetch("1sec", beginTimestamp, beginTimestamp + 4, displayResults);	// 1sec 단위로 0에서 4초까지의 사용자 출력
concurrentPlays.fetch("1min", beginTimestamp, beginTimestamp + 120, displayResults);	// 1min 단위로 0에서 120초까지의 사용자 출력
 
client.quit(); 
```

# 결과

* 0초에 user:max를 2번 추가했으나 중복되므로 1이 출력된다.
* 분을 기준으로 user:hugo를 2번 추가했으나 중복되므로 0에서는 3이 출력된다.
```
RResults from 1sec:
Timestamp       | Value
-------------- | ------
        0       | 1
        1       | 2
        2       | 0
        3       | 1
        4       | 0
Results from 1min:
Timestamp       | Value
-------------- | ------
        0       | 3
        60      | 1
        120     | 0
```        

# 하이퍼로그로그를 이용한 유일한 엘리먼트 추가
* 하이퍼로그로그를 사용하면 정렬된 셋을 사용한 솔류션보다 메모리를 적게 사용하지만 99.19%만 정확하다.
* 하이퍼로그로그는 키 그룹핑을 수행하지 않으므로 quantity 필드가 없다.
```
this.granularities = {
    '1sec' : { name: '1sec', ttl: this.units.hour * 2,
                duration: 1},                           
    '1min' : { name: '1min', ttl: this.units.day * 7,
                duration: this.units.minute},           
    '1hour' : { name: '1hour', ttl: this.units.day * 60,
                duration: this.units.hour},             
    '1day' : { name: '1day', ttl: null,
                duration: this.units.day}               
};                                                                                                                                                                                      
```

* pfadd 커맨드를 통해서 하이퍼로그로그에 값을 추가한다.
```
TimeSeries.prototype.insert = function(timestampInSeconds, thing) {
    for (var granularityName in this.granularities) {
        var granularity = this.granularities[granularityName];
        var key = this._getKeyName(granularity, timestampInSeconds);
        this.client.pfadd(key, thing);                              
        if ( granularity.ttl !== null ) {
            this.client.expire(key, granularity.ttl);
        }
    }
};                                                                                                                                                                                
```

* pfcount를 통해서타임스탬프에 엘리먼트 개수를 얻어온다.
```
TimeSeries.prototype.fetch = function(granularityName, beginTimestamp, endTimestamp, onComplete) {
    var granularity = this.granularities[granularityName];
    var begin = this._getRoundedTimestamp(beginTimestamp, granularity.duration);
    var end = this._getRoundedTimestamp(endTimestamp, granularity.duration);
    var fields = [];
        
    var multi = this.client.multi();
    
    for (var timestamp = begin; timestamp  <= end; timestamp += granularity.duration) {
        var key = this._getKeyName(granularity, timestamp);
        multi.pfcount(key);                                                                       
    }   
            
    multi.exec(function(err, replies) {
        var results = [];
        for ( var i = 0; i < replies.length ; i++ ) {
            var timestamp = beginTimestamp + i * granularity.duration;
            var value = parseInt(replies[i], 10) || 0;
            results.push({timestamp: timestamp, value: value});
        }
        onComplete(granularityName, results);
    });
}; 
```

