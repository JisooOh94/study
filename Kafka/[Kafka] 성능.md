# Kafka의 고가용성을 위한 장치
### 메시지 Replication
* 토픽의 파티션 생성시, 각 파티션의 복사본 n개도 함께 생성, 복사본 파티션을 각 브로커에 나누어 할당
	* 토픽 생성시, 리플리케이션 파라미터를 통해 생성할 복사본 개수 n 설정
	* 리플리케이션 수를 클러스터의 브로커 수 배수로 설정하여 각 브로커에 가해지는 부하를 동일하게 유지
* 한 브로커에 장애가 생겨, 해당 브로커의 파티션에 저장되어있던 메시지들이 유실되는 상황 방지
	> 장애상황에서도 고가용성(High Availability)을 보장
* 컨트롤러 브로커가 파티션 및 그 복사본 n 개중 하나를 리더 파티션, 나머지 n-1개를 팔로워 파티션으로 설정
	* 리더 파티션은 컨슈머의 컨슈밍 요청 처리, 팔로워 파티션은 장애 상황 대비하여 리더 파티션의 변경사항 팔로우
 
### Disk에 저장
* 메시지들은 파티션 별로 세그먼트 라는 파일로 브로커 로컬(kafka/log/dirs)에 저장
	* append-only 자료구조인 로그 자료구조 형태로 파일에 저장하여, 빠른 쓰기 작업 가능
* 파일시스템(디스크)에 저장하기때문에 컨슈머가 프로듀싱된 메시지를 빠르게 컨슘할 필요 없이 보존 기간내에 언제든지 컨슘 가능
	* 전통적인 메시지 큐 시스템은 메시지를 브로커의 메모리에 저장
	* 이로인해, 컨슈머는 프로듀싱된 메시지를 빠르게 컨슘하여 처리 필요
	* 컨슈머의 처리속도가 느리거나, 갑자기 많은 양의 메시지가 프로듀스된다면, 브로커 서버에 OOM 에러 발생 가능
* 컨슈머의 장비 성능이 떨어지거나, 순간적인 부하 증가로 처리 속도가 느려질때, 브로커측에 컨슈머의 부하가 전파되지 않고, 컨슈머도 자신이 처리 가능한 속도로 컨슈밍 가능
* 컨슈머에서 컨슘한 메시지 처리과정중에 에러가 발생했을떄, 세그먼트 파일을 통해 다시 메시지 조회 가능
* 세그먼트 파일은 설정된 보존 기간동안 보존후, 자동 삭제됨 

![image](https://user-images.githubusercontent.com/48702893/149331939-9259ea2e-18b9-41c8-a8c2-3aa6140a076d.png)

<br>

# Kafka의 성능향상을 위한 장치
### Scailability
* 브로커, 파티션, 컨슈머 모두 운영중에 추가 가능하여 유연하게 scale-out 가능
* 컴포넌트 증대시 성능이 좋아지는만큼 관리포인트등의 트레이드오프가 있기때문에 신중히 판단 

### Pull 방식 Consumer
* 기존 메시징 시스템(e.g. RabbitMq)의 경우 브로커가 컨슈머에게 메시지를 전송하는 Push 방식 사용(옵저버 패턴)
	* 컨슈머의 처리율을 초과하는 양의 데이터 전송시, 컨슈머 버퍼에 적체되다 버퍼 용량 초과하면서 장애 발생
	* 따라서 브로커는 메시지 전송시, 컨슈머의 상태 고려 필요
* 카프카는 컨슈머가 브로커에게서 메시지를 가져오는 Pull 방식(일종의 Reactive BackPressure) [Reactive BackPressure](https://github.com/JisooOh94/study/blob/master/Reactive/2.%20%EB%B0%B1%ED%94%84%EB%A0%88%EC%85%94.md)
	* 컨슈머가 자신이 처리 가능한 양만큼만 메시지 가져오기때문에 Push 방식의 문제 해결

### Zero-copy
* 브로커가 세그먼트 파일로부터 메시지를 읽고, 이를 네트워크로 전달하는 과정에서 컨텍스트 스위칭이 없도록 하는 기술
* 컨텍스트 스위칭 없이 커널 영역에서만 작업이 수행되므로, 커널 모드 - 유저모드 전환이 없어 성능 향상 
	> 메시지 암호화(SSL) 설정시, 메시지 암복호화를 위해 유저 모드 전환이 필요하므로 제로 카피 사용 불가능

![image](https://user-images.githubusercontent.com/48702893/149332010-e7f9be01-1170-475f-b180-702ee1cc0769.png)

![image](https://user-images.githubusercontent.com/48702893/149332024-ffaf5374-58d1-4d43-b559-1a3b9d667a69.png)

### 메시지 배치 처리
* 메시지를 디스크에 저장하므로, 메시지를 버퍼링했다가 한번에 컨슘하여 처리하는 배치 처리 가능
* 네트워크 트래픽 비용 절약 가능, 버퍼링을 통해 연속적인 디스크 공간에 메시지 저장하므로 I/O 성능 향상

***
> Reference
> * https://always-kimkim.tistory.com/entry/kafka101-broker
> * https://soft.plusblog.co.kr/3
