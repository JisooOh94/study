# 인덱스

<img src="https://user-images.githubusercontent.com/48702893/103456349-90eeab80-4d38-11eb-90cd-8ead640230f7.png" width="50%" height="30%">

* 데이터베이스 조회 속도를 향상시키기 위한 일종의 목차 기능
	* 인덱스가 없을경우, 조회쿼리 수행시 매번 테이블 full-scan 수행
* key : 인덱스로 설정한 칼럼 값
  value : 레코드 저장 위치 포인터 (페이지 - row 번호)
* key 값을 기준으로 정렬하여 B-Tree 구조로 인덱스 테이블에 저장하기 때문에 빠른 탐색 가능

# 다단계 인덱스

<img src="https://user-images.githubusercontent.com/48702893/103456404-40c41900-4d39-11eb-8a36-5b9f225f329a.png" width="50%" height="30%">

* 대용량 단일단계 인덱스의 탐색시간을 줄이기 위한 인덱스
	> 인덱스 테이블에 저장된 인덱스가 많아질경우, 인덱스 탐색 시간 자체가 오래 걸릴 수 있음
* 인덱스에 대한 인덱스 생성하는 방식으로 인덱스 계층화
* 하나의 디스크 블록으로 이루어진 마스터 인덱스가 생성될때까지 반복

### 다단계 인덱스 저장 구조

<img src="https://user-images.githubusercontent.com/48702893/103456597-ef1c8e00-4d3a-11eb-92ec-8b63e3e8160b.png" width="20%" height="40%">

* 하나의 노드가 여러개의 자식 노드를 가지는 B+ 트리 구조로 저장
* 하나의 디스크 블록이 하나의 노드
* 블록에 저장되어있는 인덱스 레코드들이 가리키는 자식노드가 자식 인덱스 디스크 블록 
* 일반적으로 하나의 디스크 블록에 자식노드에 대한 수백개의 포인터 저장 가능하나 추가될 인덱스 엔트리를 위한 예비공간 남겨둠 (인덱스 갱신 작업을 용이하게 하기위해)

### 다단계 인덱스 단점
* 테이블에 데이터가 추가/삭제 되어 인덱스 갱신이 필요할시 과정이 매우 복잡해짐
* 일반적으로 데이터 수정 쿼리보다 조회쿼리가 훨씬 더 많이 사용되므로 DBMS 에선 디폴트로 다단계 인덱스 사용  

# 인덱스 종류

<img src="https://user-images.githubusercontent.com/48702893/103477114-bb0aa100-4dfe-11eb-832a-7ce1e950d4d2.png" width="50%" height="30%">

### 클러스터 인덱스
* 클러스터 인덱스로 설정된 칼럼 값에 따라 물리적으로 데이터가 정렬되어 저장됨 
	* 물리적으로 정렬되어있으므로 논클러스터 인덱스에 비해 조회속도는 빠르나 DML 작업에 취약(수정내용에 따라 다시 물리적으로 정렬해야하므로)
* 정렬을 위해 테이블당 1개의 클러스터 인덱스만 생성 가능(2개 이상일시, 물리적 정렬과정에서 꼬일수 있음) 
* 물리적으로 정렬되어 저장되므로 인덱스에 리프노드 불필요, 각 디스크 블록의 헤드노드만 인덱스에 저장
	* 논클러스터 인덱스에 비해 인덱스의 크기가 작음
> 리프노드 : 단일단계 인덱스처럼, 테이블에 저장되어있는 모든 레코들의 저장위치를 포인터(페이지 - row번호) 로 가지고있는 노드 

<img src="https://user-images.githubusercontent.com/48702893/103476908-f7d59880-4dfc-11eb-8c68-086bdcd6661f.png" width="40%" height="20%">

### 논클러스터 인덱스
* 물리적인 데이터는 정렬되지 않는 인덱스
* 테이블당 여러개 생성 가능
* 인덱스에 리프노드가 필요하고 조회성능도 클러스터인덱스에 비해 떨어짐

<img src="https://user-images.githubusercontent.com/48702893/103476918-08860e80-4dfd-11eb-9fcd-5e7e8ee41c8a.png" width="50%" height="30%">