# TCP 프로토콜 속도 지연 문제 해결 방법
### 병렬 커넥션
* 서버와 여러개의 커넥션 수립 후, 동시에 여러 리소스 요청, 수신
* 네트워크 대역폭이 좁으면 병렬 커넥션을 사용해도 성능상의 효과 미미 
* 성능상의 효과가 미미해도 화면에 동시에 여러개의 리소스가 로드되므로 사용자는 더 빠르게 느낄 수 있음
* 매 트랜잭션마다 새로 커넥션을 수립하므로, 3-way-handshake, 느린시작 으로 인한 지연 발생 

### 지속 커넥션
* 커넥션을 맺어 클라이언트의 요청을 처리 한 후, 커넥션을 끊지 않고 유지하여 클라이언트의 해당 서버에대한 또다른 요청에 재활용
* 새로운 커넥션 수립(3-way-handshake, 느린 시작)으로 인한 지연 완화
* 사이트 지역성 : 클라이언트가 한 서버에 대한 요청 시, 단기간내에 동일한 서버에 대한 또다른 요청을 할 확률이 높다
   > 클라이언트가 naver 메인을 보여달라고 naver서버에 요청한다. 그 후, 클라이언트는 naver메인 화면에 보이는 또다른 링크나 탭(네이버 기사, 실시간 검색 순위등), 혹은 네이버 검색을 할 확률이 높다.
* 지속 커넥션을 잘못 관리할 시, 사용되지 않는 커넥션들이 불필요하게 유지되어 서버,클라이언트 리소스 낭비

<br>

# Keep-Alive 커넥션
* HTTP/1.0 버전의 지속 커넥션
* Connection:Keep-Alive 파라미터를 헤더에 포함시킴으로서 활성화
* 반드시 요청/응답메시지 헤더의 content-Length와 실제 바디 데이터 길이가 일치해야함
   > 일치하지 않을시, 요청/응답메시지 전송 후, 커넥션에 데이터가 잔존해있게되고 다음 트랜잭션에 문제를 유발
* Keep-Alive 를 프록시/캐시서버와 함께 사용할 경우 별도의 설정 필요(멍청한 프록시 참조)

### Keep-Alive 만료 설정
* timeout : 커넥션 유지 시간 설정
* max : 커넥션 유지 트랜잭션 수
```
GET /index.html HTTP/1.1
~
Connection: Keep-Alive
Keep-Alive: max=5, timeout=120
~
```

<br>

# 지속 커넥션
* Http/1.1 버전의 지속커넥션
* Http/1.1 버전의 디폴트 커넥션(별도의 Keep-Alive와 같은 파라미터 없음)
* 커넥션을 종료하고자 할경우 Connection:close 헤더 추가
* Content-Lenght값과 실제 바디 데이터 길이가 다를경우 커넥션 자동 종료

<br>

# 파이프라인 커넥션
* 클라이언트에서 요청 메시지 전송 후, 응답메시지를 수신할때까지 다음 요청 전송을 대기하는것이 아닌, 요청메시지가 서버에 정상적으로 전송되었다는 확인 패킷만 수신 후 바로 다음 요청 전송
* 네트워크상의 왕복으로 인한 전송대기 시간지연을 줄여 성능 향상
* Http/1.1, 지속커넥션 상황에서만 지원
* 파이프라인으로 전송한 요청에 대한 응답메시지는 요청메시지를 전송한 순서에 맞춰 수신

![image](https://media.oss.navercorp.com/user/13474/files/22daeea6-6f5e-11e9-8b01-57c0646feec7)

<br>

# TCP 커넥션 끊기
* TCP 커넥션의 경우 의도된 종료 외에 에러발생시에도 예상치 못한 끊김 가능
* 웹어플리케이션은 이러한 예상치 못한 통신도중 커넥션 종료상황에 대한 대응 방안 필요
* 멱등메소드를 이용한 요청 도중 커넥션 종료시, 재 요청 전송
* 비멱등 메소드의 경우 재요청시 서버 리소스에 문제를 일으키므로 다른 대응방안 필요
### 절반끊기
* 네트워크장비에서 입력/출력 채널 중 하나만을 개별적으로 종료하는것
* 절반끊기를 하고자 하는 장비에서 shutdown() 호출
* 예상치 못한 쓰기 에러 방지 가능