# 메모리 스왑
* 페이징을 이용한 메모리 가상화 방식에서, 메모리에 저장되어있는 프레임들중, 자주 사용되지 않는 프레임을 디스크로 옮겨 저장하는 방식 
* 더 많은 주소공간 저장이 가능해지고 물리메모리의 공간효율도 극대화됨
* 스왑공간 : 자주사용되지 않는 페이지들을 저장하는 디스크내의 별도의 공간

### 가상주소맵핑
* 가상주소맵핑시, 가상주소에 해당하는 페이지가 저장되어있는 위치(메모리/디스크)를 페이지 테이블에 Present Bit 로 기록
* Present Bit
   * 가상주소에 해당하는 페이지가 메모리에 저장되어있는지 나타내는 1bit
   * Present Bit 가 0이라면 해당 페이지는 디스크에 저장되어있는것이고, 이때 맵핑되는 물리주소 또한 디스크 물리주소(스왑공간 주소)
* 프로세서가 가상주소 참조 요청시, 운영체제는 가상주소에서 추출한 페이지번호로 페이지테이블 Present Bit 확인하여, 저장되어있는 공간의 물리주소 참조
* 프로세서가 요청한 데이터의 페이지가 디스크에 저장되어있을경우 페이지 폴트가 발생하며 페이지 폴트 처리 프로세스 수행

### 페이지 폴트 처리 프로세스
1. 메모리 조회 요청, 가상주소 맵핑 수행
   * TLB 미스 발생, 페이지 테이블 조회
      * 페이지 폴트가 발생하는 경우는 페이지가 디스크에 저장되어있는경우(오래동안 사용되지 않아)이므로 당연히 TLB 에도 없음
   * 페이지 폴트 발생, 디스크 스왑공간에서 페이지 조회하여 메모리에 저장후 페이지 테이블 갱신
2. 메모리 조회 요청 명령 다시 수행(2), 가상주소 맵핑 수행
   * TLB 미스 발생, 페이지 테이블 조회
   * 페이지 hit, TLB 갱신
3. 메모리 조회 요청 명령 다시 수행(3), 가상주소 맵핑 수행
   * TLB hit, 메모리 데이터 반환

<br>

# 메모리 갱신 정책
* 페이지 폴트 발생시, 디스크에 저장되어있는 페이지를 메모리로 올리게되는데, 이때, 메모리에 여유공간이 없다면 문제 발생
* 이를 위해 운영체제는 메모리에 항상 일정크기의 여유공간 확보해둠
* 여유공간 확보를 위해 메모리에 저장되어있는 페이지중 일부를 선택하여 디스크로 스왑(페이징 아웃)

### 여유공간 확보 과정
* 설정되어있는 여유공간 최소 크기값(low watermark, LW)보다 메모리 여유공간이 적어질경우 여유공간 확보 작업을 수행하는 백그라운드 스레드(swap daemon) wake
* 여유공간의 크기가 설정되어있는 여유공간 최대 크기값(high watermark, HW)보다 커질때까지 정책에 따라 메모리의 페이지들을 선택하여 디스크로 스왑후 메모리에서 삭제
* 여유공간의 크기가 여유공간 최대 크기값보다 커지면 swap daomon 스레드 sleep

### 갱신 정책 종류
* 선입선출정책(FIFO) : 가장 오래전에 메모리에 저장된(사용됨 x) 페이지 순으로 페이징 아웃(메모리에 저장된 시간정보 함께 저장)
* 랜덤정책 : 랜덤하게 페이징 아웃, 비효율적
* LFU(Least Frequent Used) : 가장 적게 사용된 페이지 순으로 페이징 아웃 (사용 빈도수 함께 저장)
* LRU(Least Recently Used) : 가장 오래전에 사용된 페이지 순으로 페이징 아웃 (마지막 사용 시간정보 함께 저장)

<br>

# 기타 메모리 스왑 정책
### 페이지 선택 정책
* 디스크에서 메모리로 페이지 스왑시, 언제 스왑할지 시점 선택 정책
* 요구 페이징 정책 : 요청된 시점에 스왑
* 선반입 정책 : 페이지 스왑시, 공간지역성에 따라, 스왑하는 페이지 주변에 함께 저장되어있던 페이지들도 미리 스왑

### 클러스터링
* 메모리에서 디스크로 페이징 아웃시, 페이징아웃될 페이지들을 버퍼에 모아두었다가 한번에 디스크에 저장
* 매번 디스크에 페이징아웃하는 방식에 비해 디스크 접근 시간 절약 가능