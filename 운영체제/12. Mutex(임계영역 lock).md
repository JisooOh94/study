# Mutex(Mutual Extension)
* 한 코드 영역을 임계영역으로 만들어주는 변수
* 임계영역의 상태(사용 가능/사용중) 및 사용중인/대기중인 스레드 정보 저장 

### 동작방식
* lock(), unlock() 메서드로 구성
* 스레드는 임계영역 진입전 lock() 메서드를 호출하여 임계영역의 lock(사용권개념) 획득
* 임계영역이 이미 다른 스레드에 의해 사용중이면 lock 메서드는 return 하지 않고 무한반복문으로 대기(임계영역을 수행중이던 스레드가 수행을 마치고 unlock을 호출할떄까지)

```java
private lock_t lock;
private Object shareObj;

private void add(Object obj) {
	lock(&lock);
	obj = obj + 1;
	unlock(&lock);
}

private void lock(lock_t* lock) {
	while(lock.flag == UNAVAILABLE);
	lock.setFlag(UNAVAILABLE);
}

private void unlock(lock_t* lock) {
	lock.setFlag(AVAILABLE);
}
```

### lock 중첩
* 하나의 코드영역에 대해 하나의 lock 만 사용하는 것이 아닌, 여러개의 lock을 필요한곳에 사용
* 서로 다른 데이터와 자료구조 각각을 개별적으로 세밀하게 보호

<br>

# lock 종류
### lock 의 성능 판단 기준
1. 정확성 : 임계영역의 상호배제를 보장하는지
2. 공정성 : 대기중인 스레드들의 lock 획득 공정성을 보장하는지(스레드 굶주림 문제가 발생하지 않는지)
3. 성능 : 락 사용시 발생하는 오버헤드 크기

### 스핀 락

```java
private void lock(lock_t* lock) {
	while(lock.flag == UNAVAILABLE);
	lock.setFlag(UNAVAILABLE);
}

private void unlock(lock_t* lock) {
	lock.setFlag(AVAILABLE);
}
```

* 임계영역에 대한 lock이 해제(사용가능)될 떄까지 무한반복문 while(lock.flag == UNAVAILABLE) 으로 대기하는것
* 성능 평가
   * 정확성
      * 임계영역에 대한 상호배제를 보장
   * 공정성
      * lock 해제 시점에 스케쥴링되어 무한반복분으로 대기중이던 스레드가 lock 을 얻는 방식
      * 운에 기대는 방식이므로 운이 나빠 계속해서 lock 을 얻지못하고 무한 대기하게되는 스레드 발생 가능(스레드 굶주림)
   * 성능
      * 단일 프로세서 환경일시, 과도한 스핀문제로 성능 저하 발생
   
### 티켓 락

```java
private int moveCur(int* cur) {
	int curTurn = &cur;
	*cur = curTurn + 1;
	return curTurn;
}

private void lock(lock_t* lock) {
	int myTurnNum = moveCur(lock->ticket);		//대기번호(ticket)를 옮긴다. 마지막 대기번호 + 1 를 반환한다.
	while(myTurnNum != lock -> turn);
}

private void unlock(lock_t* lock) {
	moveCur(lock -> turn);		//실행번호(ticket) 를 옮긴다. 현재 실행이 끝난 실행번호 + 1 를 반환한다.
}
```

* 대기중인 스레드들에 FIFO 방식으로 실행 순서를 부여하여 일종의 스케쥴링처럼 동작하는 락
* lock 이 실행번호, 대기번호 2개의 상태를 가지고있어, 임계영역에 접근하는 스레드 순서대로 실행순서 부여 가능
* 성능 평가
   * 정확성
      * 임계영역에 대한 상호배제 보장
   * 공정성
      * 대기중인 스레드들에 명시적 실행 순서를 부여하므로 일정시간 대기 후 반드시 실행됨을 보장(스레드 굶주림 없으)
   * 성능
      * 단일 프로세서 환경일시, 과도한 스핀문제로 성능 저하 발생

<br>

# 과도한 스핀 문제
* 스레드 A 가 임계영역의 lock 을 얻어 작업중, 스케쥴러에 의해 '준비' 상태로 전환
* 스케쥴링되어 실행을 시작한 스레드 B 가 동일한 임계영역에 접근
* 스레드 A 가 lock 을 가지고있으므로, 스레드 B는 실행시간 내내 아무런작업도 못한채 대기만 하다가 '준비'상태로 전환

### 해결방법 1. 무조건 양보
* '실행' 상태인 스레드가 획득하고자 하는 lock이 이미 사용중이라면, 스스로 '준비'상태로 전환하여 CPU 를 다른 스레드에게 양보
* yield() 시스템 콜 활용(실행상태 > 준비상태로 변환 명령어)
* 과도한 스핀문제는 해결할 수 있지만, 동일한 lock을 얻고자 대기중인 스레드가 많을 경우, 그만큼 문맥교환이 많이 발생하여 문맥교환비용이 커짐
   * '준비'상태인 스레드 99개가 동일한 lock 을 얻기 위해 대기중이라면, 해당 lock 이 해제될때까지 계속해서 99번의 문맥교환 발생
* 스레드 굶주림 문제 발생 가능

### 해결방법 2. 대기 큐
* lock 에 스레드 대기 큐를 두어 lock 을 얻기 위해 대기중인 스레드 저장
* 스레드가 lock 호출시, lock 이 사용중인 상태일경우, 자신을 lock 의 대기큐에 insert 하고 yield 호출하여 CPU 양보
* lock을 사용중인 스레드가 작업 완료후 unlock 호출시, lock의 스레드 대기큐에서 dequeue 하여 '준비'상태로 대기하던 스레드 순차 실행
* 과도한 스핀문제, 스레드 굶주림 문제 모두 해결
8 꺠우기/대기 문제 발생 가능

### 해결방법 3. 2단계 락
* 락이 곧 해제될 상황에선 스핀락도 효율적으로 동작(대기시간이 짦음)
* 이같은 원리를 이용, 스핀락 시작 후 짧은시간동안만 대기하다가 락이 해제되지 않으면 yield 호출하여 CPU 양보
* 기본적인 동작방식은 무조건 양보 방식과 동일하므로 마찬가지로 스레드 굶주림 문제 발생 가능