# lock
* 한 코드 영역을 임계영역으로 만들어주는 변수
* 임계영역의 상태(사용 가능/사용중) 및 사용중인/대기중인 스레드 정보 저장 

### 동작방식
* lock(), unlock() 메서드로 구성
* 스레드는 임계영역 진입전 lock() 메서드를 호출하여 임계영역의 lock(사용권개념) 획득
* 임계영역이 이미 다른 스레드에 의해 사용중이면 lock 메서드는 return 하지 않고 무한반복문으로 대기(임계영역을 수행중이던 스레드가 수행을 마치고 unlock을 호출할떄까지)

```java
private lock_t lock;
private Object shareObj;

private void add(Object obj) {
	lock(&lock);
	obj = obj + 1;
	unlock(&lock);
}

private void lock(lock_t* lock) {
	while(lock.flag == UNAVAILABLE);
	lock.setFlag(UNAVAILABLE);
}

private void unlock(lock_t* lock) {
	lock.setFlag(AVAILABLE);
}
```

### lock 중첩
* 하나의 코드영역에 대해 하나의 lock 만 사용하는 것이 아닌, 여러개의 lock을 필요한곳에 사용
* 서로 다른 데이터와 자료구조 각각을 개별적으로 세밀하게 보호

<br>

# lock 종류
### lock 의 성능 판단 기준
1. 정확성 : 임계영역의 상호배제를 보장하는지
2. 공정성 : 대기중인 스레드들의 lock 획득 공정성을 보장하는지(스레드 굶주림 문제가 발생하지 않는지)
3. 성능 : 락 사용시 발생하는 오버헤드 크기

### 스핀 락

```java
private void lock(lock_t* lock) {
	while(lock.flag == UNAVAILABLE);
	lock.setFlag(UNAVAILABLE);
}

private void unlock(lock_t* lock) {
	lock.setFlag(AVAILABLE);
}
```

* 임계영역에 대한 lock이 해제(사용가능)될 떄까지 무한반복문 while(lock.flag == UNAVAILABLE) 으로 대기하는것
* 성능 평가
   * 정확성
      * 임계영역에 대한 상호배제를 보장
   * 공정성
      * lock 해제 시점에 스케쥴링되어 무한반복분으로 대기중이던 스레드가 lock 을 얻는 방식
      * 운에 기대는 방식이므로 운이 나빠 계속해서 lock 을 얻지못하고 무한 대기하게되는 스레드 발생 가능(스레드 굶주림)
   * 성능
      * 단일 프로세서 환경일시, 과도한 스핀문제로 성능 저하 발생
   
### 티켓 락

```java
private int moveCur(int* cur) {
	int curTurn = &cur;
	*cur = curTurn + 1;
	return curTurn;
}

private void lock(lock_t* lock) {
	int myTurnNum = moveCur(lock->ticket);		//대기번호(ticket)를 옮긴다. 마지막 대기번호 + 1 를 반환한다.
	while(myTurnNum != lock -> turn);
}

private void unlock(lock_t* lock) {
	moveCur(lock -> turn);		//실행번호(ticket) 를 옮긴다. 현재 실행이 끝난 실행번호 + 1 를 반환한다.
}
```

* 대기중인 스레드들에 FIFO 방식으로 실행 순서를 부여하여 일종의 스케쥴링처럼 동작하는 락
* lock 이 실행번호, 대기번호 2개의 상태를 가지고있어, 임계영역에 접근하는 스레드 순서대로 실행순서 부여 가능
* 성능 평가
   * 정확성
      * 임계영역에 대한 상호배제 보장
   * 공정성
      * 대기중인 스레드들에 명시적 실행 순서를 부여하므로 일정시간 대기 후 반드시 실행됨을 보장(스레드 굶주림 없으)
   * 성능
      * 단일 프로세서 환경일시, 과도한 스핀문제로 성능 저하 발생

<br>

# 과도한 스핀 문제
* 스레드 A 가 임계영역의 lock 을 얻어 작업중, 스케쥴러에 의해 '준비' 상태로 전환
* 스케쥴링되어 실행을 시작한 스레드 B 가 동일한 임계영역에 접근
* 스레드 A 가 lock 을 가지고있으므로, 스레드 B는 실행시간 내내 아무런작업도 못한채 대기만 하다가 '준비'상태로 전환

### 해결방법 1. 무조건 양보

### 해결방법 2. 