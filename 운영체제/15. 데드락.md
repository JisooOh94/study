# 데드락
* 두 스레드가 서로 상대방이 소유하고 있는 락을 대기하는 문제(식사하는 철학자 문제)
* 임계영역이 중첩되어있고, 락 획득에 사이클이 존재하는 경우 발생
   * lock_1 > lock_2 순서로 얻어 임계영역 작업을 수행하는 스레드 A 와 lock_2 > lock_1 순서로 얻어 임계영역 작업을 수행하는 스레드 B
   * 스레드 A 가 lock_1을 얻은 후 문맥교환, 스레드 B가 lock_2 를 얻은 후 다시 문맥교환
   * 스레드 A 는 lock_2를 얻고자 하나 이미 사용중이므로 lock_1을 소유한 채로 다시 문맥교환
   * 스레드 B 는 lock_1를 얻고자 하나 이미 사용중이므로 lcok_2를 소유한 채로 다시 문맥교환
   * 두 스레드는 서로가 가지고 있는 lock 을 얻기 위해 무한히 문맥교환하는 데드락 발생

### 락 획득에 사이클 발생 이유
1. 프로그램이 커지며 코드가 복잡해져서 락 획득 사이클이 의도치 않게 발생
2. 써드파티 라이브러리들의 내부 동작로직이 (캡슐화 원칙에 따라)감춰져있어, 현재 코드에 사용되었을시 사이클이 발생할지 확인할 수 없음

<br>

# 데드락 발생 조건(코프만 조건)
* 아래 조건이 모두 만족하여야 교착 상태 발생

### 상호배제(Mutual Exclusion)
* 하나의 자원에 하나의 프로세스만 접근 가능

### 점유대기(Hold and wait)
* 프로세스가 이미 할당된 자원을 가지고 있는 상태에서 다른 자원의 할당을 대기

### 비선점(No preemption)
* 프로세스가 자원의 사용을 끝내고 스스로 해제할때까지 다른 프로세스가 그 자원을 뺏을 수 없음

### 순환대기(Circular wait)
* 각 프로세스가 자원을 가지고 있으면서 서로의 자원을 할당 대기

<br>

# 데드락 해결 방법	
### 예방(Prevention)
* 4가지 코프만 조건 중 하나의 발생을 방지하여 교착상태 발생 예방
* 상호배제
	* 하나의 자원에 여러개의 스레드가 동시에 접근할 수 있도록 임계영역 해제
* 점유대기
	* 스레드가 작업 수행전, 작업에 필요한 모든 자원을 미리 할당 받은 후 수행 
* 비선점
	* 이미 할당된 자원을 선점할 수 있는 기능 제공
* 순환대기
	* 자원 획득 순서 지정

### 회피(Avoidance)
* 운영체제가 각 스레드의 자원획득 과정을 미리 검사하여 자원획득 알고리즘(자원할당그래프 알고리즘, 은행원 알고리즘)을 적용해 교착상태 발생 방지

### 회복(Recovery)
* 교착상태 발생을 허용하고, 발생 후에 교착상태를 해결하는 방식

### 무시(Ignore)
* 위의 3가지 방법은 모두 오버헤드가 크고 성능저하 유발
* 따라서 현재의 대부분의 운영체제는 교착상태에 대한 어떠한 대응도 하지 않음
* 따라서 개발자가 프로그램 개발시 교착상태 발생하지 않도록 주의하여 개발하는것이 중요