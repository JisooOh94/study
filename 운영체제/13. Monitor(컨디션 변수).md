# 컨디션 변수
* 스레드가 작업 실행 중, 변수/객체/프로그램이 작업 수행에 필요한 상태가 아닌경우, 원하는 상태가 될떄까지 cpu와 lock 반납하고 sleep, 이러한 sleep 스레드가 저장되는 대기 큐
* lock 대기 큐와 비슷하나, lock 이 해제되는것을 기다리는것이 아닌, (이미 lock 을 얻어 실행중인 스레드가) 프로그램 상태가 바뀌길 기다리는것
* 다른 스레드가 실행중에 프로그램 상태값을 수정할 경우, 수정 후 signal(일종의 wake) 을 전송하여 컨디션 변수큐에서 sleep 중이던 스레드 꺠움
* 깨어난 스레드는 다른 스레드에 의해 바뀐 프로그램 상태값이 자신이 원하는 상태값인지 확인하여 작업 continue(원하는 상태값이 아닐경우 다시 sleep)
* 
* 동기화 되어야 하는 상태값 마다 컨디션 변수 생성

```java
void thread_join() {
	lock(&lock);
	while(status == 0) wait(this, &lock);
	unlock(&lock);
}
```

### wait(thread* th, mutext* mu)
* 현재 실행중인 스레드를 '준비' 상태로 전환
* 뮤텍스(임계영역 lock) 를 파라미터 전달받아, 스레드 sleep 전, 스레드가 가지고있던 lock 해제(그래야 다른 스레드 실행가능, 과도한 스핀 방지)
* signal 을 통해 스레드 다시 실행시, 실행전, lock 다시 획득
* 만약 signal 후 lock 이 사용중일시, lock 대기 큐에 스레드 삽입 후 다시 sleep

### lock 대기 큐와 비교

|.|lock 대기 큐|컨디션 변수 큐|
|:---:|:---:|:---:|
|대상 스레드|실행시작하려는 스레드|이미 실행중인 스레드(lock 소유)|
|기다리는 상태|임계영역 lock의 해제|다음 코드를 실행하는데에 필요한 변수/프로그램 상태|
|sleep/awake 메서드|yield() / unlock()|wait() / signal()|

### 포함 조건
* 프로그램의 상태를 변경한 스레드가 signal 전송하여 컨디션 변수 큐에서 대기중인 스레드 wake
* signal 전송 스레드는 큐에서 대기중인 스레드중 상태 변경에 따라 다시 실행할 수 있는 스레드가 어느 스레드인지를 알 수 없어, 다이렉트로 시그널 전송 불가능
* 따라서 컨디션 변수 큐에서 대기중인 모든 스레드에게 signal을 전송하여 wake(일종의 signal 브로드 캐스팅)
* signal을 전송받은 스레드들은 프로그램 상태값 확인하여 다시 실행할 수 있는 스레드들만 실행되고 나머지는 다시 sleep
* 큐에서 대기중인 모든 스레드들을 깨우므로, 다시 sleep 상태에 들어가는 스레드들이 많을수록 문맥교환 비용이 커짐