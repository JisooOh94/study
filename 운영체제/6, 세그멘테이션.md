# 세그멘테이션 등장 배경

<img src="https://user-images.githubusercontent.com/48702893/90977303-5baea180-e57f-11ea-9f8d-40fa5a56c4c9.png" width="100" height="200" />

* 프로세스에게 할당된 주소공간 전체를 물리메모리에 저장시, 힙과 스택사이의 사용하지 않는 공간도 함께 저장되어 메모리 낭비 발생
* 빈공간은 물리 메모리에 저장하지 않고, 사용되고있는 공간들만 따로 물리 메모리에 저장후 각각의 베이스 바운드를 기록함으로서 메모리 낭비 완화

<br>

# 세그멘테이션

![image](https://user-images.githubusercontent.com/48702893/91732976-f17fa780-ebe3-11ea-93a6-47e3fdfdaadb.png)

* 전체 주소공간중, 사용되고 있는 공간만 물리메모리에 저장하는 방식
* 주소공간의 3가지 구성요소(코드, 힙, 스택)를 세그멘트라 하고 각각의 베이스와 바운드를 개별적으로 저장
* 각각의 베이스와 바운드를 따로 저장, 관리함으로서 하나의 주소공간내의 코드, 힙, 스택을 물리메모리의 각기 다른 위치에 저장 가능

### 세그멘테이션의 가상주소 맵핑
1. 프로세서가 요청한 주소공간의 가상주소가 어느 세그멘테이션(코드, 힙, 스택 중)에 속해있는지 확인
2. 요청한 가상주소에서 속해있는 세그멘테이션의 시작가상주소를 뺄셈하여 offset 계산
3. MMU 에서 속해있는 세그멘테이션의 Bound, Base 값 조회하여 validation 후 물리메모리주소로 맵핑(offset + Base) 수행
cf) 스택의 경우 - 방향으로 확장하므로, 음수 offset 으로 (스택 전체 크기 - offset) 맵핑 수행

### 세그멘테이션의 문제점
* 전체 주소공간중, 사용되고있는 세그멘테이션 영역만 물리메모리에 저장하여 물리메모리에 저장되어있는 세그멘테이션들의 크기가 모두 제각각임
* 프로세스가 종료되어 메모리 해제시, 해제되는 메모리 영역의 위치와 크기도 모두 제각각
* 작은크기의 세그멘테이션들이 메모리에 저장 후 해제되는 과정이 반복될수록 물리메모리내의 빈공간이 작게 쪼개어지는 파편화 발생
* 작은크기의 빈공간엔 큰 크기의 세그멘테이션을 저장 할 수 없고, 그에따라 메모리에 빈공간은 많지만 모두 파편화되어 결국 아무런 세그멘테이션도 저장하지 못하는 외부 단편화 문제 발생
* Compaction 을 통해 해결가능하나 오버헤드가 큼