# Mutex
* 하나의 스레드/프로세스가 임계영역 사용중엔 임계영역을 잠궈서 다른 스레드/프로세스가 접근하지 못하도록 하는것
* 프로세스간 동기화까지 수행
	* 한 프로세스의 스레드가 임계영역 수행중이라면 그 프로세스의 다른 스레드 뿐만 아니라, 다른 프로세스들도 접근 불가능

### 동작방식
* lock(), unlock() 메서드로 구성
* 스레드는 임계영역 진입전 lock() 메서드를 호출하여 임계영역의 lock(사용권개념) 획득
* 스레드의 임계영역 작업이 끝나면, unlock()을 호출하여 lock 반납

```java
private lock_t lock;
private Object shareObj;

private void add(Object obj) {
	lock(&lock);
	obj = obj + 1;
	unlock(&lock);
}
```

### 동작 과정 예시
* A 스레드가 임계영역 Lock 을 얻어 수행하는중에 라운드로빈 스케쥴링에 의해 Interrupt 걸림
* 이후 스케쥴링된 B 스레드가 같은 임계영역 접근후, A 스레드가 보유중인 Lock 을 얻기위해 무한 대기 진입(busy-waiting)
* 시간이 지나 다시 A 스레드가 스케쥴링되어 임계영역 코드 수행 완료 후 Lock 반납
* 시간이 지나 다시 B 스레드가 스케쥴링되어 임계영역 Lock 얻어 수행

### Lock 의 성능 판단 기준
1. 정확성 : 임계영역의 상호배제를 보장하는지
2. 공정성 : 대기중인 스레드들의 lock 획득 공정성을 보장하는지(스레드 굶주림 문제가 발생하지 않는지)
3. 성능 : 락 사용시 발생하는 오버헤드 크기

### Lock 구현방식 종류
* 스핀 락
* 양보 락

<br>

# 스핀락
```java
private void lock(lock_t* lock) {
	while(lock.flag == UNAVAILABLE);
	lock.setFlag(UNAVAILABLE);
}

private void unlock(lock_t* lock) {
	lock.setFlag(AVAILABLE);
}
```

* 임계 영역에 진입 가능할 때까지 계속 진입을 시도하는 방식으로 구현된 락
* 임계영역이 이미 다른 스레드에 의해 사용중이면 lock 메서드는 return 하지 않고 무한반복문으로 대기

### 단점
* 과도한 스핀 문제 발생
	* 스레드 A 가 임계영역의 lock 을 얻어 작업중, 스케쥴러에 의해 '준비' 상태로 전환
	* 스케쥴링되어 실행을 시작한 스레드 B 가 동일한 임계영역에 접근
	* 스레드 A 가 lock 을 가지고있으므로, 스레드 B는 실행시간 내내 아무런작업도 못한채 대기만 하다가 '준비'상태로 전환
* 스레드 굶주림 문제 발생
	* lock 해제 시점에 스케쥴링되어 무한반복분으로 대기중이던 스레드가 lock 을 얻는 방식
    * 운에 기대는 방식이므로 운이 나빠 계속해서 lock 을 얻지못하고 무한 대기하게되는 스레드 발생 가능
* 바쁜 대기(busy-waits) 문제
	* lock 을 얻지 못하면 아무런 작업 없이 무한반복문을 계속 실행하며 CPU 점유
	* 스케쥴러에 의해 준비상태로 전환될떄까 CPU 자원 낭비 
* 불완전한 상호 배제
	* lock 메서드에서 무한반복문을 통과하고 lock.setFlag(UNAVALIABLE) 수행직전에 컨텍스트 스위칭 발생시 임계영역에 대한 상호배제 손상
	* 인터럽트 제어, 피터슨 알고리즘, 티켓락 등의 방법으로 해결 가능

### 성능 평가
* 정확성
	* 임계영역에 대한 상호배제를 보장하지 못함
* 공정성
	* 스레드 굶주림 문제 발생
* 성능
	* 과도한 스핀문제, 바쁜 대기 문제로 성능 저하

<br>

# 티켓 락
```java
private int moveCur(int* cur) {
	int curTurn = &cur;
	*cur = curTurn + 1;
	return curTurn;
}

private void lock(lock_t* lock) {
	int myTurnNum = moveCur(lock->ticket);		//대기번호(ticket)를 옮긴다. 마지막 대기번호 + 1 를 반환한다.
	while(myTurnNum != lock -> turn);
}

private void unlock(lock_t* lock) {
	moveCur(lock -> turn);		//실행번호(ticket) 를 옮긴다. 현재 실행이 끝난 실행번호 + 1 를 반환한다.
}
```
* 임계영역에 대한 상호배제를 보장하는 스핀락
* 대기중인 스레드들에 FIFO 방식으로 실행 순서를 부여하여 일종의 스케쥴링처럼 동작하는 락
* lock 이 실행번호, 대기번호 2개의 상태를 가지고있어, 임계영역에 접근하는 스레드 순서대로 실행순서 부여 가능
### 성능 평가
* 정확성
	* 임계영역에 대한 상호배제 보장
* 공정성
	* 대기중인 스레드들에 명시적 실행 순서를 부여하므로 일정시간 대기 후 반드시 실행됨을 보장(스레드 굶주림 해소)
* 성능
	* 바쁜 대기문제, 과도한 스핀문제로 성능 저하

<br>

# 양보락
* 임계영역이 이미 사용중일시, 다른 스레드에 cpu 양보하고 스스로 준비상태로 전환하는 락
* 스핀락의 과도한 스핀문제, 바쁜 대기문제 해결

### 무조건 양보
* '실행' 상태인 스레드가 획득하고자 하는 lock이 이미 사용중이라면, 스스로 '준비'상태로 전환(yield())하여 CPU 를 다른 스레드에게 양보
* 다른 스레드에게 양보시 문맥 교환 비용 발생
	* 동일한 lock을 얻고자 대기중인 스레드가 많을 경우, 그만큼 문맥교환이 많이 발생하여 문맥교환비용이 커짐
	* '준비'상태인 스레드 99개가 동일한 lock 을 얻기 위해 대기중이라면, Round-Robin 스케쥴러일경우 해당 lock 이 해제되기 위해 99번의 문맥교환 발생
* 스레드 굶주림 문제 발생

### 대기 큐
* lock 에 스레드 대기 큐를 두어 lock 을 얻기 위해 대기중인 스레드 저장
* 스레드가 lock 호출시, lock 이 사용중인 상태일경우, 자신을 lock 의 대기큐에 insert 하고 CPU 양보(yield())
* 스레드가 작업 완료후 unlock 호출시, lock의 스레드 대기큐에서 dequeue 하여 '준비'상태로 대기하던 스레드 순차 실행
* 과도한 스핀문제, 스레드 굶주림 문제 해결
* 꺠우기/대기 문제 발생 가능