# 주소공간
* 메모리 가상화를 통해 프로세스당 부여하는 독립적인 가상 메모리 공간

### 등장 배경
* 시분할 멀티프로그래밍(Round Robin 스케쥴링) 이 각광을 받으며 프로세스 컨텍스트 스위칭 빈번히 발생
* 과거 컨텍스트 스위칭시 전환 시점의 프로세스 모든 상태를 메모리에서 디스크에 저장
* 디스크의 느린 속도로 인해 컨텍스트 스위칭시간이 오래걸리고 멀티프로그래밍 효율 저하
* 컨텍스트 스위칭시 프로세스 상태를 디스크에 저장하지 않고 메모리에 그대로 가지고있음으로서 효율저하 해결
* 프로세스 상태를 메모리에 그대로 유지 하기 위해 프로세스당 독립적인 메모리 공간 부여( = 주소 공간)

<br>

# 주소공간 구조

![image](https://user-images.githubusercontent.com/48702893/90977303-5baea180-e57f-11ea-9f8d-40fa5a56c4c9.png)

### 코드 영역
* 주소공간 최상단(시작부분)에 위치
* 프로세스가 실행중인 프로그램의 명령어(코드)를 저장하는 영역
* 프로그램 코드는 크기가 고정되어있기때문(실행중에도 바뀌지않음)에 시작부분에 위치해도 무방 (저장되어있는 메모리 공간크기가 바뀌지 않음)  

### 힙
* 코드 영역 하단에 위치
* 동적 메모리 할당 영역(객체, 배열 등 저장)
   > int* arr = (int*)malloc(sizeof(int) * size);  --> 힙에 size * sizeof(int) 만큼의 크기 저장
* 프로그램 실행 중에 동적으로 크기가 바뀌기 때문에 코드 영역 바로 밑에 위치하여 하단으로 동적 확장

### 스택
* 주소 공간 최하단(끝부분)에 위치
* 프로그램 실행 중 컴파일러에 의해 암묵적으로 사용되는 영역(변수, 파라미터, 반환값 등 저장)
   > int a = 0;  --> 스택에 컴파일러가 자동 저장
* 힙과 마찬가지로 프로그램 실행 중에 동적으로 크기가 바뀌기 때문에 주소공간 최하단에 위치하여 상단으로 동적 확장

<br>

# 가상 주소 변환
* 프로세스는 자신이 사용중인 메모리 공간을 가상 메모리공간이 아닌, 물리 메모리 공간으로 인식
* 따라서 메모리 주소 참조시 시작 주소를 0 으로 하여 참조
* 운영체제는 프로세스가 참조하는 이런 주소를 실제 물리 메모리의 주소로 자동 변환 해줌

![image](https://user-images.githubusercontent.com/48702893/90977174-53099b80-e57e-11ea-9a42-6a8ab661db8f.png) 

<br>

# 메모리 가상화 원칙
### 투명성
* 프로세스가 자신에게 주어진 주소공간을 가상메모리가 아닌, 물리메모리처럼 인식하고 동작해야함

### 효율성
* 시간적, 공간적 측면에서 효율적이도록 메모리 가상화 수행

### 보호와 고립
* 각 프로세스가 각자의 고유 영역내에서만 고립된채로 동작하도록 메모리 가상화하여 다른 프로세스의 동작이나 운영체제에 영향을 주지 않게 해야함
