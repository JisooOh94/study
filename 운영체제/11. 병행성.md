# 스레드
* 하나의 프로세스 내에서 여러개의 실행 흐름을 두기 위한 모델(여러개의 작업을 동시에 수행하기 위한 모델)
* 프로세스 내에서 실제로 작업을 수행하는 주체

### 프로세스와 스레드
* 프로세스는 운영체제로부터 자원을 할당받는 단위
* 스레드는 프로세스가 할당받은 자원을 이용하는 실행의 단위
* 실질적인 연산 및 작업은 모두 스레드가 수행
* 프로세스 상태(실행, 준비, 대기) 또한 실질적으론 프로세스의 상태가 아닌, 프로세스에 속해있는 스레드들의 상태
   * 스레드들중 하나라도 실행되고있는게 있으면 그 프로세스는 실행 상태

### 스레드 메모리 구조
* 프로세스에게 할당된 주소공간 중 힙, 코드 영역은 공유하고 스택, 레지스터는 스레드 개별적으로 생성
* 주소공간의 최상단에 힙, 최하단에 스택을 배치하여 서로 반대방향으로 확장하므로 동적 크기 확장이 가능했으나, 멀티스레드 환경에선 스레드별로 스택을 할당하므로 스택의 동적 크기 확장 불가능
* 스레드들은 각각 독립적으로 자신에게 할당된 함수를 수행(개별적으로 main 함수 가지고있음)
	* 함수 수행에 사용되는 변수들(파라미터, 반환값, 지역변수)을 저장하는 공간이 스택이므로 각각의 스레드에 개별적인 스택영역 필요
	* 스택의 정보를 담고 있는 stack pointer 레지스터, frame pointer 레지스터 또한 개별적으로 필요
	* 스레드별로 함수 수행이 독립적으로 진행되기때문에, 프로그램 카운터 레지스터 또한 개별적으로 필요
		> 프로그램 카운터 : 실행해야할 명령어의 위치(명령어가 저장되어있는 메모리의 코드영역내 주소)를 가리키는 레지스터

### 메모리 관점에서의 멀티 프로세스 vs 멀티 스레드
* 멀티 프로세스
	* 각 프로세스 간 독립적인 메모리 공간 사용
	* 장점
		* 프로세스간 메모리 공간이 독립되어 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지 않음
	* 단점
		* Context Switching 시 CPU에 저장되어있던 레지스터 교체 뿐만 아니라, MMU 에 저장되어있는 TLB 캐시데이터까지 초기화해야하므로 많은 오버헤드 발생
		* 멀티스레드에 비해 더 많은 메모리 공간 사용
		* 프로세스간 데이터 통신 비용이 비쌈
* 멀티 스레드
	* 스레드간 힙,코드 영역 공유
	* 장점
		* Context Switching시, TLB 캐시데이터 초기화가 필요 없어 오버헤드가 적고 속도가 빠름
		* 메모리의 힙,코드영역을 공유하므로 프로세스에 비해 더 적은 메모리 공간 사용
		* 스레드 생성이나 스택 영역 할당시 프로세스(프로세스 생성, 가상메모리 할당등)와 같은 SystemCall 수행이 필요없어, 오허베드가 적음
		* 힙 영역을 공유하므로 스레드간 데이터 교환이 쉬움
	* 단점
		* 자원을 공유하므로 하나의 스레드에서 장애 발생시, 다른 스레드에 전파
		* 자원을 공유하므로 동기화 이슈로 인한 락대기, 병목현상, 데드락

<br>

# 멀티스레딩과 원자성
* 하나의 프로세스의 작업을 여러 스레드에 나누어 동시에 처리하는것
* 스레드도 프로세스와 마찬가지로 상태값(준비, 대기, 실행)을 가지며, 스레드 스케줄러 정책에 따라 각 스레드 실행 순서가 결정됨
* '준비' 상태에 있는 스레드의 실행 시점은 스케줄러에 의해 결정되므로 개발자가 미리 알 수도 없고 매번 실행때마다 달라짐 
* 또한 힙영역을 공유하기 때문에, 스레드 실행 결과가 실행된 시점에 따라 매번 달라짐 
   * 특정 시점에 힙에 저장되어있는 공유자원에 수정을 가했던 스레드의 수 및 내용이 매번 달라짐
      
### 공유 리소스 문제 발생 케이스
* 스레드가 공유 자원 수정 도중 컨텍스트 스위칭이 일어나 준비상태로 되고, 다시 실행 상태가 되기전에 다른 스레드에 의해 해당 공유자원이 수정되면 정합성 손상 발생  
```java
private static Integer num = 0;

private void add() {
	num++;
}

//assembly
mov 0x30 %eax			//30 주소에 있던 값을 스레드 자신의 레지스터 eax에 저장
add 0x01	%eax			//자신의 레지스터 eax 에 있는 값이 1 더하기
mov %eax	0x30			//1이 더해진 자신의 레지스터 eax 에 있는 값을 다시 30 주소에 저장
```
* add 함수를 실행하던 스레드 A 가 첫번째 mov 명령 실행 후 스케쥴러에 의해 준비 상태로 전환
   * 0x30 : 0, A-eax : 0
* 스레드 B 가 동일한 add 함수 끝까지 실행
   * 0x30 : 1, A-eax : 0, B-eax : 1
* 스레드 A 가 다시 실행상태가 되어 끝까지 실행
   * 0x30 : 1, A-eax : 1, B-eax : 1 -> 스레드 B의 실행 결과값 덮어씌워짐
 
### 원자성
* 위와같은 멀티스레딩시 발생하는 공유 리소스 문제는 하드웨어적 원자성 이나 소프트웨어적 원자성(상호배제)를 통해 해결
* 하드웨어적 원자성
   * 여러개의 명령어(mov, add, mov)로 이루어진 작업을 하나의 명령어(memory-add : 레지스터로 값 복사 없이 메모리에 직접 수정) 로 교체
   * 명령어 수행 중간이란것을 없애어 명령어 수행중간에 문맥교환이 발생할 가능성을 원천 차단하는 방식(전무 또는 전부인 상태만 존재하고 중간 상태를 없앰)
   * 하지만 일반적으로 여러 명령어로 이루어진 작업을 교체할 수 있는 하나의 명령어는 거의 없어, 트랜잭션을 활용하거나 상호배제를 통해 주로 해결
   * 트랜잭션 : 여러개의 명령어를 묶어 하나의 명령어처럼 동작하도록 처리하는것
* 상호배제(Mutual Exclusion)
   * 한 스레드가 임계영역 코드를 수행중(또는 공유 리소스 사용중)에는 다른 스레드가 같은 임계 영역 코드를 수행 할 수 없도록(또는 같은 공유 리소스를 사용할 수 없도록) 하는것
   * 임계영역(Ciritical Section) : 공유자원이 사용되는 영역. 한번에 하나의 스레드/프로세스만 수행할 수 있어야 함

<br>

# 상호배제 장치 종류
### 유저 모드 동기화
* 커널의 자원을 이용하지 않고 동기화 수행하기때문에 커널모드로 전환이 이루어지지 않아 성능이 좋음
* 프로세스간 동기화는 불가능
* Critical Section

### 커널 모드 동기화
* 동기화 과정에서 커널 자원을 이용하기떄문에 커널모드로 전환되어 성능이 떨어짐
* 프로세스간 동기화 가능
* Mutex, Semaphore, Monitor

***
> Reference
> * https://wooody92.github.io/os/%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C/
> * https://darrengwon.tistory.com/763