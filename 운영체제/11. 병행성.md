# 스레드
* 하나의 프로세스 내에서 여러개의 실행 흐름을 두기 위한 모델(여러개의 작업을 동시에 수행하기 위한 모델)
* 프로세스 내에서 실제로 작업을 수행하는 주체

### 프로세스와 스레드
* 프로세스는 스레드를 담는 컨테이너
* 실질적인 연산 및 작업은 모두 스레드가 수행
* 프로세스 생성시, 메인 스레드 1개도 함께 생성
* 프로세스 상태(실행, 준비, 대기) 또한 실질적으론 프로세스의 상태가 아닌, 프로세스에 속해있는 스레드들의 상태
   * 스레드들중 하나라도 실행되고있는게 있으면 그 프로세스는 실행 상태
* 프로세스 스케줄러가 스케줄링 하는것도 프로세스가 아닌, 스레드
* 프로세스 컨텍스트 스위칭도 내부적으론 서로 다른 프로세스에 속해있는 스레드간 컨텍스트 스위칭

### 스레드 메모리 구조
* 프로세스에게 할당된 주소공간 중 힙, 코드 영역은 공유하고 스택, 레지스터는 스레드 개별적으로 생성
* 스레드들은 각각 독립적으로 자신에게 할당된 함수를 수행하고(개별적으로 main 함수 가지고있음), 이런 함수 수행에 사용되는 변수들(파라미터, 반환값, 지역변수)을 저장하는 공간이 스택이므로 각각의 스레드에 개별적인 스택영역 필요
   * 스택의 정보를 담고 있는 stack pointer 레지스터, frame pointer 레지스터 또한 스레드 각각 개별적으로 생성
   * 주소공간의 최상단에 힙, 최하단에 스택을 배치하여 서로 반대방향으로 확장하므로 동적 크기 확장이 가능했으나, 멀티스레드 환경에선 스레드별로 스택을 할당하므로 스택의 동적 크기 확장 불가능
* 스레드별로 함수 수행이 독립적으로 진행되기때문에, 프로그램 카운터 레지스터 또한 개별적으로 생성
   * 프로그램 카운터 : 실행해야할 명령어의 위치(명령어가 저장되어있는 메모리의 코드영역내 주소)를 가리키는 레지스터

### 스레드간 메모리(힙,코드) 공유를 통한 장/단점
* 장점
   * 스레드간 컨텍스트 스위칭시 스택, 레지스터 데이터만 전환하면 되기때문에 스위칭이 빠르게 이루어진다.
      * 프로세스의 경우, 모든 메모리 데이터 및 캐시메모리까지 전환해야하기때문에 스위칭 비용이 커, 멀티프로세싱 효율이 떨어짐
   * 힙영역을 공유하기 때문에, 서로 다른 작업을 하는 스레드간 통신 및 데이터 공유가 용이
      * 프로세스 간 통신의 경우, 메모리 공간을 공유하지 않기때문에 별도의 IPC(Inner Process Communication)라는 작업을 통해 데이터 공유 
* 단점
   * 힙에 저장되어있는 하나의 자원을 동시에 여러개의 스레드가 접근하여 사용하려는 경합 발생 가능 

<br>

# 멀티스레딩
* 하나의 프로세스의 작업을 여러 스레드에 나누어 동시에 처리하는것
* 스레드도 프로세스와 마찬가지로 상태값(준비, 대기, 실행)을 가지며, 스레드 스케줄러 정책에 따라 각 스레드 실행 순서가 결정됨
* '준비' 상태에 있는 스레드의 실행 시점은 스케줄러에 의해 결정되므로 개발자가 미리 알 수도 없고 매번 실행때마다 달라짐 
* 또한 힙영역을 공유하기 때문에, 스레드 실행 결과가 실행된 시점에 따라 매번 달라짐 
   * 특정 시점에 힙에 저장되어있는 공유자원에 수정을 가했던 스레드의 수 및 내용이 매번 달라짐
      
### 공유 리소스 문제 발생 케이스
* 스레드가 공유 자원 수정 도중 컨텍스트 스위칭이 일어나 준비상태로 되고, 다시 실행 상태가 되기전에 다른 스레드에 의해 해당 공유자원이 수정되면 정합성 손상 발생  
```java
private static Integer num = 0;

private void add() {
	num++;
}

//assembly
mov 0x30 %eax			//30 주소에 있던 값을 스레드 자신의 레지스터 eax에 저장
add 0x01	%eax			//자신의 레지스터 eax 에 있는 값이 1 더하기
mov %eax	0x30			//1이 더해진 자신의 레지스터 eax 에 있는 값을 다시 30 주소에 저장
```
* add 함수를 실행하던 스레드 A 가 첫번째 mov 명령 실행 후 스케쥴러에 의해 준비 상태로 전환
   * 0x30 : 0, A-eax : 0
* 스레드 B 가 동일한 add 함수 끝까지 실행
   * 0x30 : 1, A-eax : 0, B-eax : 1
* 스레드 A 가 다시 실행상태가 되어 끝까지 실행
   * 0x30 : 1, A-eax : 1, B-eax : 1 -> 스레드 B의 실행 결과값 덮어씌워짐
 
### 원자성
* 위와같은 멀티스레딩시 발생하는 공유 리소스 문제는 하드웨어적 원자성 이나 소프트웨어적 원자성(상호배제)를 통해 해결
* 하드웨어적 원자성
   * 여러개의 명령어(mov, add, mov)로 이루어진 작업을 하나의 명령어(memory-add : 레지스터로 값 복사 없이 메모리에 직접 수정) 로 교체
   * 명령어 수행 중간이란것을 없애어 명령어 수행중간에 문맥교환이 발생할 가능성을 원천 차단하는 방식(전무 또는 전부인 상태만 존재하고 중간 상태를 없앰)
   * 하지만 일반적으로 여러 명령어로 이루어진 작업을 교체할 수 있는 하나의 명령어는 거의 없어, 트랜잭션을 활용하거나 상호배제를 통해 주로 해결
   * 트랜잭션 : 여러개의 명령어를 묶어 하나의 명령어처럼 동작하도록 처리하는것
* 상호배제(Mutex : Mutual Exclusion)
   * 한 스레드가 임계영역 코드를 수행중(또는 공유 리소스 사용중)에는 다른 스레드가 같은 임계 영역 코드를 수행 할 수 없도록(또는 같은 공유 리소스를 사용할 수 없도록) 하는것
   * 임계영역 : 공유자원을 접근하고, 하나 이상의 스레드에서 동시에 실행되면 안되는 코드영역