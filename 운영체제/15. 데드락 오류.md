# 데드락
* 두 스레드가 서로 상대방이 소유하고 있는 락을 대기하는 문제
* 락 획득에 사이클이 존재하는 경우 발생
   * lock_1 > lock_2 순서로 얻어 임계영역 작업을 수행하는 스레드 A 와 lock_2 > lock_1 순서로 얻어 임계영역 작업을 수행하는 스레드 B
   * 스레드 A 가 lock_1을 얻은 후 문맥교환, 스레드 B가 lock_2 를 얻은 후 다시 문맥교환
   * 스레드 A 는 lock_2를 얻고자 하나 이미 사용중이므로 lock_1을 소유한 채로 다시 문맥교환
   * 스레드 B 는 lock_1를 얻고자 하나 이미 사용중이므로 lcok_2를 소유한 채로 다시 문맥교환
   * 두 스레드는 서로가 가지고 있는 lock 을 얻기 위해 무한히 문맥교환하는 데드락 발생

### 락 획득에 사이클 발생 이유
1. 프로그램이 커지며 코드가 복잡해져서 락 획득 사이클이 의도치 않게 발생
2. 써드파티 라이브러리들의 내부 동작로직이 (캡슐화 원칙에 따라)감춰져있어, 현재 코드에 사용되었을시 사이클이 발생할지 확인할 수 없음

# 데드락 예방 방법
### 1. 락 획득 순서 지정
* 프로세스에 여러개의 lock이 존재할경우, 각 lock의 획득 우선순위를 정하여 락획득 사이클 발생 가능성 제거
   * e.g. lock_1, lock_2 가 존재할 경우, lock_1 을 가지고있는 스레드만이 lock_2 를 요청할 수 있도록 설정
* 프로그램이 커져 프로세스내의 lock 의 개수도 많고 복잡해 전체 lock의 우선순위를 설정할 수 없을경우 , 서로 의존관계가 있는 lock 들끼리 묶어 각 묶음 내의 lock 획득 우선순위 설정


### 2. 락 획득 프로세스 원자화
* 하나의 스레드 작업에서 여러개의 임계영역이 중첩되어있을경우, 각 임계영역의 lock을 얻는 코드를 코드 첫부분에 모은후 원자화
```java
//AS-IS -------------------
lock(lock_1);
//execute lock_1 job

lock(lock_2);
//execute lock_2 job

unlock(lock_1);
unlock(lock_2);

//TO-BE -------------------
lock(lock_t)
lock(lock_1);
lock(lock_2);
unlock(lock_t);

//execute lock_1 job
//execute lock_2 job

unlock(lock_1);
unlock(lock_2);
```
* lock 을 획득하는 과정에서 문맥교환이 발생하지 않도록 하여, 락 획득 사이클 발생 가능성 제거

### 3. 락 양보
* 하나의 스레드 작업에서 여러개의 lock을 얻어야 하는경우, 작업 시작전, 필요한 모든 lock을 얻지 못하면 소유하고있던 lock 들도 반납 후 재시도
* trylock 루틴 사용
```java
while(true) {
	lock(lock_1)
	if(trylock(lock_2) == true) break;
	else continue;
}
```
* 절묘한 타이밍으로 두 스레드가 동시에 trylock 루틴 수행시 사이클 발생이 가능하고, 무한반복문을 통한 대기로 인해 프로세스 낭비가 발생하므로 효율성이 떨어짐

### 4. 명시적 스레드 스케쥴링
* 동일한 임계영역을 사용하는 여러 스레드가 동시에 수행되고 있을경우, 각 스레드의 실행순서를 락획득 사이클이 발생하지 않도록 명시적으로 스케쥴링 하는것
* 임베디드 시스템에서의 정해진 작업 수행과 같이 실행될 모든 스레드와 각 스레드가 요청하는 락들을 모두 미리 알고 있어야 사용 가능 

### 5. 허용 및 복구
* 데드락 발생을 허용, 데드락 발생시 프로그램 재시작 
* 백그라운드에서 프로세스내의 데드락을 탐색하는 스레드를 두어 주기적으로 실행하여 데드락 발견시 복구프로세스 수행(주로 재부팅)
* 데드락이 가끔 발생하고, 발생하는 데드락들이 복구 가능한 교착상태일때에만 사용 가능
   * e.g. 교착상태가 발생한 스레드가 사용자 정보를 수정하는 스레드일경우 복구 불가능