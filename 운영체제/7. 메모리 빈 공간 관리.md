# 메모리 공간 관리
* 프로그래머가 직접 할당, 해제하는 힙메모리의 경우 보통 세그멘테이션(가변 크기 할당) 기법으로 메모리가 할당
* 세그멘테이션 기법의 단점인 메모리 단편화(외부단편화) 발생
   * 메모리 단편화 발생시, 실제 빈공간 전체크기에 비해 사용(할당) 가능한 메모리가 줄어듦
   * 링킹을 통해 떨어져있는 빈공간에 할당이 가능해져도 조회 성능이 떨어짐
* 단편화가 발생하여 서로 떨어져있는 빈 메모리 공간은 일반적으로 메모리 주소 링크드 리스트로 관리

<br>

# 메모리 사용 과정
### 메모리 할당 과정(malloc)
1. 탐색
* 빈 메모리 공간 주소 링크드 리스트에서 할당 요청이 들어온 객체 크기보다 큰 메모리 공간(청크) 주소 탐색

2. 분할
* 탐색된 메모리 공간을 필요한 크기만큼만 분리하여 객체 할당하고 나머지는 다시 메모리 리스트에 저장

### 메모리 해제 과정(free)
1. 공간 범위 확인
* 해제 요청이 들어온 메모리 주소의 메타데이터헤더를 참조하여 해제될 메모리 공간 범위 확인

2. 해제 및 리스트 추가
* 메모리 공간에 할당되어있던 데이터 해제 후, 메모리 리스트에 추가 

3. 병합
* 메모리 리스트 추가시, 해제된 공간에 인접해있는 공간들이 메모리 리스트에 존재하는지(비어있는지) 확인 후, 존재한다면 노드 병합

<br>

# 청크 헤더
* 메모리 공간 할당시, 단순히 객체만 빈공간에 저장하는것이 아닌, 할당될 공간에 대한 메타데이터도 따로 헤더공간을 할당하여 저장
* 따라서 객체를 저장할 힙 메모리 공간 탐색시, 객체 크기 + 헤더 크기 보다 큰 공간 탐색
* 청크헤더엔 할당된 메모리 공간 크기, 무결성검사를 위한 매직넘버 등 여러 메타데이터 저장
* 메모리 해제시, 청크헤더의 할당된 메모리공간크기 정보를 참조하여 해제할 메모리 공간 범위 산정 

<br>

# 빈 메모리 공간 리스트 탐색 알고리즘
### 최적 적합
* 빈 메모리 리스트중, 필요한 공간크기와 가장 비슷한 크기의 청크 반환 알고리즘
* 메모리 공간 낭비를 줄일 수 있으나 전체 메모리리스트를 탐색해야하므로 시간이 오래걸림 

### 최악 적합
* 빈 메모리 리스트중, 가장 큰 청크 반환 알고리즘
* 작은 청크 대신 큰 하나의 청크를 유지(?), but 전체 메모리리스트를 탐색하여 시간도 오래걸리고 메모리 단편화도 많이 발생

### 최초 적합
* 빈 메모리 리스트중, 첫번쨰로 탐색되는 할당 가능한 크기의 청크 반환
* 전체 리스트를 탐색하지 않으므로(최악의 경우엔 전체 리스트 탐색하게됨) 탐색속도 빠르나 메모리 앞부분에 단편화 집중
* 전체 리스트를 탐색하게되는(할당 가능한 크기의 청크가 리스트 맨 뒤에 있는경우) 최악의 경우를 방지하기 위해 빈 메모리 리스트 정렬 방식이 중요 

### 다음 적합
* 빈 메모리 리스트중, 마지막으로 할당된 메모리 노드에서부터 최초 적합 수행
* 메모리 앞부분에 단편화가 집중되는 문제 완화, 탐색 속도 빠름