# 필수 의존성
* spring-boot-starter-webflux
* spring-boot-starter-web 과 같은 타 starter 와 함께 사용할경우 정상적으로 동작 안할 수 있으므로 충돌 여부 확인 필요
	* spring-boot-starter-web 와 spring-boot-starter-webflux 가 함꼐 추가되었을 경우, MVC 웹 애플리케이션 생성됨[[관련 내용]](https://stackoverflow.com/questions/51377675/dont-spring-boot-starter-web-and-spring-boot-starter-webflux-work-together) 
```java
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
```

<br>

# Controller 프로그래밍 모델
### 어노테이션 모델(Annotated Controllers)
* 기존의 Spring Web MVC 에서 사용하던 @Controller, @RequestMapping 어노테이션을 이용한 컨트롤러 등록 방식
* 기존 MVC기반 프로젝트를 Reactive 로 전환시 전환 비용을 절약할 수 있다는 장점 존재

### 함수형 모델(Functional Endpoints)
* 람다 기반 함수형 프로그래밍 모델에 맞춰 개발된 컨트롤러 등록방식
* @Controller, @RequestMapping 어노테이션 대신 Handler, Router 를 통해 컨트롤러 등록
* MVC 와 달리 POJO 를 반환할 수 없고 반드시 Mono, Flux와 같은 Publisher Object로 감싸서 반환
* MVC 방식 보다 함수형 프로그래밍 패러다임에 더 적합하다는 장점이 있으나, 가독성이 떨어지고 Spring validation, swagger 등의 기존 MVC에서 사용하던 어노테이션 기반 모듈들을 사용할 수 없다는(별도 처리를 통해 사용 가능) 단점 존재

<br>

# Mono, Flux
* 데이터를 제공하는 Publisher 의 구현체

### Flux
* 0-N개의 데이터 전달
* 하나의 데이터 전달할때마다 Subscriber 의 onNext 호출, 더이상 전송할 데이터가 없을시 onComplete 호출
* Flux 생성 팩토리 메서드
	* just(T... data) : 인자로 전달된 data 들을 emit 하는 Flux 생성 
	* range(int start, int count) : start 부터 시작하여 count 만큼의 정수를 emit 하는 Flux 생성 
	* fromArray(T[]), fromIterable(Iterable<? extends T>), fromStream(Stream<? extends T>) : 인자로 전달된 Collection 의 elements 를 emit 하는 Flux 생성  
	* empty : 아무 데이터도 emit 하지 않고 complete 되는 Flux 생성

### Mono
* 0-1개의 데이터 전달
* onNext 가 한번만 호출
* Mono 생성 팩토리 메서드
	* just(T data)
	* empty

### subscribe
* Flux, Mono 는 subscribe 가 호출되기전까지 어떠한 작업도 수행하지 않음
* Flux.subscribe/Mono.subscribe 가 호출되어야 비로소 IO 작업 수행후 subscriber 에게 데이터 전송
* subscribe 호출시 인자로 전송받은 데이터를 처리할 Consumer 를 전달하면, Subscriber.onNext 수행시 내부에서 consumer 호출하여 수행
```java
Flux<String> flux = Flux.just("A", "B").log();

logger.info("not yet started");

flux.subscribe(data -> logger.info("received data : " + data));
```
```java
//console.log
INFO main - not yet started
INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
INFO reactor.Flux.Array.1 - | request(unbounded)
INFO reactor.Flux.Array.1 - | onNext(A)
INFO main - received data : A
INFO reactor.Flux.Array.1 - | onNext(B)
INFO main - received data : B
INFO reactor.Flux.Array.1 - | onComplete()
```

# ServerRequest, ServerResponse
* Reactive 를 지원하는 HttpServletRequest, HttpServletResponse
* body 데이터를 publisher(Mono, Flux) 로 제공
	* BodyExtractors 를 통해 추출 가능
	```java
	Mono<String> bodyMono = request.body(BodyExtractors.toMono(String.class));
	Flux<Object> bodyFlux = reqeust.body(BodyExtractors.toFlux(Object.class));
	//bodyToMono, bodyToFlux 로 축약 가능
	Mono<String> bodyMono = request.bodyToMono(String.class);
	Flux<Object> bodyFlux = reqeust.bodyToFlux(Object.class);
	```
* ServerResponse 생성시 BodyBuilder 이용
```java
Mono<ServerResponse> serverResponseMono = ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).contentLength(1024).body(BodyInserters.fromValue("value"))
```

# Cold, Hot stream
***
> Reference
https://dreamchaser3.tistory.com/13 <br>
https://godekdls.github.io/Reactive%20Spring/springwebflux2/ <br>
https://dreamchaser3.tistory.com/13 <br>
