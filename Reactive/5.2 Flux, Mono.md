# Mono, Flux
* 데이터를 제공하는 Publisher 의 구현체

### Flux
* 0-N개의 데이터 전달
* 하나의 데이터 전달할때마다 Subscriber 의 onNext 호출, 더이상 전송할 데이터가 없을시 onComplete 호출

### Mono
* 0-1개의 데이터 전달
* onNext 가 한번만 호출

<br>

# subscribe
* Flux, Mono 는 subscribe 가 호출되기전까지 어떠한 작업도 수행하지 않음
* Flux.subscribe/Mono.subscribe 가 호출되어야 비로소 IO 작업 수행후 subscriber 에게 데이터 전송
* subscribe 호출시 인자로 전송받은 데이터를 처리할 Consumer 를 전달하면, Subscriber.onNext 수행시 내부에서 consumer 호출하여 수행
```java
Flux<String> flux = Flux.just("A", "B").log();

logger.info("not yet started");

flux.subscribe(data -> logger.info("received data : " + data));
```
```java
//console.log
INFO main - not yet started
INFO reactor.Flux.Array.1 - | onSubscribe([Synchronous Fuseable] FluxArray.ArraySubscription)
INFO reactor.Flux.Array.1 - | request(unbounded)
INFO reactor.Flux.Array.1 - | onNext(A)
INFO main - received data : A
INFO reactor.Flux.Array.1 - | onNext(B)
INFO main - received data : B
INFO reactor.Flux.Array.1 - | onComplete()
```

<br>

# map, flatMap 차이
### map
* mapper 인 Function 의 파라미터, 리턴타입이 모두 Object
* 따라서 Function 내부에서 Object 타입 반환해야함
* API interface
```java
Mono<R> map(Function<? super T,? extends R> mapper)
```
* Example
```java
Mono<Integer> result = Mono.just("1")
	.map(val -> { return Integer.parseInt(val); });
```

### flatMap
* mapper 인 Function 의 파라미터는 Object 이나, 리턴타입은 Publisher
> mapper 에서 반환한 Publisher 를 flatten 후 map 수행 <br>
> Mono<Mono<String>> -> Mono<String> -> Mono<Integer> 
* 따라서 Function 내부에서 Mono/Flux 타입 반환해야함
* API interface
```java
Mono<R> flatMap(Function<? super T,? extends Mono<? extends R>> transformer)
```
* Example
```java
Mono<Integer> result = Mono.just("1")
   	.flatMap(val -> { return Mono.just(Integer.parseInt(val)); });
```
```java
Mono<Map<String,Object>> invokeResult = webClient.get().retrieve().bodyToMono(Map.class).flatMap(result -> {
   			if(MapUtils.isEmpty(result)) {
   				return Mono.error(new ApiInvokeException());
   			} else {
   				return Mono.just(result);
   			}
   		});
```

### Flux.map, Flux.flatMap 차이[[참고]](https://www.baeldung.com/java-reactor-map-flatmap)
> 기본적인 object, publisher 반환 차이는 동일
* Flux.map
	* Flux 가 emit 하는 element 에 synchronous 하게 mapper 적용하여 반환
	* 따럿 Flux 의 element 순서와 map 수행한 결과의 element 순서는 동일함을 보장
* Flux.flatMap
	* Flux 가 emit 하는 element 에 synchronous 하게 mapper 적용하여 Publisher 반환
	* flatten 작업과정에서 mapper 를 통해 반환된 publisher subscribe 시, asynchronous 하게 동작
		> flatten 작업을 기다리지 않고 Flux 가 emit 하는 바로 다음 element 에 대한 처리 시작
	* 성능상 더 효율적이나 Flux 의 element 순서와, flatMap 한 결과의 element 순서가 동일하지 않을 수 있음
	* 따라서 Flux 의 형태변환시 성능을 위해 가급적 flatMap 을 사용하되, 순서의 동일함이 보장되어야한다면, flatMapSequential 로 대체

<br>

# 예외처리



<br>

***
> reference
> * http://wonwoo.ml/index.php/post/category/web/spring
> * https://dreamchaser3.tistory.com/17
> * https://dreamchaser3.tistory.com/6
> * https://dreamchaser3.tistory.com/6
> * https://okky.kr/article/734519
> * https://godekdls.github.io/Reactor%20Core/appendixawhichoperatordoineed/
> * https://brunch.co.kr/@lonnie/17