# Reactive 기본 개념
* 옵저버 패턴 기반의 논블로킹 비동기 방식 사용자 요청 처리 방법
* 사용자 요청 처리 과정에서 수행되는 IO 작업들을 논블로킹, 비동기적으로 수행함으로서 스레드 및 자원을 효율적으로 사용

### AS-IS(Blocking, Sync)
![image](https://user-images.githubusercontent.com/48702893/109412880-e4eed700-79ed-11eb-977e-a9b960318dca.png)
* 응답시간 : 각 IO 작업 수행시간의 총합

### TO-BE(Non-Blocking, Async)
![image](https://user-images.githubusercontent.com/48702893/109412882-e7513100-79ed-11eb-8d43-d18b2786486d.png)
* 응답시간 : IO 작업중 가장 오래 걸린 작업의 수행시간


<img src="https://user-images.githubusercontent.com/48702893/128733391-1346d4ea-f67b-434f-9b18-713d3407f88c.png" width="500" height="300">

<br>

# 등장 배경
### MSA 및 분산시스템
* 시스템이 분산됨에 따라 API 호출, 데이터 엑세스등의 IO 수행시간 대폭 증가

### 멀티스레딩의 한계
* 복잡한 임계영역을 개발자가 직접 컨트롤해야하므로 개발이 어려워지고 버그 가능성도 높아짐
* 멀티스레딩을 이용한 기존의 비동기 방식은 IO 작업 수행중 스레드를 점유하여 컨텍스트 스위칭으로 인한 비효율 발생 및 스레드풀 스레드 부족 문제 발생 가능
	* Reactive 는 Event driven 방식으로 동작하여 스레드 점유 없이 Async 하게 처리(Event Handler 사용)
		1. 메인 스레드에선 IO 작업 요청 후 바로 return 하여 다른 작업 수행 <br>
		2. EventLoop 스레드 에서 이벤트(IO 응답) 수신시 Event Handler 에게 처리 위임 <br>
			2.1 응답 서버가 응답 준비되었다고 Observer 에게 noti 전송 <br>
			2.2 Observer 는 가용한 처리량만큼 응답 서버에게 데이터 요청(백프레셔)
		3. Event Handler 에선 call back 함수를 Event Queue 에 등록 <br>
		4. Event Loop 가 call stack 이 비어있는지 확인하여 Event Queue에 등록되어있는 call back 함수를 call stack으로 옮겨 수행

> 용어정리 <br>
> Lisener : 옵저버 패턴을 활용해 만든 인터페이스 <br>
> Callback : Publisher 가 Subscriber(Observer) 에게 noti를 전송하는것. Observer 는 noti 수신 후 등록된 Callback 메서드 수행

![event-loop](https://user-images.githubusercontent.com/48702893/129528788-c0374bff-8735-4d9e-8c69-021a62b0d642.gif)

<br>

# 장점
### 논블로킹
* IO 작업을 논블로킹으로 처리하기때문에 리소스를 더 효율적으로 사용함(IO 응답을 대기하는것이 아닌, 다른 작업 수행) 
* 그를 통해 더 적은 리소스(쓰레드, CPU, 메모리, 네트워크 등)로 더 많은 요청 처리 가능
* 그에따라 인프라 비용 절감 가능

### 오토스케일링
* 급작스런 요청량 증가에도 안정적으로 동작
* ???

### 백프레셔
* Subscriber 가 처리 가능한 양만큼의 데이터만 Publisher 로부터 pull
* Publisher 가 전송하는 데이터가 Subscriber 의 버퍼에 적체되는 현상을 완화하여 장애방지
* 즉, IO 작업에서의 과도한 부하를 방지하여 IO 작업으로인한 부하가 전체 웹서버로 전파되는 상황 방지

<br>

# 단점
### 디버깅의 어려움
* 직관적으로 에러가 발생한 클래스 메서드와 그 코드 라인까지 보여주는 blcking 방식의 stack trace 에 비해 non-blokcing 방식의 stack trace는 리액티브 체인의 수행과정에 대한 정보만 보여줄뿐, 직접적인 에러 원인이된 코드 위치정보는 유실
	* blocking 방식의 stacktrace
	
	![image](https://user-images.githubusercontent.com/48702893/129766318-03a1d79f-57e7-4d20-96e9-36f862efe534.png)
    
    ![image](https://user-images.githubusercontent.com/48702893/129766330-71525cde-8723-44da-bc3e-2ddb661dcb5d.png)
    
	* non blocking 방식의 stacktrace 
    
    ![image](https://user-images.githubusercontent.com/48702893/129766339-a3b3fee1-57eb-41fc-96bf-b22dabc5938e.png)
    
    ![image](https://user-images.githubusercontent.com/48702893/129766360-9033a64b-affd-42bf-b3b7-0e418bc5db72.png)
    
* 유일하게 보여주는 에러발생 위치도, 실제 에러가 발생한 위치가 아닌, reactive chain의 subscribe 가 호출되는 위치여서 무의미
* 장애발생시, 로그파일에 남은 stacktrace 정보를 통해 원인을 추적하므로, stacktrace 에 유의미한 데이터가 남도록 추가적인 모듈 필요 

### 개발 난이도 증가
* 코드에 blocking 방식으로 동작하는 로직 존재시 성능이 매우 안좋아짐
* 따라서 개발시, 모든 로직이 non blocking 으로 동작하도록 유의해야하고, 써드파티 라이브러리 사용시에도 내부에 blocking으로 동작하는 로직이 있는지 확인 필요 

### 코드 가독성 저하
* 메서드가 stream api 호출의 연쇄로 이루어지고, 이떄 사용되는 stream api 도 너무나 다양
* stream api 연쇄를 거쳐가며 Mono > Flux, Flux > Mono 의 전환이 빈번히 발생
* 이로인해 코드 파악시, 로직의 흐름이 한눈에 안들어고 reactive stream 의 흐름 및 변화를 계속 신경써야함
* 개발시에도, 비즈니스로직 개발에 집중하기 힘들고 non blocking 하게 개발하는데에 신경을 뺏김  

### 높은 러닝커브
* 기존의 blocking 방식의 시퀀셜한 로직 수행이 아닌, non-blocking 방식의 비동기적 수행
* 이에따라 위에서부터 아래로 로직의 흐름을 이해하던 기존의 사고체계와는 전혀 다른방식의 프레임워크이기때문에 학습하고 이해하는데에 오래걸림
* reactive 에서 제공하는, 상황별로 사용해주어야 하는 너무나 많은 연산자들 및 래퍼, stream api 들이 있어 이들을 모두 파악하고 사용하는데에 오래걸림

### 높은 전환비용 
* RDBMS driver 전환 필요(mybis, jpa, jdbc 등 > R2DBC)
* 높은 러닝커브

***
> 참고자료<br>
> https://techblog.woowahan.com/2619/ <br>
> https://juneyr.dev/reactive-programming <br>
> https://dzone.com/articles/raw-performance-numbers-spring-boot-2-webflux-vs-s <br>
> https://devahea.github.io/2019/04/21/Spring-WebFlux%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9D%80-%EB%A6%AC%EC%86%8C%EC%8A%A4%EB%A1%9C-%EB%A7%8E%EC%9D%80-%ED%8A%B8%EB%9E%98%ED%94%BD%EC%9D%84-%EA%B0%90%EB%8B%B9%ED%95%A0%EA%B9%8C/ <br>
> https://poiemaweb.com/js-event
> https://godekdls.github.io/Reactor%20Core/debuggingreactor/#71-the-typical-reactor-stack-trace
> http://gunsdevlog.blogspot.com/2020/09/reactive-streams-reactor-webflux.html
> https://m.blog.naver.com/sthwin/221953620875
<img src="https://user-images.githubusercontent.com/48702893/129197508-0e126286-7b34-41dd-b684-694c20fe98b8.png" width="500" height="300">