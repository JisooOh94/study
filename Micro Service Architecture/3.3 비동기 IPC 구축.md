# 메시징 패턴
* 메시징 패턴을 이용해 비동기 IPC 수행
* 메시지
	* 헤더 + 바디로 구성
	* 데이터 / 커맨드 / 이벤트 등의 정보 표현
* 메시지 채널
	* 메시지가 프로듀싱 / 컨슈밍되는 메시지 보관함
	* 프로듀서 - 컨슈머 관계에 따라 점대점(1:1), 발행-구독(1:N) 메시지 채널 선택
		* 점대점 : 채널을 컨슈밍하는 서버중 하나의 서버를 선택하여 해당 서버만 메시지 컨슈밍 가능
		* 발행-구독 : 채널을 컨슈밍하는 모든 서버가 메시지 컨슈밍 가능

### 메시징 패턴 종류
* 단방향 알림
	* 클라이언트 - 서버 점대점 통신
	* 클라이언트 > 서버로의 메시지 전송만 이루어지고, 서버 > 클라이언트로의 응답은 이루어지지 않는 구조
	* 서버는 수신한 메시지의 처리만 수행한 하고, 수행 결과를 따로 클라이언트에게 전달하지 않음
	* 커맨드 메시지에 주로 사용
* 발행/구독
	* publisher - channel - subscriber 간 통신
	* publisher 와 subsciber는 서로를 몰라도 되며, channel 를 통해 메시지 프로듀싱, 컨슈밍
		* publisher 와 subscriber 간 결합도가 낮으므로 확장성이 더 뛰어남
	* 메시지 토픽별로 channel이 나뉘어져 있음
	* 이벤트 메시지에 주로 사용
* 발행/비동기응답
	* 클라이언트 - 요청 channel, 응답 channel - 서버 간 통신
	* 클라이언트는 요청메시지를 요청 channel 에 발행. 요청 메시지에 응답을 수신할 응답 channel 정보 및 메시지 ID(MessageId) 포함 
	* 서버는 요청 channel 에서 컨슈밍하여 요청 처리후, 그에 대한 응답을 응답 channel 에 발생, 응답 메시지에 메시지 ID(CorrelationId) 포함
	* 클라이언트는 응답 chaneel 에서 응답 메시지 컨슈밍 후, correlationId 를 통해 요청 메시지와 매칭 수행

### 메시징 패턴별 API 인터페이스 작성법
* 단방향 알림 API : 메시지 채널, 메시지 타입과 포맷
* 발행/구독 API : 메시지 채널, 메시지 타입과 포맷
* 발행/비동기응답 API : 메시지 채널, 메시지 타입과 포맷, 응답 메시지의 타입과 포맷

<br>

# 메시지 브로커
* 메시지 채널을 관리한느 별도의 서버
* Producer, Consumer 는 메시지 브로커로부터 프로듀싱, 컨슈밍

### 장점
* Producer, Consumer 의 느슨한 결합을 통한 높은 확장성
* Producer, Consumer 가 서로의 IP정보를 알 필요가 없으므로 서비스 디스커버리 불필요
* 메시지 버퍼링을 통한 영속성 향상, 비동기 처리에 따른 성능 향상
> 추가적으로 유연한 통신(?), 명시적 IPC(?) 

### 단점
* 잠재적 보틀넥 포인트
* 잠재적 단일 장애점
* 운영 복잡도 증가 및 운영 리소스 비용 증가

> cf) 브로커리스 메시징
> * 브로커 없이 Producer - Consumer 가 직접 메시지 통신
> * 동기 통신에 비해 장점이 없어 거의 사용하지 않음
> * 장점
> 	* 중간에 거치는 과정이 없으므로 딜레이가 적고 네트워크 트래픽 비용이 적음
> 	* 운영 복잡도가 낮고 리소스 절약 가능
> * 단점
> 	* IP 주소를 알아야하므로 서비스 디스커버리 수행 필요, 그에 따른 부하 증가
> 	* Producer, Consumer 모두 가용한 상태일때에만 메시지 통신이 가능하므로 가용성 떨어짐
> 	* 전달보장등의 장치 적용에 어려움 

### 메시지 순서 유지
* 단일 파티션 내에선 FIFO 를 보장하므로 파티션 키 지정을 통해 메시지 순서 보장 가능
* 메시지 키가 분산도가 떨어지면 특정 파티션에 메시지가 몰리므로 적절한 메시지 키 설정 및 분산 정도 확인 필요
> 고객의 ID 가 파티션 키로 사용되고 어떤 고객이 트래픽의 90% 를 생성한다면 하나의 파티션이 90% 의 트래픽을 감당하게 되어 브로커 장애로 이어질 수 있음 

### 중복 메시지 처리
* 메시지별로 offset 할당 및 offset commit 을 통해 파티션별로 마지막으로 처리한 offset 정보를 별도 테이블(_consumer_offset)에 저장, 관리 함으로서 중복 메시지 처리 방지 