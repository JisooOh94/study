# 메시징 패턴
* 메시징 패턴을 이용해 비동기 IPC 수행
* 메시지
	* 헤더 + 바디로 구성
	* 데이터 / 커맨드 / 이벤트 등의 정보 표현
* 메시지 채널
	* 메시지가 프로듀싱 / 컨슈밍되는 메시지 보관함
	* 프로듀서 - 컨슈머 관계에 따라 점대점(1:1), 발행-구독(1:N) 메시지 채널 선택
		* 점대점 : 채널을 컨슈밍하는 서버중 하나의 서버를 선택하여 해당 서버만 메시지 컨슈밍 가능
		* 발행-구독 : 채널을 컨슈밍하는 모든 서버가 메시지 컨슈밍 가능

### 메시징 패턴 종류
* 단방향 알림
	* 클라이언트 - 서버 점대점 통신
	* 클라이언트 > 서버로의 메시지 전송만 이루어지고, 서버 > 클라이언트로의 응답은 이루어지지 않는 구조
	* 서버는 수신한 메시지의 처리만 수행한 하고, 수행 결과를 따로 클라이언트에게 전달하지 않음
	* 커맨드 메시지에 주로 사용
* 발행/구독
	* publisher - channel - subscriber 간 통신
	* publisher 와 subsciber는 서로를 몰라도 되며, channel 를 통해 메시지 프로듀싱, 컨슈밍
		* publisher 와 subscriber 간 결합도가 낮으므로 확장성이 더 뛰어남
	* 메시지 토픽별로 channel이 나뉘어져 있음
	* 이벤트 메시지에 주로 사용
* 발행/비동기응답
	* 클라이언트 - 요청 channel, 응답 channel - 서버 간 통신
	* 클라이언트는 요청메시지를 요청 channel 에 발행. 요청 메시지에 응답을 수신할 응답 channel 정보 및 메시지 ID(MessageId) 포함 
	* 서버는 요청 channel 에서 컨슈밍하여 요청 처리후, 그에 대한 응답을 응답 channel 에 발생, 응답 메시지에 메시지 ID(CorrelationId) 포함
	* 클라이언트는 응답 chaneel 에서 응답 메시지 컨슈밍 후, correlationId 를 통해 요청 메시지와 매칭 수행

### 메시징 패턴별 API 인터페이스 작성법
* 단방향 알림 API : 메시지 채널, 메시지 타입과 포맷
* 발행/구독 API : 메시지 채널, 메시지 타입과 포맷
* 발행/비동기응답 API : 메시지 채널, 메시지 타입과 포맷, 응답 메시지의 타입과 포맷

<br>

# 메시지 브로커
* 메시지 채널을 관리한느 별도의 서버
* Producer, Consumer 는 메시지 브로커로부터 프로듀싱, 컨슈밍

### 장점
* Producer, Consumer 의 느슨한 결합을 통한 높은 확장성
* Producer, Consumer 가 서로의 IP정보를 알 필요가 없으므로 서비스 디스커버리 불필요
* 메시지 버퍼링을 통한 영속성 향상, 비동기 처리에 따른 성능 향상
> 추가적으로 유연한 통신(?), 명시적 IPC(?) 

### 단점
* 잠재적 보틀넥 포인트
* 잠재적 단일 장애점
* 운영 복잡도 증가 및 운영 리소스 비용 증가

> cf) 브로커리스 메시징
> * 브로커 없이 Producer - Consumer 가 직접 메시지 통신
> * 동기 통신에 비해 장점이 없어 거의 사용하지 않음
> * 장점
> 	* 중간에 거치는 과정이 없으므로 딜레이가 적고 네트워크 트래픽 비용이 적음
> 	* 운영 복잡도가 낮고 리소스 절약 가능
> * 단점
> 	* IP 주소를 알아야하므로 서비스 디스커버리 수행 필요, 그에 따른 부하 증가
> 	* Producer, Consumer 모두 가용한 상태일때에만 메시지 통신이 가능하므로 가용성 떨어짐
> 	* 전달보장등의 장치 적용에 어려움


<br>

# 메시징 패턴의 문제 및 해결방법
### 메시지 순서 유지
* 경우에 따라 메시지가 발행된 순서대로 처리되어야하는 케이스 존재 
* 단일 파티션 내에선 FIFO 를 보장하므로 파티션 키 지정을 통해 메시지 순서 보장 가능
* 메시지 키가 분산도가 떨어지면 특정 파티션에 메시지가 몰리므로 적절한 메시지 키 설정 및 분산 정도 확인 필요
> 고객의 ID 가 파티션 키로 사용되고 어떤 고객이 트래픽의 90% 를 생성한다면 하나의 파티션이 90% 의 트래픽을 감당하게 되어 브로커 장애로 이어질 수 있음 

### 중복 메시지 처리
* 버그, 장애등으로 메세지가 중복 처리되는경우 문제가 발생하는 케이스 존재 (e.g. 결제 정보 누적 update)
* 메시지별로 offset 할당 및 offset commit 을 통해 파티션별로 마지막으로 처리한 offset 정보를 별도 테이블(_consumer_offset)에 저장, 관리 함으로서 중복 메시지 처리 방지

### 트랜잭셔널 메시징
* DB 수정과 메세지 발행이 원자적으로 수행되어야 하는 케이스 존재 (e.g. 결제 정보 update 및 결제 알림 발송)
* JTA 등의 분산 트랜잭션을 이용하거나 메시지를 DB(OUTBOX 테이블) 에 우선적으로 저장하여 DB 수정과 함께 하나의 트랜잭션으로 처리
* DB 에 저장한 메시지는 별도 컴포넌트에서 주기적으로 조죄하여 브로커에 메시지 발생
	* 메시지 폴링 방식
		* 주기적으로 OUTBOX 테이블에서 메시지 조회하여 브로커에 발행
		* OUTBOX 테이블에 저장되는 메시지가 많을 경우, DB에 가해지는 부하가 커지므로 비효율적
	* 로그 테일링 방식
		* OUTBOX 테이블에 수행된 insert 쿼리를 릴레이 로그로부터 읽어 메시지로 파싱하여 브로커에 발행
		* DB 부하 적음
 
<br>

# 비동기 IPC 적용
* MSA 환경에서 모든 요청은 Non blocking 방식의 비동기 IPC 로 처리하는것이 효율적 (고가용성, 영속성, 확장성)
* 주로 메시지 채널을 이용한 발행/비동기 응답 메시지 패턴을 이용해 비동기 IPC 를 구축하며 필요에 따라 데이터 복제나 선응답 후처리 방식도 활용

### 데이터 복제
* 요청 처리에 필요한 데이터이나 타 컴포넌트가 소유하고 있고 자주 변경되지 않는 데이터(e.g. 식당의 메뉴정보)의 경우 활용
* 해당 데이터를 요청 처리 컴포넌트에 복사하여 유지, 요청 처리시 타 컴포넌트와 통신 없이 복사본을 이용하여 처리
* 데이터가 수정될시, 데이터 소유 컴포넌트에서 데이터 수정 이벤트 메시지 발행, 요청 처리 컴포넌트에서 메시지 컨슈밍 하여 복사본 동기화 
* 복사해야할 데이터가 대용량일 경우 비효율적

### 선응답 후처리
* 클라이언트 요청에 대해 즉시 처리 필요한 요청이 아닌경우(e.g. 주문접수), 선 응답 후 후처리 하는 방식
* 요청 수신 컴포넌트는 메시지 채널에 요청 메시지 발행후 응답, 요청 처리 컴포넌트들이 메시지 컨슈밍하여 처리 수행
* 요청 처리에 따른 응답이 필요한 경우, 클라이언트에서 폴링해가거나, 서비스에서 응답 채널에 메시지 발행