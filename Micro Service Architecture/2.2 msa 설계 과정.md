# msa 설계 과정
# 1. 시스템 작업 식별
* 서비스 기능별 이용 시나리오 작성 및 그를 바탕으로 서비스에 필요한 작업 및 그 API 정의

### 시나리오 작성
* 특정 서비스 기능을 이용하는 시나리오를 상상하여 given(전체) - when(조건) - then(결과) 구조에 따라 작성
* e.g. 배달 어플의 음식 주문하기 기능
	* given
		* 식당이 영업중이고 배달가능한 상태이어야 함
		* 소비자의 지역이 배달가능한 지역이어야 함
		* 소비자의 주문 총액이 최소 주문금액 이상이어야 함
	* when
		* 소비자가 음식을 주문
	* then
		* 결제 창으로 화면 전환
		* 주문 정보 결제 컴포넌트로 전달

### 대략적인 클래스 구성
* 작성한 시나리오의 명사에 초점을 맞춰 시나리오의 기능을 수행하기 위해 필요한 대략적인 클래스 구성
* e.g. 배달 어플의 음식 주문하기 기능
	* 식당 : 주소, 영업 상태, 배달 상태, 메뉴 정보, 최소 주문금액 정보 
	* 소비자 : 주소, 아이디
	* 주문 : 주문 식당, 주문 메뉴, 주문 금액, 주문 사용자 

### 클래스 API 정의
* 작성한 시나리오의 동사에 초점을 맞춰 각 클래스의 동작 및 그 API 정의
* e.g. 배달 어플의 음식 주문하기 기능
	* 식당 : getStatus, checkDeliveryRegion, checkMinOrderAmount
	* 소비자 : getAddress, getId
	* 주문 : getRestauRantId, getUserId, getOrderAmount, getOrderMenus
	
### 클래스 API 명세 작성
* API 정의 후, 각 API 의 명세(파라미터, 반환값, 선행조건, 수행결과) 작성하여 구체화
* e.g. 식당의 checkDeliveryRegion
	* 파라미터 : 목적지 주소
	* 반환값 : 배달 가능 여부
	* 선행조건
		* 식당이 영업중이고, 배달 가능 상태 이어야함
		* 소비자의 주문금액이 식당의 최소 주문 금액 이상이어야함
	* 수행결과
		* 배달 가능 지역 여부 반환

<br>

# 2. 서비스 식별(분해)
* 서비스의 기능에 따라 컴포넌트 구성

### 컴포넌트 구성 방법
#### 비즈니스 능력에 따른 구성
* 비즈니스 능력 : 서비스의 기능
* 서비스가 제공하는 기능 및 그 기능을 수행하기 위한 하위 기능을 먼저 정의
* 연관된 기능들을 하나의 컴포넌트로 구성
* 기능을 기반으로 아키텍쳐를 설계하기 때문에 아키텍쳐의 확장성 및 유지보수성이 뛰어남
	* 각 기능의 동작방식이나 세세한 스펙은 바뀔 수 있어도, 서비스의 기능 자체는 거의 변경될일이 없으므로
  
#### 하위 도메인에 따른 구성
* DDD 방법론에 따라 서비스의 도메인과 그 도메인을 구성하는 하위 도메인 정의ㅡ
* 정의한 하위 도메인별로 도메인 모델(도메인이 담당하는 기능을 수행하기 위한 컴포넌트 구성) 따로 정의
* 정의한 각 하위 도메인의 모델을 경계 컨텍스트라고 하며, MSA에서의 각 컴포넌트를 의미
 
### 컴포넌트 구성시 주의 사항
#### 단일 책임 원칙
* 변경 사유가 오직 하나인 컴포넌트를 정의해야 함 > 하나의 컴포넌트는 하나의 책임(기능)만 가지고있어야 함
* 이를 통해, 더 작고 안정적이며 유지보수에 용이한 컴포넌트 개발 가능

#### 공동 폐쇄 원칙
* 패키지의 클래스들은 동일한 유형의 변경에 닫혀 있어야 함 > 한 기능을 수행하기 위한 하위 기능을 담당하는 클래스(컴포넌트)들은 동일한 패키지에 있어야 함
* 기능 수정시, 함께 수정되는 컴포넌트들은 하나의 컴포넌트로 통합 필요
* 이를 통해 스펙 변경시, 수정 및 배포해야하는 컴포넌트수가 줄어들어 유지보수에 용이해짐

<br>

# 3. 서비스 API 및 협동 정의
* 1번 과정에서 정의한 동작 API 들을 2번 과정에서 정의한 각 컴포넌트에 할당
	* 동작을 수행하기 위해 어느 컴포넌트가 진입점이 되어야 할지 결정
* 동작을 수행하기 위해 필요한 부가 동작들을 정의하고, 그 부가 동작들을 어느 컴포넌트에서 수행할지 결정