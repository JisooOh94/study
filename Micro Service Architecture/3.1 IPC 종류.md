# API 유지보수
* API 수정은 하위호환 여부에 따라 대응 방식이 달라짐

### 하위호환 가능
* 비필수 요청 파라미터를 추가하거나, 응답 필드를 추가하는 등의 수정
* 하위호환을 보장하기 위해선, 구버전 API 요청으로 들어올 수 있는 모든 예외 케이스에 대한 방어로직 필요

### 하위호환 불가능
* 배포 시점에, API 를 사용하는 모든 클라이언트가 새로운 API 로 사용하도록 수정을 강제하는것은 불가능
* 따라서, 모든 클라이언트가 수정 배포할때까지, 일정기간동안은 신/구버전 API 모두 제공 필요
* 신/구버전 API 구분시 주로 시맨틱 버저닝 방식 사용

> 시맨틱 버저닝
> * API 수정시, 수정된 API 각각에 버전 번호 할당
> * 수정 내용의 하위호환 여부에 따라, 버전 번호를 MAJOR(하위호환 X, 로직변경), MINOR(하위호환 O, 로직변경), PATCH(하휘호환 O, 버그수정) 세 파트로 나누어 '.' 으로 구분하여 표시
> 	* e.g. 16.13.1
> * API 구분을 위해 시맨틱 버저닝 사용시, 주로 각 API 호출 url 에 MAJOR 버전 정보를 추가하여 구분
> 	* e.g. /v1/user/salary, /v2/user/salary

<br>

# IPC 종류
* IPC : Inter Process Communication, MSA 환경에서 각 컴포넌트간 통신 방법
* IPC 는 MSA 구조 애플리케이션 가용성 및 성능에 큰 비중을 차지하므로 신중이 선택 필요
 
### 요청 처리 주체에 따라
* 일대일
	* 클라이언트의 요청을 하나의 컴포넌트에서 처리
* 일대다
	* 클라이언트의 요청을 여러 컴포넌트가 협동하여 처리 

### 응답 시점에 따라
* 동기
	* Sync + blocking
* 비동기
	* Async + Non blocking
* 단방향
	* 서비스는 응답 보내지 않음, 클라이언트는 서비스에 일방적으로 요청만 전송
	* 대표적으로 발행-구독 형식
* 비동기 + 단방향
	* 클라이언트는 응답 채널 헤더가 명시된 요청 메시지를 브로커에 프로듀싱
	* 컨슈머는 CorrelationId가 포함된 응답 메시지를 지정된 응답 채널에 발송
	* 클라이언트는 이 CorrelationId로 응답을 취합하여 응답 메시지와 요청을 검증

### 응답 메시지 포맷에 따라
* 텍스트
	* JSON, XML
	* 장점 : human-readable, self-discriptiveness
	* 단점
		* 텍스트 데이터 이므로 메시지 크기가 커짐에 따라 네트워크 트래픽 비용 증가
		* 바이너리 데이터에 비해 직렬화/역직렬화 파싱 부하가 큼
* 바이너리
	* protocol-buffer, AVRO