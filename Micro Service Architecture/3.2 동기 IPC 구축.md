# RPI
* Remote Procedure Invocation
* 컴포넌트간 통신하는 방법중 하나
* 클라이언트 요청 전송 - 서버 응답 통신 방식
* 비즈니스 로직과 통신부가 인터페이스로 느슨하게 결합되어 동작

<br>

# 동기 IPC 통신 방식 종류
* Rest : HTTP 기반 통신 프로토콜
* gRpc : 컴포넌트간 통신시, 일반 메소드 호출하는 방식으로 수행할 수 있는 프로토콜

<br>

# 동기 IPC 의 문제점 1. 부분 실패
* 다른 컴포넌트 API 호출시, blocking 방식으로 동작하기때문에 부하 및 장애가 전체 서비스로 전파될 수 있음
* 접속 차단이나 fallback value 반환등으로 대응 가능

### 접속 차단
* 네트워크 타임아웃
	* 클라이언트에서 응답 대기 timeout 을 설정하여 무한 응답 대기 방지
* 미처리 요청 개수 제한
	* 클라이언트에서 특정 컴포넌트로의 요청 가능한 미처리 요청 개수 제한을 설정
	* 컴포넌트로의 부하 무한 가중 방지 및 무한 응답 대기 방지
* 회로 차단기 패턴
	* 클라이언트에서 컴포넌트로의 요청에 대한 성공/실패 비율을 모니터링하여, 비율이 임계점을 넘는경우, 해당 컴포넌트로의 추가적인 요청은 바로 실패로 처리
	* 컴포넌트로의 부하 무한 가중 방지 및 무한 응답 대기 방지

### fallback value 반환
* 클라이언트의 요청에 응답하기 위한 데이터를 타 컴포넌트에 요청했을때 실패한경우, 미리 설정한 default value 나 캐싱해준 value 로 반환
* 일대다 요청인 경우, 실패한 API 데이터를 제외한 나머지 정상 처리 API 데이터만이라도 응답

<br>

# 동기 IPC 의 문제점 2. 유동 IP
* 클라우드 기반의 MSA 아키텍쳐에선 컴포넌트마다 유동 IP 를 할당받아 동작
* 클라우드 기반으로 여러가지 상황에 따라 서버의 자동 확장, 절체, 업그레이드 등의 작업이 빈번히 발생
* 그에 따라 컴포넌트의 IP 변경도 빈번히 발생하므로 컴포넌트들의 IP 주소에 대한 별도의 관리 필요
* 서비스 디스커버리를 통해 관리 수행

### 서비스 디스커버리
* 현재 동작중인 서비스 컴포넌트들의 IP, PORT 정보를 서비스 레지스트라는 일종의 DB 에 저장 관리
* 서비스 디스커버리에서 컴포넌트들의 IP,PORT 정보 등록 및 삭제, 클라이언트의 요청 프록시 수행
* 서비스 디스커버리는 2가지 방식 존재
	* 애플리케이션 레벨 서비스 디스커버리
		* 클라이언트, 서비스가 직접 서비스 레지스트리 접근, 사용
		* 서비스 인스턴스가 시작/종료 될떄마다 인스턴스에서 직접 서비스 레지스트리 업데이트
			* 종료된 인스턴스의 제거는 health check url이나 heartbeat api 호출을 이용
		* 클라이언트는 서비스 레지스트리에서 가용한 인스턴스 목록 직접 조회하여 요청 전송
			* 인스턴스 목록을 캐싱하여 성능 향상 가능
		* 인프라 플랫폼엔 독립적이나, 언어 및 프레임워크에 종속되고, 개발자가 직접 서비스 디스커버리를 신경써야한다는 단점 존재
		* 대표적으로 유레카 + 스프링 클라우드 
	* 인프라 프레임워크 제공 서비스 디스커버리
		* 인프라 프레임워크(e.g. 쿠버네티스) 에서 자체적으로 서비스 디스커버리, 레지스트리를 내장하여 기능 제공
		* 서비스 인스턴스 시작/종료시, 인프라에 내장된 서드파티(일종의 등록기)가 레지스트리에 업데이트 수행
		* 클라이언트는 DNS/VIP 로 요청을 전송하고 그를 인프라에서 가용한 인스턴스로 프록시 (일종의 L4 스위치 처럼 동작)
		* 개발자는 비즈니스 로직에 집중할 수 있어 생산성이 향상되나 인프라 플랫폼에 종속적이 된다는 단점 존재