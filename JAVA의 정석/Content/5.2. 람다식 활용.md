# ***람다식 활용***
# 사전 정의 함수형 인터페이스
* java.util.function 패키지에 내장되어있는 함수형 인터페이스
* 자주 사용되는 매개변수, 리턴타입의 함수형 인터페이스를 미리 정의해둠
* 매번 새로운 함수형 인터페이스를 정의하기보다 기존에 이미 정의되어있는 함수형 인터페이스를 재활용함으로서 메서드 이름 통일을 통한 가독성 증가 및 재사용성, 유지보수 효율성 증가
### 전달인자 1개 이하 함수형 인터페이스
|인터페이스 명|가상함수명|return 타입|전달인자|사용예시|
|:---------------:|:-------:|:------------:|:--------:|:------|
|Runnable|run|void|없음||
|Supplier< T >|get|T|없음||
|Consumer< T >|accept|없음|T||
|Function< T,R >|apply|R|T||
|Predicate< T >|test|boolean|T||
|UnaryOperator< T >|apply|T|T||
```java
Runnable runnable = () -> System.out.println(DateUtils.now);
runnable.run();

Supplier<Date> supplier = () -> { return DateUtils.now; };
Date now = supplier.get();

Consumer<String> consumer = str -> System.out.println(str);
consumer.accept("Hello World");

Function<Date, String> function = date -> { return "Today is " + date.toString() };
System.out.println(function.apply(DateUtils.now));

Predicate<Date> predicate = date -> { return date.getTimeMillis() > DateUtils.now.getTimeMillis(); };
if(predicate.test(new Date(2019.10.10)) {
	System.out.println("The date is future");
}
```

### 전달인자 2개 함수형 인터페이스
|인터페이스 명|가상함수명|return 타입|전달인자|사용예시|
|:---------------:|:-------:|:------------:|:--------:|:------|
|BiConsumer<T1,T2>|accept|없음|T1, T2||
|BiFunction<T1,T2,R>|apply|R|T1, T2||
|BiPredicate<T1,T2>|test|boolean|T1, T2||
|BinaryOperator< T >|apply|T|T|

<br>

*전달인자 3개 이상부터는 직접 정의하여 사용*

# 사전 정의 함수형 인터페이스 모듈
* 컬렉션 프레임웍(Collections)에 사전정의 함수형 인터페이스를 활용한 다양한 메서드들이 정의되어있음

|반환형|메서드명|파라미터|설명|
|:------:|:----------:|:----------:|:------|
|void|forEach|(Consumer< T> f|모든 요소에 작업(f) 수행|
|void|replaceAll|UnaryOperator< T> f|모든 요소의 값을 연산(UnaryOperaotr)을 거친 값으로 수정|
|boolean|removeIf|Predicate< T> f|조건식(Predicate)을 만족하는 요소 삭제|
|T|compute|String key, BiFunction<String,T,T> f|선택한 키의 value에 작업(f) 수행|
|T|computeIfAbsent|String key,Function<String,T> f|선택한 키가 없으면 작업(f)수행 후 추가|
|T|computeIfPresent|String key,BiFunction<String,T,T> f|선택한 키가 있으면 작업(f) 수행|
|T|merge|String key, T value, BiFunction<T,T,T> f|두 컬렉션 병합시, 모든 요소에 병합작업(f) 수행|
|void|forEach|BiConsumer<String,T> f|모든 요소에 작업(f) 수행|
|void|replaceAll|BiFunction<String,T,T> f|모든 요소에 교체작업(f) 수행|

```java
public static void main(String[] args) {
   List<Integer> list = new ArrayList<>();
   for(int i = 0; i<10 ;i++) {
      list.add(i);
   }
   Map<String, String> map = new HashMap<>();
   map.put("1", "1");
   
   list.forEach(i -> System.out.print(i+",");)

   list.replaceAll(i -> i*10);

   list.removeIf(x -> x%2==0 || x%3==0);
   
   map.forEach((k,v) -> System.out.print("K : " + k + " V : " + v));
}
```
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjk5MjIyODUxLC0xNzAyMjk4MTU2LDk1OT
IzMTA1Niw0MTAwODkyMTUsNDY4MzQ5MjI5LDE0MjEyMjQ5MjEs
LTE2MTk2MjU1NzQsMTU3NTQ2ODA3MV19
-->