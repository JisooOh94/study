# JVM
* 다른 언어들의 경우 컴파일러가 직접 소스코드를 실행환경 OS에 맞는 기계어로 번역하여 수행
* JAVA의 경우 컴파일러가 실행환경OS에 상관없이 동일한 반기계어(자바 바이트코드)로 번역 (빌드)
* 자바 바이트코드는 클래스로더에 의해 JVM 에 로드되고 JVM이 실행환경 OS에 맞는 기계어로 번역하여 수행
* JAVA 애플리케이션은 OS에 독립적이나 JVM은 OS 종속적 (Java 프로그램 실행시 PC 에 환경에 맞는 JDK(JVM) 이 설치되어있어야함)

### JAVA 프로그램 실행 과정
1. 프로젝트 빌드시 컴파일러(javac)가 소스코드(.java)를 읽어 바이트코드(.class)로 변환
2. 클래스 로더가 바이트코드들을 JVM으로 로딩
3. JVM에 로딩된 바이트코드들을 JVM의 실행엔진이 OS에 맞는 기계어(Native 코드)로 해석하여 실행

### JVM 실행엔진 종류
1. 인터프리터 방식
* 빌드과정 없이 런타임에 코드 한줄씩 빌드(바이트코드변환) + 번역(기계어변환) 하여 수행
* 한줄씩 읽어 변환 후 실행하므로 속도가 느림
* 코드 변경시 빌드 과정 없이 바로 변경된 코드로 실행 가능

2. JIT(Just In Time)
* 인터프리터 방식의 느린 실행속도라는 단점을 보완한 실행방식
* 빌드시 소스코드 > 바이트 코드 변환 후 런타임시 필요한 바이트코드만 한줄씩 기계어로 번역하여 수행
* 바이트코드 > 기계어 번역시 번역된 기계어를 캐싱하여, 추후 같은 코드 수행요청시 빠르게 수행 가능 
* 바이트코드 전체를 네이티브코드로 컴파일하는 과정은 오래걸리므로 재사용될 확률이 높은 코드들만 컴파일
* JVM이 자체적으로 코드를 분석하여 자주수행되는 메서드 선출

# 상수와 리터럴
### 상수
* 리터럴에 의미있는 이름을 붙인것
* 상수 명은 대문자로 설정
* 상수 선언 키워드 : final
### 리터럴
* 값 그자체, 이름이 없는 상수
* 접미사를 통해 타입 구분
    * float : F
    * long : L
    * 16진수 : 0x
    * 8진수 : 0


# 참조형 변수
* 참조형 변수 : 배열, 클래스
```JAVA
public void setDate(Date date) {
   date.setDate(date.getDate() + 100);
}

public void doubleValue(int[] arr) {
   for(int i = 0, i < arr.size(); i++) {
      arr[i] *= 2;
   }
}
```

# JVM 메모리 구조
### 1. 메서드 영역
* 프로그램 실행중 특정 클래스를 사용해야할때, 클래스파일로부터 읽어들인 해당 클래스에 대한 정보를 저장하는 영역
* 클래스 변수도 이곳에 저장
### 2. 힙
* 인스턴스 저장 공간
### 3. 콜스택
* 메서드 수행시 사용되는 지역변수, 연산 중간결과값등이 저장되는 공간

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5NTQ4MDYxMjZdfQ==
-->