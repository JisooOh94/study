# JVM
* 다른 언어들의 경우 컴파일러가 직접 소스코드를 실행환경 OS에 맞는 기계어로 번역하여 수행
* JAVA의 경우 컴파일러가 실행환경OS에 상관없이 동일한 반기계어(자바 바이트코드)로 번역 (빌드)
* 자바 바이트코드는 클래스로더에 의해 JVM 에 로드되고 JVM이 실행환경 OS에 맞는 기계어로 번역하여 수행
* JAVA 애플리케이션은 OS에 독립적이나 JVM은 OS 종속적 (Java 프로그램 실행시 PC 에 환경에 맞는 JDK(JVM) 이 설치되어있어야함)

### JAVA 프로그램 실행 과정
1. 프로젝트 빌드시 컴파일러(javac)가 소스코드(.java)를 읽어 바이트코드(.class)로 변환
2. 클래스 로더가 바이트코드들을 JVM으로 로딩
3. JVM에 로딩된 바이트코드들을 JVM의 실행엔진이 OS에 맞는 기계어(Native 코드)로 해석하여 실행

### JIT 컴파일러
* Java 의 default 컴파일러(옵션으로 off 가능, off 시 정적컴파일방식으로 동작)
* 기본적으로 인터프리터방식으로 동작하다 자주 사용되는 코드 발견시, 기계어로 컴파일하여 캐싱
* 추후 동일한 코드 수행 요청시, 인터프리터방식이 아닌, 캐싱된 기계어로 수행하게 되므로 수행속도 향상

> cf)
> 컴파일러(c/c++)
>* 소스코드를 전부 기계어로 변환하여 저장후 실행
>* 컴파일만 끝나면 런타임시점의 실행속도는 매우 빠름
>* 컴파일된 실행파일은 컴파일한 OS 및 빌드환경에 종속적
>	* 한 컴퓨터에서 컴파일한 실행파일은 다른 컴퓨터에서 제대로 동작 안할 수 있음

>cf) 인터프리터(java)
>* 반기계어를 런타임시점에 필요할때마다 기계어로 번역하여 실행
>* 코드 한줄한줄 매번 기계어로 번역한 후 실행되므로 실행속도 느림
>* 반기계어는 OS 및 빌드환경에 독립적
>	* 어느 컴퓨터에서든지 jvm만 설치되어있으면 운영체제, 빌드환경에 상관없이 정상적으로 실행됨 

# 상수와 리터럴
### 상수
* 리터럴에 의미있는 이름을 붙인것
* 상수 명은 대문자로 설정
* 상수 선언 키워드 : final
### 리터럴
* 값 그자체, 이름이 없는 상수
* 접미사를 통해 타입 구분
    * float : F
    * long : L
    * 16진수 : 0x
    * 8진수 : 0


# 참조형 변수
* 참조형 변수 : 배열, 클래스
```JAVA
public void setDate(Date date) {
   date.setDate(date.getDate() + 100);
}

public void doubleValue(int[] arr) {
   for(int i = 0, i < arr.size(); i++) {
      arr[i] *= 2;
   }
}
```

# JVM 메모리 구조
### 1. 메서드 영역
* 프로그램 실행중 특정 클래스를 사용해야할때, 클래스파일로부터 읽어들인 해당 클래스에 대한 정보를 저장하는 영역
* 클래스 변수도 이곳에 저장
### 2. 힙
* 인스턴스 저장 공간
### 3. 콜스택
* 메서드 수행시 사용되는 지역변수, 연산 중간결과값등이 저장되는 공간

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5NTQ4MDYxMjZdfQ==
-->